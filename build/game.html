<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maquette 3D - Letters Cascade Challenge</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÆ</text></svg>">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/shared.css">
    <script src="js/utils.js"></script>
    <style>
        /* Enhanced 3D Game Layout - Optimized for single screen */
        .page-layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: var(--spacing-2xl);
            min-height: 100vh;
            max-width: 1800px;
            margin: 0 auto;
            padding: var(--spacing-xl);
        }

        .nav-sidebar {
            background: rgba(255, 255, 255, 0.98);
            border-radius: var(--radius-2xl);
            padding: var(--spacing-2xl);
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            height: fit-content;
            position: sticky;
            top: var(--spacing-xl);
            transition: all 0.3s ease;
        }

        .nav-sidebar:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-2xl);
        }

        .nav-sidebar h3 {
            color: var(--primary-color);
            margin-bottom: var(--spacing-xl);
            font-size: 1.4rem;
            font-weight: 800;
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: var(--spacing-md);
            text-align: center;
        }

        .nav-links {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-lg);
        }

        .nav-links a {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            padding: var(--spacing-lg);
            border-radius: var(--radius-lg);
            text-decoration: none;
            color: var(--gray-700);
            font-weight: 600;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .nav-links a::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .nav-links a:hover::before {
            left: 100%;
        }

        .nav-links a:hover {
            background: rgba(102, 126, 234, 0.15);
            color: var(--primary-color);
            transform: translateX(8px) scale(1.02);
            box-shadow: var(--shadow-lg);
        }

        .nav-links a.active {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            box-shadow: var(--shadow-xl);
            transform: translateX(5px);
        }

        .nav-links a i {
            font-size: 1.2rem;
            width: 24px;
            text-align: center;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-2xl);
        }

        /* Enhanced Game Header */
        .game-header {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(255, 255, 255, 0.95));
            border-radius: var(--radius-2xl);
            padding: var(--spacing-2xl);
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .game-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 30% 20%, rgba(102, 126, 234, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 70% 80%, rgba(118, 75, 162, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        .game-header h1 {
            color: var(--primary-color);
            font-size: 2.5rem;
            font-weight: 900;
            margin-bottom: var(--spacing-lg);
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color), var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
            z-index: 1;
        }

        .game-header p {
            color: var(--gray-600);
            font-size: 1.2rem;
            line-height: 1.7;
            font-weight: 500;
            position: relative;
            z-index: 1;
        }

        /* Enhanced Game Container */
        .game-container {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(255, 255, 255, 0.95));
            border-radius: var(--radius-2xl);
            padding: var(--spacing-2xl);
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: var(--spacing-xl);
            min-height: 600px;
            position: relative;
            overflow: hidden;
        }

        .game-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
        }

        /* Enhanced Controls Section */
        .controls-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
            padding: var(--spacing-xl);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.08), rgba(118, 75, 162, 0.08));
            border-radius: var(--radius-xl);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .control-group h3 {
            color: var(--primary-color);
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .game-controls {
            display: flex;
            gap: var(--spacing-md);
            flex-wrap: wrap;
        }

        .game-controls .btn {
            padding: var(--spacing-md) var(--spacing-lg);
            font-size: 1rem;
            font-weight: 600;
            border-radius: var(--radius-lg);
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: var(--gray-700);
            min-width: 120px;
            position: relative;
            overflow: hidden;
        }

        .game-controls .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .game-controls .btn:hover::before {
            left: 100%;
        }

        .game-controls .btn:hover {
            background: rgba(102, 126, 234, 0.15);
            color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .game-controls .btn.active {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            box-shadow: var(--shadow-md);
        }

        /* Enhanced Game Grid Container */
        .game-grid-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(118, 75, 162, 0.05));
            border-radius: var(--radius-xl);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: var(--spacing-lg);
            position: relative;
            overflow: hidden;
        }

        .game-grid-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, rgba(102, 126, 234, 0.1) 0%, transparent 70%);
            pointer-events: none;
        }

        .grid-3d {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 1;
        }

        #gameGrid {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #gameGrid canvas {
            display: block !important;
            margin: 0 auto !important;
            border: 3px solid rgba(255, 255, 255, 0.4) !important;
            border-radius: 16px !important;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4) !important;
            transition: all 0.3s ease !important;
        }

        #gameGrid canvas:hover {
            transform: scale(1.02) !important;
            box-shadow: 0 16px 50px rgba(0, 0, 0, 0.5) !important;
        }

        /* Enhanced Game Info */
        .game-info {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--spacing-lg);
            margin-top: var(--spacing-xl);
        }

        .info-section {
            background: rgba(255, 255, 255, 0.9);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            box-shadow: var(--shadow-md);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .info-section:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .info-section h4 {
            color: var(--primary-color);
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .info-section .value {
            color: var(--gray-800);
            font-size: 1.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Enhanced Score Display */
        .score-display {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            margin-top: var(--spacing-lg);
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-align: center;
        }

        .score-display span {
            color: var(--gray-600);
            font-size: 1rem;
            font-weight: 600;
        }

        .score-display strong {
            color: var(--primary-color);
            font-size: 1.8rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Enhanced Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xl);
        }

        .sidebar-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .sidebar-section:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-xl);
        }

        .sidebar-section h3 {
            color: var(--primary-color);
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: var(--spacing-lg);
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: var(--spacing-md);
        }

        .sidebar-section p {
            color: var(--gray-700);
            line-height: 1.7;
            margin-bottom: var(--spacing-md);
            font-size: 1rem;
        }

        .sidebar-section strong {
            color: var(--primary-color);
            font-weight: 700;
        }

        /* Enhanced Word List */
        .word-list {
            max-height: 200px;
            overflow-y: auto;
            padding: var(--spacing-md);
            background: rgba(102, 126, 234, 0.05);
            border-radius: var(--radius-md);
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .word-list li {
            padding: var(--spacing-sm) var(--spacing-md);
            margin-bottom: var(--spacing-xs);
            background: rgba(255, 255, 255, 0.8);
            border-radius: var(--radius-sm);
            border-left: 3px solid var(--primary-color);
            transition: all 0.3s ease;
            font-size: 0.95rem;
            font-weight: 500;
        }

        .word-list li:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: translateX(5px);
        }

        .word-list li.completed {
            background: rgba(76, 175, 80, 0.1);
            border-left-color: var(--success-color);
            color: var(--success-color);
        }

        /* Enhanced Letter Queue */
        .letter-queue {
            margin-top: var(--spacing-lg);
        }

        .queue-display {
            display: flex;
            gap: var(--spacing-sm);
            flex-wrap: wrap;
            justify-content: center;
        }

        .queue-letter {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-radius: var(--radius-md);
            font-size: 1.2rem;
            font-weight: 700;
            box-shadow: var(--shadow-md);
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .queue-letter:hover {
            transform: scale(1.1) rotate(5deg);
            box-shadow: var(--shadow-lg);
        }

        /* Enhanced Full Screen Styles for 3D Game */
        .game-container.fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999 !important;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%) !important;
            border-radius: 0 !important;
            padding: 0 !important;
            margin: 0 !important;
            display: flex !important;
            flex-direction: column !important;
            overflow: hidden !important;
            animation: fullscreenEnter 0.5s ease-out !important;
        }

        @keyframes fullscreenEnter {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .game-container.fullscreen .game-header {
            background: rgba(0, 0, 0, 0.8) !important;
            backdrop-filter: blur(20px) !important;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1) !important;
            padding: 1rem 2rem !important;
            margin: 0 !important;
            border-radius: 0 !important;
            animation: slideDown 0.5s ease-out !important;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .game-container.fullscreen .game-header h1 {
            font-size: 2rem !important;
            margin: 0 !important;
            background: linear-gradient(135deg, #667eea, #764ba2) !important;
            -webkit-background-clip: text !important;
            -webkit-text-fill-color: transparent !important;
            background-clip: text !important;
        }

        .game-container.fullscreen .controls-section {
            background: rgba(0, 0, 0, 0.8) !important;
            backdrop-filter: blur(20px) !important;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1) !important;
            padding: 1rem 2rem !important;
            margin: 0 !important;
            border-radius: 0 !important;
            animation: slideDown 0.5s ease-out 0.1s both !important;
        }

        .game-container.fullscreen .game-grid-container {
            flex: 1 !important;
            margin: 0 !important;
            border-radius: 0 !important;
            background: transparent !important;
            border: none !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            padding: 2rem !important;
            position: relative !important;
        }

        .game-container.fullscreen .game-grid-container::before {
            content: '' !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            background: radial-gradient(circle at center, rgba(102, 126, 234, 0.1) 0%, transparent 70%) !important;
            pointer-events: none !important;
        }

        .game-container.fullscreen #gameGrid canvas {
            max-width: 90vw !important;
            max-height: 90vh !important;
            width: auto !important;
            height: auto !important;
            border: 3px solid rgba(255, 255, 255, 0.3) !important;
            border-radius: 16px !important;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5) !important;
            animation: canvasAppear 0.8s ease-out 0.3s both !important;
        }

        @keyframes canvasAppear {
            from {
                opacity: 0;
                transform: scale(0.8) rotateY(15deg);
            }
            to {
                opacity: 1;
                transform: scale(1) rotateY(0deg);
            }
        }

        .game-container.fullscreen .game-info {
            background: rgba(0, 0, 0, 0.8) !important;
            backdrop-filter: blur(20px) !important;
            border-top: 1px solid rgba(255, 255, 255, 0.1) !important;
            padding: 1rem 2rem !important;
            margin: 0 !important;
            border-radius: 0 !important;
            animation: slideUp 0.5s ease-out 0.2s both !important;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .game-container.fullscreen .info-section {
            background: rgba(255, 255, 255, 0.1) !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            padding: 1rem !important;
            border-radius: 8px !important;
            transition: all 0.3s ease !important;
        }

        .game-container.fullscreen .info-section:hover {
            background: rgba(255, 255, 255, 0.15) !important;
            transform: translateY(-2px) !important;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.2) !important;
        }

        .game-container.fullscreen .info-section h4 {
            color: rgba(255, 255, 255, 0.8) !important;
        }

        .game-container.fullscreen .info-section .value {
            background: linear-gradient(135deg, #667eea, #764ba2) !important;
            -webkit-background-clip: text !important;
            -webkit-text-fill-color: transparent !important;
            background-clip: text !important;
        }

        .game-container.fullscreen .btn {
            padding: 0.75rem 1.5rem !important;
            font-size: 1rem !important;
            font-weight: 600 !important;
            border-radius: 8px !important;
            transition: all 0.3s ease !important;
            border: 2px solid rgba(255, 255, 255, 0.2) !important;
            background: rgba(255, 255, 255, 0.1) !important;
            color: white !important;
        }

        .game-container.fullscreen .btn:hover {
            transform: translateY(-2px) !important;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4) !important;
            background: rgba(255, 255, 255, 0.2) !important;
        }

        .game-container.fullscreen .btn.active {
            background: linear-gradient(135deg, #667eea, #764ba2) !important;
            border-color: rgba(255, 255, 255, 0.4) !important;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3) !important;
        }

        /* Full Screen Exit Button */
        .fullscreen-exit {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            width: 50px !important;
            height: 50px !important;
            background: rgba(255, 255, 255, 0.1) !important;
            backdrop-filter: blur(10px) !important;
            border: 2px solid rgba(255, 255, 255, 0.2) !important;
            border-radius: 50% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            cursor: pointer !important;
            z-index: 10000 !important;
            font-size: 1.5rem !important;
            color: white !important;
            transition: all 0.3s ease !important;
            animation: exitButtonAppear 0.5s ease-out 0.4s both !important;
        }

        @keyframes exitButtonAppear {
            from {
                opacity: 0;
                transform: scale(0.5) rotate(180deg);
            }
            to {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
        }

        .fullscreen-exit:hover {
            background: rgba(255, 255, 255, 0.2) !important;
            transform: scale(1.1) !important;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3) !important;
        }

        /* Full Screen Sidebar */
        .game-container.fullscreen .sidebar {
            position: fixed !important;
            right: 20px !important;
            top: 50% !important;
            transform: translateY(-50%) !important;
            width: 300px !important;
            max-height: 80vh !important;
            background: rgba(0, 0, 0, 0.8) !important;
            backdrop-filter: blur(20px) !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            border-radius: 16px !important;
            padding: 1.5rem !important;
            overflow-y: auto !important;
            z-index: 10001 !important;
            animation: sidebarSlideIn 0.6s ease-out 0.5s both !important;
        }

        @keyframes sidebarSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50%) translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateY(-50%) translateX(0);
            }
        }

        .game-container.fullscreen .sidebar-section {
            background: rgba(255, 255, 255, 0.05) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            border-radius: 12px !important;
            padding: 1rem !important;
            margin-bottom: 1rem !important;
            transition: all 0.3s ease !important;
        }

        .game-container.fullscreen .sidebar-section:hover {
            background: rgba(255, 255, 255, 0.08) !important;
            transform: translateX(-5px) !important;
        }

        .game-container.fullscreen .sidebar-section h3 {
            font-size: 1.1rem !important;
            margin-bottom: 0.75rem !important;
            color: rgba(255, 255, 255, 0.9) !important;
        }

        .game-container.fullscreen .sidebar-section p {
            font-size: 0.9rem !important;
            line-height: 1.5 !important;
            color: rgba(255, 255, 255, 0.7) !important;
        }

        /* Full Screen Word List */
        .game-container.fullscreen .word-list {
            max-height: 200px !important;
            overflow-y: auto !important;
        }

        .game-container.fullscreen .word-list li {
            padding: 0.5rem 0.75rem !important;
            margin-bottom: 0.5rem !important;
            font-size: 0.9rem !important;
            transition: all 0.3s ease !important;
        }

        .game-container.fullscreen .word-list li:hover {
            background: rgba(102, 126, 234, 0.2) !important;
            transform: translateX(5px) !important;
        }

        /* Full Screen Letter Queue */
        .game-container.fullscreen .letter-queue {
            margin-top: 1rem !important;
        }

        .game-container.fullscreen .queue-display {
            display: flex !important;
            gap: 0.5rem !important;
            flex-wrap: wrap !important;
        }

        .game-container.fullscreen .queue-letter {
            width: 40px !important;
            height: 40px !important;
            font-size: 1.2rem !important;
            transition: all 0.3s ease !important;
        }

        .game-container.fullscreen .queue-letter:hover {
            transform: scale(1.1) !important;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3) !important;
        }

        /* Responsive Full Screen */
        @media (max-width: 1200px) {
            .game-container.fullscreen .controls-section {
                grid-template-columns: 1fr !important;
                gap: 1rem !important;
            }
            
            .game-container.fullscreen .sidebar {
                width: 250px !important;
            }
        }

        @media (max-width: 768px) {
            .game-container.fullscreen .game-header h1 {
                font-size: 1.5rem !important;
            }
            
            .game-container.fullscreen .controls-section {
                padding: 0.75rem 1rem !important;
            }
            
            .game-container.fullscreen .game-info {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 1rem !important;
            }
            
            .game-container.fullscreen .sidebar {
                position: static !important;
                width: 100% !important;
                max-height: none !important;
                transform: none !important;
                margin-top: 1rem !important;
            }
            
            .game-container.fullscreen #gameGrid canvas {
                max-width: 95vw !important;
                max-height: 60vh !important;
            }
        }

        /* Responsive Design */
        @media (max-width: 1400px) {
            .page-layout {
                grid-template-columns: 280px 1fr;
                gap: var(--spacing-xl);
            }
        }

        @media (max-width: 1200px) {
            .page-layout {
                grid-template-columns: 250px 1fr;
                gap: var(--spacing-lg);
            }
            
            .game-container {
                grid-template-columns: 1fr 300px;
            }
        }

        @media (max-width: 768px) {
            .page-layout {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                gap: var(--spacing-lg);
            }
            
            .nav-sidebar {
                position: static;
                margin-bottom: var(--spacing-lg);
            }
            
            .game-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
            }
            
            .game-header h1 {
                font-size: 2rem;
            }
            
            .controls-section {
                grid-template-columns: 1fr;
            }
            
            .game-info {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Animation Enhancements */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .game-container {
            animation: fadeInUp 0.6s ease-out;
        }

        .sidebar-section {
            animation: fadeInUp 0.6s ease-out;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="page-layout">
            <!-- Navigation Menu -->
            <div class="nav-sidebar">
                <h3>Navigation</h3>
                <div class="nav-links">
                    <a href="index.html"><i class="fas fa-home"></i> Accueil</a>
                    <a href="prototype.html"><i class="fas fa-flask"></i> Maquette 2D</a>
                    <a href="game.html" class="active"><i class="fas fa-gamepad"></i> Maquette 3D</a>
                    <a href="GDD.html"><i class="fas fa-file-alt"></i> Documentation</a>
                    <a href="moodboard.html"><i class="fas fa-palette"></i> Moodboard</a>
                    <a href="sitemap.html"><i class="fas fa-sitemap"></i> Plan de Site</a>
                </div>
        </div>

            <div class="main-content">
                <div class="game-section">
                    <!-- Enhanced Game Header -->
                    <div class="game-header">
                        <h1>üéÆ Maquette 3D - Letters Cascade Challenge</h1>
                        <p>Mode immersif avec grille 3D - Jouabilit√© avanc√©e</p>
        </div>

                    <div class="game-container">
                        <!-- Enhanced Controls Section -->
                        <div class="controls-section">
                            <div class="control-group">
                                <h3><i class="fas fa-gamepad"></i> Contr√¥les du Jeu</h3>
                                <div class="game-controls">
                                    <button id="startBtn" class="btn">
                                        <i class="fas fa-play"></i> D√©marrer
                                    </button>
                                    <button id="pauseBtn" class="btn">
                                        <i class="fas fa-pause"></i> Pause
                                    </button>
                                    <button id="resetBtn" class="btn">
                                        <i class="fas fa-redo"></i> Reset
                                    </button>
                                    <button id="fullscreenBtn" class="btn" onclick="toggleFullScreen()">
                                        <i class="fas fa-expand"></i> Plein √âcran
                                    </button>
                                </div>
            </div>

                            <div class="control-group">
                                <h3><i class="fas fa-cog"></i> Configuration</h3>
                                <div class="mode-selection">
                                    <button class="mode-btn" data-mode="2d">
                                        <i class="fas fa-square"></i> Mode 2D
                                    </button>
                                    <button class="mode-btn active" data-mode="3d">
                                        <i class="fas fa-cube"></i> Mode 3D
                                    </button>
                    </div>
                                <div class="grid-selection">
                                    <button class="grid-btn" data-size="8x8">8√ó8</button>
                                    <button class="grid-btn active" data-size="10x10">10√ó10</button>
                                    <button class="grid-btn" data-size="12x12">12√ó12</button>
                </div>
                </div>
            </div>

                        <!-- Enhanced Game Grid -->
                        <div class="game-grid-container">
                            <div id="gameContainer" class="grid-3d">
                                <div id="gameGrid" class="grid-cube grid-10x10">
                                    <!-- Grid will be generated by JavaScript -->
                </div>
            </div>
        </div>

                        <!-- Enhanced Game Info -->
                        <div class="game-info">
                            <div class="info-section">
                                <h4>Score</h4>
                                <strong class="value" id="scoreValue">0</strong>
            </div>
                                    <div class="info-section">
                                        <h4>Niveau</h4>
                                        <strong class="value" id="levelValue">1</strong>
            </div>
                                    <div class="info-section">
                                        <h4>Mode</h4>
                                        <strong class="value" id="currentMode">3D</strong>
            </div>
                                    <div class="info-section">
                                        <h4>Grille</h4>
                                        <strong class="value" id="currentGrid">10√ó10</strong>
            </div>
                                    <div class="info-section">
                                        <h4>Temps</h4>
                                        <strong class="value" id="timeValue">00:00</strong>
        </div>
                                    <div class="info-section">
                                        <h4>Mots</h4>
                                        <strong class="value" id="wordsValue">0</strong>
        </div>
        </div>
        </div>

                            <div class="info-section">
                                <h3><i class="fas fa-list-check"></i> Mots √† compl√©ter</h3>
                                <div class="word-list">
                                    <ul id="wordsFound">
                                        <li>CHAT</li>
                                        <li>MAISON</li>
                                        <li>MUSIQUE</li>
                                        <li>PLANTE</li>
                                        <li>LUMI√àRE</li>
            </ul>
        </div>
                                <div class="letter-queue">
                                    <h4><i class="fas fa-queue"></i> Prochaines lettres</h4>
                                    <div id="letterQueue" class="queue-display"></div>
            </div>
            </div>
        </div>

                        <div id="loadingIndicator" class="loading-indicator" style="display: none;">
                            <div class="loading-spinner"></div>
                            Chargement du jeu...
            </div>
            </div>
            </div>

                <!-- Enhanced Sidebar -->
                <div class="sidebar">
                    <div class="sidebar-section">
                        <h3><i class="fas fa-info-circle"></i> √Ä propos de la Maquette 3D</h3>
                        <p>Cette version pr√©sente le mode immersif 3D du jeu Letters Cascade Challenge.</p>
                        <p><strong>Caract√©ristiques :</strong> Grille 3D multi-couches, effets visuels avanc√©s, gameplay immersif.</p>
                        <p><strong>Note :</strong> Interface et design uniquement - logique de jeu en d√©veloppement.</p>
            </div>

                    <div class="sidebar-section">
                        <h3><i class="fas fa-book"></i> R√®gles du Jeu 3D</h3>
                        <ul style="list-style: none; padding: 0; margin: 0;">
                            <li style="margin-bottom: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm);">
                                üéØ <strong>Formation de Mots:</strong> Formez des mots de 3+ lettres en utilisant les lettres qui tombent
                            </li>
                            <li style="margin-bottom: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm);">
                                üèÜ <strong>Score:</strong> 1 point par lettre + bonus longueur √ó 10
                            </li>
                            <li style="margin-bottom: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm);">
                                üéÆ <strong>Contr√¥les:</strong> Fl√®ches pour d√©placer, Espace pour rotation
                            </li>
                            <li style="margin-bottom: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm);">
                                üåü <strong>Bonus 3D:</strong> +50 points pour formation 3D
                            </li>
                        </ul>
            </div>

                    <div class="sidebar-section">
                        <h3><i class="fas fa-mobile-alt"></i> Support Mobile 3D</h3>
                        <div style="margin-bottom: var(--spacing-md);">
                            <strong>üì± Portrait:</strong> Grille 120√ó120px, contr√¥les compacts, une main suffit
            </div>
                        <div>
                            <strong>üîÑ Paysage:</strong> Grille 100√ó100px, sidebar compl√®te, deux mains recommand√©es
                    </div>
                </div>

                    <div class="sidebar-section">
                        <h3><i class="fas fa-chart-bar"></i> Progression 3D</h3>
                        <div style="display: grid; gap: var(--spacing-sm);">
                            <div style="padding: var(--spacing-sm); background: rgba(76, 175, 80, 0.1); border-radius: var(--radius-sm); border-left: 3px solid #4caf50;">
                                üü¢ <strong>Facile:</strong> 8√ó8, 2-3s par chute, mots 3-4 lettres
                            </div>
                            <div style="padding: var(--spacing-sm); background: rgba(255, 193, 7, 0.1); border-radius: var(--radius-sm); border-left: 3px solid #ffc107;">
                                üü° <strong>Moyen:</strong> 10√ó10, 1.5-2s par chute, mots 4-5 lettres
                        </div>
                            <div style="padding: var(--spacing-sm); background: rgba(255, 152, 0, 0.1); border-radius: var(--radius-sm); border-left: 3px solid #ff9800;">
                                üü† <strong>Difficile:</strong> 12√ó12, 1-1.5s par chute, mots 5-6 lettres
                        </div>
                            <div style="padding: var(--spacing-sm); background: rgba(244, 67, 54, 0.1); border-radius: var(--radius-sm); border-left: 3px solid #f44336;">
                                üî¥ <strong>Expert:</strong> 12√ó12, 0.5-1s par chute, mots 6+ lettres
                </div>
            </div>
        </div>

                    <div class="sidebar-section">
                        <h3><i class="fas fa-cube"></i> Mode 3D Avanc√©</h3>
                        <ul style="list-style: none; padding: 0; margin: 0;">
                            <li style="margin-bottom: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm);">
                                üéØ <strong>6 Directions:</strong> Horizontal, vertical, profondeur, diagonales
                            </li>
                            <li style="margin-bottom: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm);">
                                üèóÔ∏è <strong>3 Couches:</strong> Avant, milieu, arri√®re pour combos avanc√©s
                            </li>
                            <li style="margin-bottom: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm);">
                                üåü <strong>Bonus 3D:</strong> +50 points pour formation 3D
                            </li>
                    </ul>
                </div>

                    <!-- Enhanced Concept Images Section -->
                    <div class="sidebar-section">
                        <h3><i class="fas fa-palette"></i> Concepts Visuels</h3>
                        <div class="concept-showcase">
                            <div class="concept-showcase-item">
                                <img src="images/Cascade Letters - 02 - Decor concept 01.png" alt="Environment Concept - KridVOID" onerror="this.src='https://via.placeholder.com/250x150/667eea/ffffff?text=Environment'">
                                <div class="concept-info">
                                    <h4>Environnement 3D</h4>
                                    <p>Concepts d'environnement immersif avec cascades et √©l√©ments naturels</p>
                </div>
                </div>
                            <div class="concept-showcase-item">
                                <img src="images/HighresScreenshot00002.png" alt="High Resolution Interface - KridVOID" onerror="this.src='https://via.placeholder.com/250x150/764ba2/ffffff?text=Interface'">
                                <div class="concept-info">
                                    <h4>Interface Haute R√©solution</h4>
                                    <p>D√©tails visuels et qualit√© graphique pour une exp√©rience premium</p>
                </div>
            </div>
        </div>
            </div>
            </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Complete 3D Game Engine for Letters Cascade Challenge
        class Game3D {
            constructor() {
                console.log('üîß Game3D constructor called');
                this.mode = '3d';
                this.gridSize = 10;
                this.score = 0;
                this.level = 1;
                this.wordsFound = 0;
                this.gameRunning = false;
                this.paused = false;
                this.startTime = null;
                this.letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
                this.targetWords = ['CHAT', 'MAISON', 'MUSIQUE', 'JARDIN', 'LIVRE', 'TABLE', 'FEN√äTRE', 'PORTE'];
                this.completedWords = [];
                this.currentLetter = null;
                this.letterPosition = { x: 0, y: 0 };
                this.gameSpeed = 1000;
                this.gameInterval = null;
                
                // Three.js properties
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.grid = [];
                this.raycaster = null;
                this.mouse = null;
                
                console.log('üîß Game3D constructor completed, calling init()');
                this.init();
            }

            init() {
                console.log('üöÄ init() called - mode:', this.mode, 'THREE available:', typeof THREE !== 'undefined');
                
                // Show loading indicator
                const loadingIndicator = document.getElementById('loadingIndicator');
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'flex';
                    console.log('‚è≥ Loading indicator shown');
                }
                
                if (this.mode === '3d' && typeof THREE !== 'undefined') {
                    console.log('üéÆ Three.js loaded, checking WebGL support...');
                    
                    // Check WebGL support
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    
                    if (gl) {
                        console.log('‚úÖ WebGL supported, creating 3D game...');
                        this.initThreeJS();
                    } else {
                        console.warn('‚ö†Ô∏è WebGL not supported, falling back to 2D grid...');
                        this.createGrid(); // Fallback to original 2D grid
                    }
                } else {
                    console.log('üì± Using 2D grid mode...');
                    this.createGrid(); // Use 2D grid
                }
                
                console.log('üîÑ Calling updateLetterQueue()');
                this.updateLetterQueue();
                
                console.log('üìä Calling updateDisplay()');
                this.updateDisplay();
                
                console.log('üéØ Calling setupEventListeners()');
                this.setupEventListeners();
                
                if (typeof Utils !== 'undefined') {
                    console.log('‚úÖ Game initialized with Utils');
                } else {
                    console.warn('‚ö†Ô∏è Utils not available');
                }
                
                // Hide loading indicator
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'none';
                    console.log('‚úÖ Loading indicator hidden');
                }
                
                console.log('üéâ init() completed successfully');
            }

            initThreeJS() {
                console.log('üéÆ initThreeJS() called');
                
                const container = document.getElementById('gameGrid');
                console.log('üì¶ Container found:', container);
                
                if (!container) {
                    console.error('‚ùå gameGrid container not found!');
                    return;
                }
                
                // Clear container and create canvas
                container.innerHTML = '';
                const canvas = document.createElement('canvas');
                canvas.id = 'threejsCanvas';
                canvas.width = 500;
                canvas.height = 500;
                canvas.style.border = '2px solid rgba(255, 255, 255, 0.3)';
                canvas.style.borderRadius = '12px';
                canvas.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.3)';
                canvas.style.display = 'block';
                canvas.style.margin = '0 auto';
                container.appendChild(canvas);
                
                console.log('üé® Canvas created and added to container');

                // Enhanced scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1a1a2e);
                console.log('üåå Scene created');
                
                // Enhanced camera with better positioning
                this.camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);
                this.camera.position.set(0, 0, 15);
                this.camera.lookAt(0, 0, 0);
                console.log('üì∑ Camera created and positioned');

                // Enhanced renderer with better quality
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    alpha: true, 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                
                this.renderer.setSize(canvas.width, canvas.height);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                console.log('üé® Renderer created with enhanced settings');

                // Create enhanced 3D grid
                this.create3DGrid();
                
                // Enhanced lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                console.log('üí° Ambient light added');
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -10;
                directionalLight.shadow.camera.right = 10;
                directionalLight.shadow.camera.top = 10;
                directionalLight.shadow.camera.bottom = -10;
                this.scene.add(directionalLight);
                console.log('üí° Directional light added');
                
                // Add point lights for better atmosphere
                const pointLight1 = new THREE.PointLight(0x4ecdc4, 1, 100);
                pointLight1.position.set(5, 5, 5);
                this.scene.add(pointLight1);
                
                const pointLight2 = new THREE.PointLight(0x667eea, 1, 100);
                pointLight2.position.set(-5, -5, 5);
                this.scene.add(pointLight2);
                console.log('üí° Point lights added');
                
                // Add fog for depth
                this.scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);
                console.log('üå´Ô∏è Fog added');
                
                // Setup raycaster for mouse interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                console.log('üéØ Raycaster setup complete');
                
                // Start animation loop
                this.animate();
                console.log('üé¨ Animation loop started');
                
                // Add mouse event listeners
                canvas.addEventListener('click', (event) => this.onCanvasClick(event));
                canvas.addEventListener('mousemove', (event) => this.onMouseMove(event));
                console.log('üñ±Ô∏è Mouse event listeners added');
                
                console.log('‚úÖ initThreeJS() completed successfully');
            }

            create3DGrid() {
                console.log('üèóÔ∏è create3DGrid() called');
                
                this.grid = [];
                const cellSize = 1.2;
                const gap = 0.2;
                const totalSize = this.gridSize * (cellSize + gap) - gap;
                const startX = -totalSize / 2;
                const startZ = -totalSize / 2;
                
                console.log('üìê Grid dimensions:', {
                    cellSize: cellSize,
                    gap: gap,
                    totalSize: totalSize,
                    startX: startX,
                    startZ: startZ
                });
                
                for (let row = 0; row < this.gridSize; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < this.gridSize; col++) {
                        const x = startX + col * (cellSize + gap);
                        const z = startZ + row * (cellSize + gap);
                        
                        // Create cube geometry
                        const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
                        const material = new THREE.MeshPhongMaterial({ 
                            color: 0x2a2a3e,
                            specular: 0x444444,
                            shininess: 100
                        });
                        
                        const cube = new THREE.Mesh(geometry, material);
                        cube.position.set(x, 0, z);
                        cube.castShadow = true;
                        cube.receiveShadow = true;
                        cube.userData = { row: row, col: col, letter: null, occupied: false };
                        
                        this.scene.add(cube);
                        this.grid[row][col] = cube;
                        
                        console.log(`üì¶ Cube created at row ${row}, col ${col}, position (${x}, 0, ${z})`);
                    }
                }
                
                console.log('‚úÖ 3D grid created successfully');
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Enhanced animation with floating effect
                if (this.scene) {
                    this.scene.rotation.y += 0.002;
                    
                    // Add floating animation to cubes
                    this.grid.forEach(row => {
                        row.forEach(cell => {
                            if (cell) {
                                cell.position.y += Math.sin(Date.now() * 0.001 + cell.userData.row + cell.userData.col) * 0.001;
                            }
                        });
                    });
                }
                
                this.renderer.render(this.scene, this.camera);
            }

            onCanvasClick(event) {
                console.log('üñ±Ô∏è Canvas click detected at:', event.clientX, event.clientY);
                
                const rect = event.target.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                console.log('üéØ Mouse coordinates:', this.mouse.x, this.mouse.y);

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children);
                
                console.log('üéØ Intersections found:', intersects.length);

                if (intersects.length > 0) {
                    const clickedCube = intersects[0].object;
                    const userData = clickedCube.userData;
                    
                    console.log('üéØ Clicked cube userData:', userData);
                    
                    if (userData && !userData.occupied) {
                        console.log('‚úÖ Valid click - placing letter at row:', userData.row, 'col:', userData.col);
                        this.placeLetter3D(userData.row, userData.col, event);
                    } else {
                        console.log('‚ùå Invalid click - cube already filled or no userData');
                    }
                } else {
                    console.log('‚ùå No intersections found');
                }
            }

            // Add hover effects for 3D cubes
            onMouseMove(event) {
                if (!this.raycaster || !this.mouse) {
                    console.log('‚ö†Ô∏è Raycaster or mouse not initialized');
                    return;
                }
                
                const rect = event.target.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children);

                // Reset all cube colors
                this.grid.forEach(row => {
                    row.forEach(cell => {
                        if (cell && !cell.userData.occupied) {
                            cell.material.color.setHex(0x2a2a3e);
                            cell.scale.set(1, 1, 1);
                        }
                    });
                });

                // Highlight hovered cube
                if (intersects.length > 0) {
                    const hoveredCube = intersects[0].object;
                    const userData = hoveredCube.userData;
                    
                    if (userData && !userData.occupied) {
                        hoveredCube.material.color.setHex(0x4ecdc4);
                        hoveredCube.scale.set(1.1, 1.1, 1.1);
                    }
                }
            }

            placeLetter3D(row, col, event) {
                console.log('üéØ placeLetter3D() called - row:', row, 'col:', col, 'letters remaining:', this.letters.length);
                
                if (this.letters.length > 0) {
                    const letter = this.letters.shift();
                    console.log('üìù Placing letter:', letter);
                    
                    // Create enhanced 3D text
                    const textGeometry = new THREE.PlaneGeometry(0.8, 0.8);
                    
                    // Create canvas for better text rendering
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 128;
                    canvas.height = 128;
                    
                    // Create gradient background
                    const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
                    gradient.addColorStop(0, '#4ecdc4');
                    gradient.addColorStop(1, '#667eea');
                    context.fillStyle = gradient;
                    context.fillRect(0, 0, 128, 128);
                    
                    // Add text with shadow
                    context.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    context.shadowBlur = 4;
                    context.shadowOffsetX = 2;
                    context.shadowOffsetY = 2;
                    context.fillStyle = '#ffffff';
                    context.font = 'bold 72px Arial';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText(letter, 64, 64);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const textMaterial = new THREE.MeshBasicMaterial({ 
                        map: texture,
                        transparent: true,
                        opacity: 0.95
                    });
                    
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    
                    // Position the text with offset
                    textMesh.position.set(
                        (col - this.gridSize/2) * 1.4,
                        (row - this.gridSize/2) * 1.4,
                        0.8
                    );

                    // Add glow effect
                    const glowGeometry = new THREE.PlaneGeometry(1.2, 1.2);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x4ecdc4,
                        transparent: true,
                        opacity: 0.3
                    });
                    const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                    glowMesh.position.copy(textMesh.position);
                    glowMesh.position.z = 0.7;
                    
                    this.scene.add(glowMesh);
                    this.scene.add(textMesh);
                    
                    this.grid[row][col].userData.letter = textMesh;
                    this.grid[row][col].userData.occupied = true;
                    
                    console.log('‚úÖ Letter placed successfully in 3D scene');
                    
                    // Enhanced animation
                    textMesh.scale.set(0, 0, 0);
                    glowMesh.scale.set(0, 0, 0);
                    
                    const animate = () => {
                        textMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.15);
                        glowMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                        
                        if (textMesh.scale.x < 0.95) {
                            requestAnimationFrame(animate);
                        } else {
                            // Add pulse animation
                            this.addPulseAnimation(textMesh);
                        }
                    };
                    animate();
                    
                    // Update cube color when letter is placed
                    const cube = this.grid[row][col];
                    cube.material.color.setHex(0x4ecdc4);
                    cube.material.opacity = 0.9;
                    
                    this.score += 10;
                    console.log('üìä Score updated:', this.score);
                    
                    this.updateDisplay();
                    this.updateLetterQueue();
                    this.checkWordCompletion();
                    
                    // Enhanced particle effects
                    if (typeof Utils !== 'undefined') {
                        console.log('‚ú® Creating particle effects');
                        Utils.createParticleEffect(
                            event.clientX,
                            event.clientY,
                            8,
                            '#4ecdc4'
                        );
                        Utils.playSound('place', 600, 0.15);
                    } else {
                        console.warn('‚ö†Ô∏è Utils not available for particle effects');
                    }
                } else {
                    console.warn('‚ö†Ô∏è No letters remaining in queue');
                }
            }

            addPulseAnimation(mesh) {
                console.log('üí´ Adding pulse animation to mesh');
                const originalScale = mesh.scale.clone();
                const pulse = () => {
                    const scale = 1 + Math.sin(Date.now() * 0.01) * 0.05;
                    mesh.scale.set(scale, scale, scale);
                    requestAnimationFrame(pulse);
                };
                pulse();
            }

            // Enhanced victory effects for 3D mode
            createVictoryEffect3D(word, positions) {
                positions.forEach((pos, index) => {
                    const cell = this.grid[pos.row][pos.col];
                    if (cell && cell.userData.letter) {
                        // Create explosion effect
                        const explosionGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                        const explosionMaterial = new THREE.MeshBasicMaterial({
                            color: 0xffd700,
                            transparent: true,
                            opacity: 0.8
                        });
                        const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                        explosion.position.copy(cell.userData.letter.position);
                        explosion.position.z += 0.5;
                        
                        this.scene.add(explosion);
                        
                        // Animate explosion
                        const animateExplosion = () => {
                            explosion.scale.multiplyScalar(1.1);
                            explosion.material.opacity -= 0.02;
                            
                            if (explosion.material.opacity > 0) {
                                requestAnimationFrame(animateExplosion);
                            } else {
                                this.scene.remove(explosion);
                            }
                        };
                        animateExplosion();
                        
                        // Pulse the letter
                        this.addPulseAnimation(cell.userData.letter);
                    }
                });
            }

            createGrid() {
                console.log('üèóÔ∏è createGrid() called - gridSize:', this.gridSize);
                
                const grid = document.getElementById('gameGrid');
                console.log('üì¶ Grid container found:', grid);
                
                if (!grid) {
                    console.error('‚ùå gameGrid element not found!');
                    return;
                }
                
                grid.innerHTML = '';
                
                // Remove existing grid classes
                grid.classList.remove('grid-8x8', 'grid-10x10', 'grid-12x12');
                
                // Add the correct grid class based on size
                if (this.gridSize === 8) {
                    grid.classList.add('grid-8x8');
                    console.log('üìê Added grid-8x8 class');
                } else if (this.gridSize === 10) {
                    grid.classList.add('grid-10x10');
                    console.log('üìê Added grid-10x10 class');
                } else if (this.gridSize === 12) {
                    grid.classList.add('grid-12x12');
                    console.log('üìê Added grid-12x12 class');
                }

                for (let i = 0; i < this.gridSize * this.gridSize; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.textContent = '';
                    cell.onclick = () => this.placeLetter(cell);
                    grid.appendChild(cell);
                }
                
                console.log('‚úÖ 2D grid created with', this.gridSize * this.gridSize, 'cells');
            }

            updateLetterQueue() {
                console.log('üîÑ updateLetterQueue() called - letters:', this.letters);
                
                const queue = document.getElementById('letterQueue');
                console.log('üì¶ Letter queue container found:', queue);
                
                if (!queue) {
                    console.error('‚ùå letterQueue element not found!');
                    return;
                }
                
                queue.innerHTML = '';
                
                this.letters.slice(0, 5).forEach((letter, index) => {
                    const letterDiv = document.createElement('div');
                    letterDiv.className = 'queue-letter';
                    letterDiv.textContent = letter;
                    queue.appendChild(letterDiv);
                    console.log('üìù Added letter to queue:', letter, 'at position:', index);
                });
                
                console.log('‚úÖ Letter queue updated');
            }

            placeLetter(cell) {
                console.log('üéØ placeLetter() called - cell:', cell, 'cell text:', cell.textContent);
                
                if (!cell.textContent && this.letters.length > 0) {
                    const letter = this.letters.shift();
                    cell.textContent = letter;
                    cell.classList.add('filled');
                    
                    console.log('üìù Placed letter:', letter, 'in 2D grid');
                    
                    this.score += 10;
                    console.log('üìä Score updated:', this.score);
                    
                    this.updateDisplay();
                    this.updateLetterQueue();
                    this.checkWordCompletion();
                    
                    if (typeof Utils !== 'undefined') {
                        console.log('‚ú® Creating particle effects for 2D');
                        Utils.createParticleEffect(
                            cell.offsetLeft + cell.offsetWidth / 2,
                            cell.offsetTop + cell.offsetHeight / 2,
                            5,
                            '#4ecdc4'
                        );
                        Utils.playSound('place', 600, 0.1);
                    } else {
                        console.warn('‚ö†Ô∏è Utils not available for 2D particle effects');
                    }
                } else {
                    console.log('‚ùå Cannot place letter - cell filled or no letters remaining');
                }
            }

            checkWordCompletion() {
                console.log('üîç checkWordCompletion() called - mode:', this.mode);
                
                if (this.mode === '3d') {
                    console.log('üéÆ Checking 3D word completion');
                    this.checkWordCompletion3D();
                } else {
                    console.log('üì± Checking 2D word completion');
                    this.checkWordCompletion2D();
                }
            }

            checkWordCompletion2D() {
                console.log('üì± checkWordCompletion2D() called');
                
                const directions = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1],           [0, 1],
                    [1, -1],  [1, 0],  [1, 1]
                ];

                const cells = document.querySelectorAll('.grid-cell');
                console.log('üì¶ Found', cells.length, 'grid cells');
                
                const grid = [];
                
                // Convert cells to 2D grid
                for (let row = 0; row < this.gridSize; row++) {
                    grid[row] = [];
                    for (let col = 0; col < this.gridSize; col++) {
                        const index = row * this.gridSize + col;
                        if (cells[index]) {
                            grid[row][col] = cells[index].textContent || '';
                        } else {
                            grid[row][col] = '';
                        }
                    }
                }
                
                console.log('üìê 2D grid created:', grid);

                // Check for words in all directions
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (grid[row][col]) {
                            for (let [dx, dy] of directions) {
                                const word = this.checkWordInDirection(grid, col, row, dx, dy);
                                if (word && this.targetWords.includes(word) && !this.completedWords.includes(word)) {
                                    console.log('üèÜ Word completed in 2D:', word);
                                    this.completeWord(word);
                                }
                            }
                        }
                    }
                }
            }

            checkWordCompletion3D() {
                console.log('üéÆ checkWordCompletion3D() called');
                
                const directions = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1],           [0, 1],
                    [1, -1],  [1, 0],  [1, 1]
                ];

                // Create grid from 3D grid data
                const grid = [];
                for (let row = 0; row < this.gridSize; row++) {
                    grid[row] = [];
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.grid[row] && this.grid[row][col] && this.grid[row][col].userData.letter) {
                            // Extract letter from 3D mesh (simplified)
                            grid[row][col] = this.getLetterFrom3DMesh(this.grid[row][col].userData.letter) || '';
                        } else {
                            grid[row][col] = '';
                        }
                    }
                }
                
                console.log('üìê 3D grid created:', grid);

                // Check for words in all directions
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (grid[row][col]) {
                            for (let [dx, dy] of directions) {
                                const word = this.checkWordInDirection(grid, col, row, dx, dy);
                                if (word && this.targetWords.includes(word) && !this.completedWords.includes(word)) {
                                    console.log('üèÜ Word completed in 3D:', word);
                                    this.completeWord(word);
                                }
                            }
                        }
                    }
                }
            }

            getLetterFrom3DMesh(mesh) {
                console.log('üîç getLetterFrom3DMesh() called for mesh:', mesh);
                // For now, return a placeholder letter
                // In a real implementation, you'd extract the letter from the mesh texture
                return 'A'; // Placeholder
            }

            checkWordInDirection(grid, startCol, startRow, dx, dy) {
                console.log('üîç checkWordInDirection() called - startCol:', startCol, 'startRow:', startRow, 'dx:', dx, 'dy:', dy);
                
                let word = '';
                let col = startCol;
                let row = startRow;
                
                while (col >= 0 && col < this.gridSize && row >= 0 && row < this.gridSize) {
                    const letter = grid[row][col];
                    if (letter) {
                        word += letter;
                    } else {
                        break;
                    }
                    col += dx;
                    row += dy;
                }
                
                console.log('üìù Word found in direction:', word);
                return word;
            }

            completeWord(word) {
                console.log('üèÜ completeWord() called - word:', word);
                
                this.completedWords.push(word);
                this.wordsFound++;
                this.score += word.length * 10;
                
                console.log('üìä Word completion stats - wordsFound:', this.wordsFound, 'score:', this.score);
                
                // Add word to completed list
                const wordList = document.getElementById('wordsFound');
                if (wordList) {
                    const wordItem = document.createElement('li');
                    wordItem.textContent = word;
                    wordItem.classList.add('completed');
                    wordList.appendChild(wordItem);
                    console.log('üìù Added word to completed list:', word);
                }
                
                this.updateDisplay();
                
                // Victory effects
                if (typeof Utils !== 'undefined') {
                    console.log('‚ú® Creating victory effects');
                    Utils.createVictorySparkles();
                    Utils.playSound('complete', 1000, 0.3);
                }
                
                console.log('‚úÖ Word completed successfully');
            }

            levelUp() {
                this.level++;
                
                if (typeof Utils !== 'undefined') {
                    Utils.showModal(
                        'Niveau ' + this.level + ' !',
                        'F√©licitations ! Vous avez atteint le niveau ' + this.level + '.',
                        [{ text: 'Continuer', action: () => this.updateDisplay() }]
                    );
                }
                
                this.updateDisplay();
            }

            selectMode(mode) {
                console.log('üéÆ selectMode() called - mode:', mode);
                
                // Update active button
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.mode === mode) {
                        btn.classList.add('active');
                        console.log('‚úÖ Activated mode button:', btn.textContent);
                    }
                });
                
                this.mode = mode;
                console.log('üéÆ Mode changed to:', this.mode);
                
                // Reinitialize game with new mode
                this.resetGame();
                this.init();
                
                console.log('‚úÖ Mode selection completed');
            }

            selectGrid(size) {
                console.log('üìê selectGrid() called - size:', size);
                
                // Update active button
                document.querySelectorAll('.grid-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (parseInt(btn.dataset.size) === size) {
                        btn.classList.add('active');
                        console.log('‚úÖ Activated grid button:', btn.textContent);
                    }
                });
                
                this.gridSize = size;
                console.log('üìê Grid size changed to:', this.gridSize);
                
                // Reinitialize game with new grid size
                this.resetGame();
                this.init();
                
                console.log('‚úÖ Grid selection completed');
            }

            startGame() {
                console.log('‚ñ∂Ô∏è startGame() called');
                
                if (!this.gameRunning) {
                    this.gameRunning = true;
                    this.startTime = Date.now();
                    console.log('‚è∞ Game started at:', this.startTime);
                    
                    // Update button text
                    const startButton = document.getElementById('startBtn');
                    if (startButton) {
                        startButton.innerHTML = '<i class="fas fa-pause"></i> Pause';
                        startButton.onclick = () => this.pauseGame();
                    }
                    
                    console.log('‚úÖ Game started successfully');
                } else {
                    console.log('‚ö†Ô∏è Game already running');
                }
            }

            pauseGame() {
                console.log('‚è∏Ô∏è pauseGame() called');
                
                if (this.gameRunning) {
                    this.gameRunning = false;
                    console.log('‚è∞ Game paused');
                    
                    // Update button text
                    const pauseButton = document.getElementById('pauseBtn');
                    if (pauseButton) {
                        pauseButton.innerHTML = '<i class="fas fa-play"></i> D√©marrer';
                        pauseButton.onclick = () => this.startGame();
                    }
                    
                    console.log('‚úÖ Game paused successfully');
                } else {
                    console.log('‚ö†Ô∏è Game not running');
                }
            }

            resetGame() {
                console.log('üîÑ resetGame() called');
                
                this.gameRunning = false;
                this.paused = false;
                this.score = 0;
                this.level = 1;
                this.wordsFound = 0;
                this.startTime = null;
                this.letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
                this.completedWords = [];
                
                console.log('üîÑ Game state reset');
                
                // Clear grid
                if (this.mode === '3d') {
                    console.log('üéÆ Clearing 3D grid');
                    this.grid.forEach(row => {
                        row.forEach(cell => {
                            if (cell.userData.letter) {
                                this.scene.remove(cell.userData.letter);
                                cell.userData.letter = null;
                            }
                            if (cell.userData.glow) {
                                this.scene.remove(cell.userData.glow);
                                cell.userData.glow = null;
                            }
                            cell.userData.occupied = false;
                            cell.material.color.setHex(0x2a2a3e);
                            cell.material.opacity = 0.8;
                        });
                    });
                } else {
                    console.log('üì± Clearing 2D grid');
                    const cells = document.querySelectorAll('.grid-cell');
                    cells.forEach(cell => {
                        cell.textContent = '';
                        cell.classList.remove('filled');
                    });
                }
                
                this.updateDisplay();
                this.updateLetterQueue();
                
                // Reset button text
                const startButton = document.getElementById('startBtn');
                if (startButton) {
                    startButton.innerHTML = '<i class="fas fa-play"></i> D√©marrer';
                    startButton.onclick = () => this.startGame();
                }
                
                console.log('‚úÖ Game reset successfully');
            }

            updateGame() {
                // Update game logic here
                const currentTime = Date.now();
                if (this.startTime) {
                    const elapsed = Math.floor((currentTime - this.startTime) / 1000);
                    document.getElementById('timeValue').textContent = 
                        `${Math.floor(elapsed / 60)}:${(elapsed % 60).toString().padStart(2, '0')}`;
                }
            }

            updateDisplay() {
                console.log('üìä updateDisplay() called - score:', this.score, 'level:', this.level, 'mode:', this.mode);
                
                const scoreElement = document.getElementById('scoreValue');
                const levelElement = document.getElementById('levelValue');
                const timeElement = document.getElementById('timeValue');
                const wordsElement = document.getElementById('wordsValue');
                const modeElement = document.getElementById('currentMode');
                const gridElement = document.getElementById('currentGrid');
                
                console.log('üì¶ Display elements found:', {
                    score: scoreElement,
                    level: levelElement,
                    time: timeElement,
                    words: wordsElement,
                    mode: modeElement,
                    grid: gridElement
                });
                
                if (scoreElement) scoreElement.textContent = this.score;
                if (levelElement) levelElement.textContent = this.level;
                
                // Update mode display
                if (modeElement) {
                    const modeText = this.mode === '3d' ? '3D' : '2D';
                    modeElement.textContent = modeText;
                    console.log('üéÆ Mode display updated to:', modeText);
                }
                
                // Update grid size display
                if (gridElement) {
                    gridElement.textContent = `${this.gridSize}√ó${this.gridSize}`;
                    console.log('üìê Grid display updated to:', `${this.gridSize}√ó${this.gridSize}`);
                }
                
                // Update time if game is running
                if (this.gameRunning && this.startTime) {
                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    if (timeElement) timeElement.textContent = `${Math.floor(elapsed / 60)}:${(elapsed % 60).toString().padStart(2, '0')}`;
                }
                
                if (wordsElement) wordsElement.textContent = this.wordsFound;
                
                // Update mode buttons to reflect current mode
                this.updateModeButtons();
                
                console.log('‚úÖ Display updated');
            }

            updateModeButtons() {
                console.log('üéÆ updateModeButtons() called - current mode:', this.mode);
                
                const modeButtons = document.querySelectorAll('.mode-btn');
                modeButtons.forEach(btn => {
                    const btnMode = btn.dataset.mode;
                    if (btnMode === this.mode) {
                        btn.classList.add('active');
                        console.log('‚úÖ Mode button activated:', btnMode);
                    } else {
                        btn.classList.remove('active');
                        console.log('‚ùå Mode button deactivated:', btnMode);
                    }
                });
            }

            updateWordList() {
                const wordList = document.querySelectorAll('.word-list li');
                wordList.forEach((item, index) => {
                    const word = this.targetWords[index];
                    if (this.completedWords.includes(word)) {
                        item.classList.add('completed');
                    } else {
                        item.classList.remove('completed');
                    }
                });
            }

            setupEventListeners() {
                console.log('üéØ setupEventListeners() called');
                
                // Game control buttons
                const startBtn = document.getElementById('startBtn');
                const pauseBtn = document.getElementById('pauseBtn');
                const resetBtn = document.getElementById('resetBtn');
                
                console.log('üéÆ Control buttons found:', {
                    start: startBtn,
                    pause: pauseBtn,
                    reset: resetBtn
                });
                
                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        console.log('üñ±Ô∏è Start button clicked');
                        this.startGame();
                    });
                }
                
                if (pauseBtn) {
                    pauseBtn.addEventListener('click', () => {
                        console.log('üñ±Ô∏è Pause button clicked');
                        this.pauseGame();
                    });
                }
                
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        console.log('üñ±Ô∏è Reset button clicked');
                        this.resetGame();
                    });
                }
                
                // Mode selection
                const modeButtons = document.querySelectorAll('.mode-btn');
                console.log('üéÆ Mode buttons found:', modeButtons.length);
                
                modeButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        console.log('üñ±Ô∏è Mode button clicked:', btn.textContent);
                        this.selectMode(btn.dataset.mode);
                    });
                });
                
                // Grid size selection
                const gridButtons = document.querySelectorAll('.grid-btn');
                console.log('üìê Grid buttons found:', gridButtons.length);
                
                gridButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        console.log('üñ±Ô∏è Grid button clicked:', btn.textContent);
                        this.selectGrid(parseInt(btn.dataset.size));
                    });
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (event) => {
                    console.log('‚å®Ô∏è Key pressed:', event.key);
                    
                    switch(event.key) {
                        case ' ':
                            console.log('‚è∏Ô∏è Space key - toggling pause');
                            event.preventDefault();
                            if (this.gameRunning) {
                                this.pauseGame();
                            } else {
                                this.startGame();
                            }
                            break;
                        case 'r':
                        case 'R':
                            console.log('üîÑ R key - resetting game');
                            event.preventDefault();
                            this.resetGame();
                            break;
                        case 's':
                        case 'S':
                            console.log('‚ñ∂Ô∏è S key - starting game');
                            event.preventDefault();
                            this.startGame();
                            break;
                    }
                });
                
                console.log('‚úÖ Event listeners setup completed');
            }
        }

        // Global game instance
        let game3D;

        // Global functions for button controls
        function selectMode(mode) {
            if (game3D) game3D.selectMode(mode);
        }

        function selectGrid(size) {
            if (game3D) game3D.selectGrid(size);
        }

        function startGame() {
            if (game3D) game3D.startGame();
        }

        function resetGame() {
            if (game3D) game3D.resetGame();
        }

        function pauseGame() {
            if (game3D) game3D.pauseGame();
        }

        function clearGrid() {
            if (game3D) game3D.clearGrid();
        }

        // Initialize 3D game when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ DOM Content Loaded - Initializing 3D game...');
            
            // Check if Three.js is available
            if (typeof THREE === 'undefined') {
                console.error('‚ùå THREE.js not loaded!');
                // Show error message to user
                const container = document.getElementById('gameGrid');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: #ff6b6b;">
                            <h3>‚ùå Erreur de chargement</h3>
                            <p>Three.js n'a pas pu √™tre charg√©. Veuillez rafra√Æchir la page.</p>
                        </div>
                    `;
                }
                return;
            }
            
            console.log('‚úÖ THREE.js available, creating Game3D instance...');
            
            try {
                game3D = new Game3D();
                console.log('üéÆ 3D Game initialized successfully');
                
                // Check if Utils is available
                if (typeof Utils !== 'undefined') {
                    console.log('‚úÖ Utils available for sound and particle effects');
                } else {
                    console.warn('‚ö†Ô∏è Utils not available - sound and particle effects disabled');
                }
                
                // Update display after initialization
                setTimeout(() => {
                    if (game3D && typeof game3D.updateDisplay === 'function') {
                        game3D.updateDisplay();
                        console.log('üìä Display updated after initialization');
                    }
                }, 100);
                
            } catch (error) {
                console.error('‚ùå Error initializing 3D game:', error);
                const container = document.getElementById('gameGrid');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: #ff6b6b;">
                            <h3>‚ùå Erreur d'initialisation</h3>
                            <p>Le jeu 3D n'a pas pu √™tre initialis√©: ${error.message}</p>
                            <button onclick="location.reload()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                Rafra√Æchir la page
                            </button>
                        </div>
                    `;
                }
            }
        });

        // Fullscreen function
        function toggleFullScreen() {
            console.log('üñ•Ô∏è toggleFullScreen() called');
            
            const gameContainer = document.querySelector('.game-container');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            
            console.log('üì¶ Game container found:', gameContainer);
            console.log('üîò Fullscreen button found:', fullscreenBtn);
            
            if (gameContainer.classList.contains('fullscreen')) {
                console.log('üì§ Exiting fullscreen mode');
                exitFullScreen();
            } else {
                console.log('üì• Entering fullscreen mode');
                enterFullScreen();
            }
        }

        function enterFullScreen() {
            console.log('üì• enterFullScreen() called');
            
            const gameContainer = document.querySelector('.game-container');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            
            gameContainer.classList.add('fullscreen');
            fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i> Sortir';
            
            // Add exit button
            const exitBtn = document.createElement('div');
            exitBtn.className = 'fullscreen-exit';
            exitBtn.innerHTML = '<i class="fas fa-times"></i>';
            exitBtn.onclick = exitFullScreen;
            gameContainer.appendChild(exitBtn);
            
            // Resize 3D canvas for full screen
            const canvas = document.getElementById('threejsCanvas');
            console.log('üé® Canvas found for fullscreen:', canvas);
            
            if (canvas && game3D && game3D.renderer) {
                // Calculate optimal canvas size for full screen
                const container = gameContainer.querySelector('.game-grid-container');
                const containerRect = container.getBoundingClientRect();
                const maxWidth = Math.min(containerRect.width * 0.9, window.innerWidth * 0.8);
                const maxHeight = Math.min(containerRect.height * 0.9, window.innerHeight * 0.7);
                const canvasSize = Math.min(maxWidth, maxHeight);
                
                console.log('üìê Fullscreen dimensions:', {
                    containerWidth: containerRect.width,
                    containerHeight: containerRect.height,
                    maxWidth: maxWidth,
                    maxHeight: maxHeight,
                    canvasSize: canvasSize
                });
                
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                game3D.renderer.setSize(canvasSize, canvasSize);
                
                // Update camera aspect ratio
                if (game3D.camera) {
                    game3D.camera.aspect = canvasSize / canvasSize;
                    game3D.camera.updateProjectionMatrix();
                    console.log('üì∑ Camera aspect ratio updated for fullscreen');
                }
                
                // Enhance 3D scene for full screen
                if (game3D.scene) {
                    // Adjust camera position for better view
                    game3D.camera.position.set(0, 0, 18);
                    game3D.camera.lookAt(0, 0, 0);
                    
                    // Enhance lighting for full screen
                    game3D.scene.children.forEach(child => {
                        if (child.type === 'DirectionalLight') {
                            child.intensity = 1.5;
                        } else if (child.type === 'PointLight') {
                            child.intensity = 1.2;
                        }
                    });
                    
                    console.log('üé¨ 3D scene enhanced for fullscreen');
                }
            } else {
                console.warn('‚ö†Ô∏è Canvas or renderer not available for fullscreen resize');
            }
            
            // Add keyboard shortcuts for full screen
            document.addEventListener('keydown', handleFullScreenKeyboard);
            
            console.log('‚úÖ Entered full screen mode');
        }

        function exitFullScreen() {
            console.log('üì§ exitFullScreen() called');
            
            const gameContainer = document.querySelector('.game-container');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            
            gameContainer.classList.remove('fullscreen');
            fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> Plein √âcran';
            
            // Remove exit button
            const exitBtn = gameContainer.querySelector('.fullscreen-exit');
            if (exitBtn) {
                exitBtn.remove();
                console.log('‚ùå Exit button removed');
            }
            
            // Reset 3D canvas size
            const canvas = document.getElementById('threejsCanvas');
            console.log('üé® Canvas found for exit fullscreen:', canvas);
            
            if (canvas && game3D && game3D.renderer) {
                canvas.width = 500;
                canvas.height = 500;
                game3D.renderer.setSize(500, 500);
                
                // Update camera aspect ratio
                if (game3D.camera) {
                    game3D.camera.aspect = 1;
                    game3D.camera.updateProjectionMatrix();
                    console.log('üì∑ Camera aspect ratio reset');
                }
                
                // Reset 3D scene to normal mode
                if (game3D.scene) {
                    // Reset camera position
                    game3D.camera.position.set(0, 0, 15);
                    game3D.camera.lookAt(0, 0, 0);
                    
                    // Reset lighting
                    game3D.scene.children.forEach(child => {
                        if (child.type === 'DirectionalLight') {
                            child.intensity = 1.2;
                        } else if (child.type === 'PointLight') {
                            child.intensity = 1;
                        }
                    });
                    
                    console.log('üé¨ 3D scene reset to normal mode');
                }
            } else {
                console.warn('‚ö†Ô∏è Canvas or renderer not available for fullscreen exit resize');
            }
            
            // Remove keyboard shortcuts
            document.removeEventListener('keydown', handleFullScreenKeyboard);
            
            console.log('‚úÖ Exited full screen mode');
        }

        function handleFullScreenKeyboard(event) {
            switch(event.key) {
                case 'Escape':
                    console.log('‚å®Ô∏è Escape key pressed - exiting fullscreen');
                    event.preventDefault();
                    exitFullScreen();
                    break;
                case 'F11':
                    console.log('‚å®Ô∏è F11 key pressed - exiting fullscreen');
                    event.preventDefault();
                    exitFullScreen();
                    break;
                case ' ':
                    console.log('‚å®Ô∏è Space key pressed - toggling game pause');
                    event.preventDefault();
                    if (game3D) {
                        if (game3D.gameRunning && !game3D.paused) {
                            game3D.pauseGame();
                        } else if (game3D.gameRunning && game3D.paused) {
                            game3D.startGame();
                        }
                    }
                    break;
                case 'r':
                case 'R':
                    console.log('‚å®Ô∏è R key pressed - resetting game');
                    event.preventDefault();
                    if (game3D) {
                        game3D.resetGame();
                    }
                    break;
                case 's':
                case 'S':
                    console.log('‚å®Ô∏è S key pressed - starting game');
                    event.preventDefault();
                    if (game3D && !game3D.gameRunning) {
                        game3D.startGame();
                    }
                    break;
            }
        }

        // Keyboard shortcut for full screen (F11)
        document.addEventListener('keydown', function(event) {
            if (event.key === 'F11') {
                console.log('‚å®Ô∏è F11 key pressed - toggling fullscreen');
                event.preventDefault();
                toggleFullScreen();
            }
        });
    </script>
</body>
</html>