<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maquette 3D - Letters Cascade Challenge</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÆ</text></svg>">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/shared.css">
    <script src="js/utils.js"></script>
    <style>
        /* ULTRA COMPACT 3D LAYOUT - ALL INFO VISIBLE */
        .page-layout {
            display: grid;
            grid-template-columns: 140px 1fr 160px;
            gap: var(--spacing-xs);
            height: 100vh;
            max-width: 1600px;
            margin: 0 auto;
            padding: var(--spacing-xs);
            overflow: hidden;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
            height: 100vh;
            overflow: hidden;
        }

        /* ULTRA COMPACT 3D GAME HEADER */
        .game-header {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(255, 255, 255, 0.95));
            border-radius: var(--radius-sm);
            padding: var(--spacing-xs);
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-align: center;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .game-header h1 {
            color: var(--primary-color);
            font-size: 1rem;
            font-weight: 800;
            margin: 0;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
            z-index: 1;
        }

        .game-header p {
            display: none;
        }

        /* ULTRA COMPACT 3D GAME CONTAINER */
        .game-container {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(255, 255, 255, 0.95));
            border-radius: var(--radius-sm);
            padding: var(--spacing-xs);
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--spacing-xs);
            height: calc(100vh - 60px);
            position: relative;
            overflow: hidden;
            flex: 1;
        }

        /* ULTRA COMPACT 3D GAME STATS - OVERLAY */
        .game-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--spacing-xs);
            padding: var(--spacing-xs);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: absolute;
            top: var(--spacing-xs);
            left: var(--spacing-xs);
            right: var(--spacing-xs);
            z-index: 10;
            backdrop-filter: blur(15px);
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.98);
            border-radius: var(--radius-sm);
            padding: 4px;
            text-align: center;
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }

        .stat-item .label {
            color: var(--gray-600);
            font-size: 0.5rem;
            font-weight: 600;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-item .value {
            color: var(--primary-color);
            font-size: 0.8rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* ULTRA COMPACT 3D SIDEBAR - LEFT */
        .sidebar-left {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
            height: 100%;
            overflow: hidden;
        }

        .sidebar-left-section {
            background: rgba(255, 255, 255, 0.98);
            border-radius: var(--radius-sm);
            padding: var(--spacing-xs);
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
            flex: 1;
            min-height: 0;
        }

        .sidebar-left-section h3 {
            color: var(--primary-color);
            font-size: 0.7rem;
            font-weight: 700;
            margin-bottom: var(--spacing-xs);
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            border-bottom: 1px solid var(--primary-color);
            padding-bottom: var(--spacing-xs);
        }

        /* ULTRA COMPACT 3D SIDEBAR - RIGHT */
        .sidebar-right {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
            height: 100%;
            overflow: hidden;
        }

        .sidebar-right-section {
            background: rgba(255, 255, 255, 0.98);
            border-radius: var(--radius-sm);
            padding: var(--spacing-xs);
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
            flex: 1;
            min-height: 0;
        }

        .sidebar-right-section h3 {
            color: var(--primary-color);
            font-size: 0.7rem;
            font-weight: 700;
            margin-bottom: var(--spacing-xs);
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            border-bottom: 1px solid var(--primary-color);
            padding-bottom: var(--spacing-xs);
        }

        /* ULTRA COMPACT 3D WORD LIST */
        .word-list {
            max-height: 80px;
            overflow-y: auto;
            padding: var(--spacing-xs);
            background: rgba(102, 126, 234, 0.05);
            border-radius: var(--radius-sm);
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .word-list li {
            padding: 3px 6px;
            margin-bottom: 3px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: var(--radius-sm);
            border-left: 2px solid var(--primary-color);
            transition: all 0.3s ease;
            font-size: 0.65rem;
            font-weight: 500;
            color: var(--gray-800);
        }

        /* ULTRA COMPACT 3D LETTER QUEUE */
        .letter-queue {
            margin-top: var(--spacing-xs);
        }

        .queue-display {
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
            padding: var(--spacing-xs);
            background: rgba(102, 126, 234, 0.05);
            border-radius: var(--radius-sm);
            border: 1px solid rgba(102, 126, 234, 0.2);
            max-height: 60px;
            overflow-y: auto;
        }

        .queue-letter {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            width: 20px;
            height: 20px;
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.6rem;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
        }

        /* ULTRA COMPACT 3D GAME CONTROLS */
        .game-controls {
            display: flex;
            gap: var(--spacing-xs);
            justify-content: center;
            margin-top: var(--spacing-xs);
            flex-wrap: wrap;
            position: absolute;
            bottom: var(--spacing-xs);
            left: var(--spacing-xs);
            right: var(--spacing-xs);
            z-index: 10;
        }

        .game-controls .btn {
            padding: 6px 12px;
            font-size: 0.65rem;
            min-width: 60px;
        }

        /* ULTRA COMPACT 3D PROGRESSION */
        .progression-info {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .progression-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .progression-label {
            color: var(--gray-600);
            font-weight: 600;
            font-size: 0.65rem;
        }

        .progression-value {
            color: var(--primary-color);
            font-weight: 700;
            font-size: 0.8rem;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* ULTRA COMPACT 3D CANVAS CONTAINER */
        .game-canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            border-radius: var(--radius-sm);
            padding: var(--spacing-xs);
            border: 2px solid rgba(255, 255, 255, 0.4);
            position: relative;
            overflow: hidden;
            height: 100%;
            margin-top: 50px;
            margin-bottom: 50px;
        }

        #gameCanvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-md);
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: block;
        }

        /* RESPONSIVE DESIGN FOR ULTRA COMPACT 3D LAYOUT */
        @media (max-width: 1600px) {
            .page-layout {
                grid-template-columns: 130px 1fr 150px;
                gap: var(--spacing-xs);
                padding: 4px;
            }
            
            .game-header h1 {
                font-size: 0.9rem;
            }
            
            .sidebar-left-section h3,
            .sidebar-right-section h3 {
                font-size: 0.65rem;
            }
            
            .word-list li {
                font-size: 0.6rem;
                padding: 2px 5px;
            }
            
            .queue-letter {
                width: 18px;
                height: 18px;
                font-size: 0.55rem;
            }
        }

        @media (max-width: 1400px) {
            .page-layout {
                grid-template-columns: 120px 1fr 140px;
                gap: 4px;
                padding: 3px;
            }
            
            .game-header {
                height: 35px;
            }
            
            .game-header h1 {
                font-size: 0.85rem;
            }
            
            .stat-item .label {
                font-size: 0.45rem;
            }
            
            .stat-item .value {
                font-size: 0.75rem;
            }
            
            .game-controls .btn {
                padding: 5px 10px;
                font-size: 0.6rem;
                min-width: 55px;
            }
        }

        @media (max-width: 1200px) {
            .page-layout {
                grid-template-columns: 110px 1fr 130px;
                gap: 3px;
                padding: 2px;
            }
            
            .game-header {
                height: 32px;
            }
            
            .game-header h1 {
                font-size: 0.8rem;
            }
            
            .sidebar-left-section,
            .sidebar-right-section {
                padding: 6px;
            }
            
            .word-list {
                max-height: 70px;
                padding: 4px;
            }
            
            .word-list li {
                font-size: 0.55rem;
                padding: 2px 4px;
                margin-bottom: 2px;
            }
            
            .queue-display {
                max-height: 50px;
                padding: 4px;
                gap: 2px;
            }
            
            .queue-letter {
                width: 16px;
                height: 16px;
                font-size: 0.5rem;
            }
            
            .progression-label {
                font-size: 0.6rem;
            }
            
            .progression-value {
                font-size: 0.75rem;
            }
        }

        @media (max-width: 1024px) {
            .page-layout {
                grid-template-columns: 100px 1fr 120px;
                gap: 2px;
                padding: 2px;
            }
            
            .game-header {
                height: 30px;
            }
            
            .game-header h1 {
                font-size: 0.75rem;
            }
            
            .game-stats {
                padding: 3px;
                gap: 3px;
            }
            
            .stat-item {
                padding: 3px;
            }
            
            .stat-item .label {
                font-size: 0.4rem;
            }
            
            .stat-item .value {
                font-size: 0.7rem;
            }
            
            .game-controls .btn {
                padding: 4px 8px;
                font-size: 0.55rem;
                min-width: 50px;
            }
            
            .game-canvas-container {
                margin-top: 40px;
                margin-bottom: 40px;
            }
        }

        /* ENSURE NO SCROLLING ON ANY SCREEN SIZE */
        body {
            overflow: hidden;
        }

        .main-content {
            overflow: hidden;
        }

        .sidebar-left,
        .sidebar-right {
            overflow: hidden;
        }

        /* CUSTOM SCROLLBARS FOR COMPACT DESIGN */
        .word-list::-webkit-scrollbar {
            width: 2px;
        }

        .word-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .word-list::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 1px;
        }

        .word-list::-webkit-scrollbar-thumb:hover {
            background: var(--secondary-color);
        }

        .queue-display::-webkit-scrollbar {
            width: 2px;
        }

        .queue-display::-webkit-scrollbar-track {
            background: transparent;
        }

        .queue-display::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 1px;
        }

        .queue-display::-webkit-scrollbar-thumb:hover {
            background: var(--secondary-color);
        }

        /* ENHANCED VISIBILITY FOR ULTRA COMPACT */
        .game-stats {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            backdrop-filter: blur(15px);
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .sidebar-left-section,
        .sidebar-right-section {
            background: rgba(255, 255, 255, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .game-canvas-container {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            border: 2px solid rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="page-layout">
            <!-- Navigation Sidebar -->
            <div class="nav-sidebar">
                <h3>Navigation</h3>
                <div class="nav-links">
                    <a href="index.html"><i class="fas fa-home"></i> Accueil</a>
                    <a href="prototype.html"><i class="fas fa-flask"></i> Maquette 2D</a>
                    <a href="game.html" class="active"><i class="fas fa-gamepad"></i> Maquette 3D</a>
                    <a href="GDD.html"><i class="fas fa-file-alt"></i> Documentation</a>
                    <a href="rules.html"><i class="fas fa-book"></i> R√®gles</a>
                    <a href="moodboard.html"><i class="fas fa-palette"></i> Moodboard</a>
                    <a href="sitemap.html"><i class="fas fa-sitemap"></i> Plan de Site</a>
                </div>
            </div>

            <div class="main-content">
                <!-- Game Header -->
                <div class="game-header">
                    <h1>üéÆ Maquette 3D - Letters Cascade Challenge</h1>
                </div>

                <!-- Game Container -->
                <div class="game-container">
                    <!-- Game Stats Overlay -->
                    <div class="game-stats">
                        <div class="stat-item">
                            <div class="value" id="scoreDisplay">0</div>
                            <div class="label">Score</div>
                        </div>
                        <div class="stat-item">
                            <div class="value" id="levelDisplay">1</div>
                            <div class="label">Niveau</div>
                        </div>
                        <div class="stat-item">
                            <div class="value" id="wordsCompleted">0</div>
                            <div class="label">Mots Compl√©t√©s</div>
                        </div>
                        <div class="stat-item">
                            <div class="value" id="comboDisplay">0</div>
                            <div class="label">Combo</div>
                        </div>
                    </div>

                    <!-- Game Canvas Container -->
                    <div class="game-canvas-container">
                        <div id="gameGrid">
                            <!-- 3D Game Canvas will be rendered here -->
                        </div>
                    </div>

                    <!-- Game Controls -->
                    <div class="game-controls">
                        <button class="btn btn-primary" onclick="game3D.startGame()">
                            <i class="fas fa-play"></i> D√©marrer
                        </button>
                        <button class="btn btn-secondary" onclick="game3D.resetGame()">
                            <i class="fas fa-redo"></i> Reset
                        </button>
                        <button class="btn btn-warning" onclick="game3D.pauseGame()">
                            <i class="fas fa-pause"></i> Pause
                        </button>
                        <a href="game-fullscreen.html" class="btn btn-success">
                            <i class="fas fa-external-link-alt"></i> Version Immersive
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script>
        // Complete 3D Game Engine for Letters Cascade Challenge
        // Implements all functionalities from technical specifications
        class Game3D {
            constructor() {
                console.log('üîß Game3D constructor called');
                
                // Game Configuration
                this.mode = '3d';
                this.gridSizes = [8, 10, 12];
                this.currentGridSize = 10;
                this.cellSize = 1.2;
                this.gap = 0.2;
                
                // Game State
                this.gameRunning = false;
                this.paused = false;
                this.gameOver = false;
                this.level = 1;
                this.score = 0;
                this.highScore = this.loadHighScore();
                this.combo = 0;
                this.maxCombo = 0;
                this.startTime = null;
                
                // 3D Scene Components
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.raycaster = null;
                this.mouse = null;
                
                // Game Mechanics
                this.grid = [];
                this.letters = [];
                this.letterQueue = [];
                this.wordsFound = [];
                this.targetWords = ['CHAT', 'MAISON', 'MUSIQUE', 'JARDIN', 'LIVRE', 'TABLE', 'FEN√äTRE', 'PORTE'];
                this.fallingLetter = null;
                this.fallSpeed = 1000;
                this.fallTimer = null;
                
                // üéØ INTELLIGENT BALANCING SYSTEM (3D)
                this.balancingSystem = {
                    // Letter Distribution based on target words
                    letterFrequency: this.calculateLetterFrequency(),
                    
                    // Dynamic speed adjustment
                    baseFallSpeed: 1000,
                    minFallSpeed: 600,
                    maxFallSpeed: 2000,
                    speedMultiplier: 1.0,
                    
                    // Grid size optimization
                    optimalGridSize: 10,
                    gridSizeAdjustment: 0,
                    
                    // Word difficulty scaling
                    wordDifficulty: {
                        easy: ['CHAT', 'LIVRE', 'TABLE'],
                        medium: ['MAISON', 'JARDIN', 'PORTE'],
                        hard: ['MUSIQUE', 'FEN√äTRE']
                    },
                    
                    // Level progression balance
                    levelBalance: {
                        lettersPerLevel: 3,
                        speedIncrease: 0.1,
                        complexityIncrease: 0.15
                    }
                };
                
                // 3D Specific
                this.cubes = [];
                this.textMeshes = [];
                this.lights = [];
                this.particles = [];
                
                // Word Detection System
                this.dictionary = this.loadDictionary();
                this.wordDetector = new WordDetector3D(this.dictionary);
                
                // Scoring System
                this.scoreManager = new ScoreManager3D();
                
                // Level System
                this.levelManager = new LevelManager3D();
                
                // Audio System
                this.audioManager = new AudioManager3D();
                
                // Particle System
                this.particleSystem = new ParticleSystem3D();
                
                // Statistics
                this.stats = {
                    lettersPlaced: 0,
                    wordsCompleted: 0,
                    totalScore: 0,
                    playTime: 0,
                    startTime: null,
                    mode: '3D'
                };
                
                // Apply initial balancing
                this.applyBalancing();
                
                console.log('üîß Game3D constructor completed, calling init()');
                this.init();
            }
            
            // Initialize 3D game
            init() {
                console.log('üöÄ Initializing 3D game...');
                
                // Check WebGL support
                if (!this.checkWebGLSupport()) {
                    console.error('‚ùå WebGL not supported');
                    this.showWebGLError();
                    return;
                }
                
                // Initialize Three.js components
                this.initThreeJS();
                this.create3DGrid();
                this.setupEnhancedLighting();
                this.setupCamera();
                this.setupControls();
                this.generateLetterQueue();
                
                // Start animation loop
                this.animate();
                
                console.log('‚úÖ 3D game initialized successfully');
            }
            
            // Enhanced Three.js Initialization
            initThreeJS() {
                console.log('üé® Initializing Three.js components...');
                
                // Create scene with enhanced background
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a0a);
                
                // Add atmospheric fog
                this.scene.fog = new THREE.Fog(0x0a0a0a, 10, 50);
                
                // Create enhanced camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 15, 20);
                this.camera.lookAt(0, 0, 0);
                
                // Create enhanced renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
                
                // Add renderer to DOM
                const container = document.getElementById('gameGrid');
                if (container) {
                    container.appendChild(this.renderer.domElement);
                }
                
                // Setup raycaster for mouse interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                console.log('‚úÖ Three.js components initialized');
            }
            
            // Enhanced Lighting Setup
            setupEnhancedLighting() {
                console.log('üí° Setting up enhanced lighting...');
                
                // Ambient light for overall illumination
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // Main directional light with shadows
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -10;
                directionalLight.shadow.camera.right = 10;
                directionalLight.shadow.camera.top = 10;
                directionalLight.shadow.camera.bottom = -10;
                this.scene.add(directionalLight);
                
                // Point light for dramatic effect
                const pointLight = new THREE.PointLight(0x667eea, 0.8, 30);
                pointLight.position.set(0, 15, 0);
                this.scene.add(pointLight);
                
                // Spot light for focused illumination
                const spotLight = new THREE.SpotLight(0xffffff, 0.5, 30, Math.PI / 4, 0.5);
                spotLight.position.set(0, 20, 0);
                spotLight.target.position.set(0, 0, 0);
                this.scene.add(spotLight);
                this.scene.add(spotLight.target);
                
                console.log('‚úÖ Enhanced lighting setup completed');
            }
            
            // WebGL Support Check
            checkWebGLSupport() {
                try {
                    const canvas = document.createElement('canvas');
                    return !!(window.WebGLRenderingContext && 
                        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
                } catch (e) {
                    return false;
                }
            }
            
            showWebGLError() {
                const container = document.getElementById('gameGrid');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: #ef4444;">
                            <h3>‚ùå WebGL Not Supported</h3>
                            <p>Your browser doesn't support WebGL. Please try a different browser or enable hardware acceleration.</p>
                            <button onclick="location.reload()" class="btn btn-primary">Reload Page</button>
                        </div>
                    `;
                }
            }
            
            // Setup Camera
            setupCamera() {
                this.camera.position.set(0, 0, 15);
                this.camera.lookAt(0, 0, 0);
            }
            
            // Setup Controls
            setupControls() {
                // Keyboard controls
                document.addEventListener('keydown', (event) => {
                    if (!this.gameRunning || this.paused) return;
                    
                    switch(event.key) {
                        case 'ArrowLeft':
                            this.moveFallingLetter(-1);
                            break;
                        case 'ArrowRight':
                            this.moveFallingLetter(1);
                            break;
                        case 'ArrowDown':
                            this.dropFallingLetter();
                            break;
                        case ' ':
                            this.rotateFallingLetter();
                            break;
                        case 'p':
                        case 'P':
                            this.togglePause();
                            break;
                        case 'r':
                        case 'R':
                            this.resetGame();
                            break;
                    }
                });
            }
            
            // Event Listeners
            setupEventListeners() {
                const canvas = this.renderer.domElement;
                
                // Mouse move for hover effects
                canvas.addEventListener('mousemove', (event) => {
                    this.onMouseMove(event);
                });
                
                // Mouse click for letter placement
                canvas.addEventListener('click', (event) => {
                    this.onCanvasClick(event);
                });
            }
            
            // Mouse Interaction
            onMouseMove(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children);
                
                // Reset all cube colors
                for (let row = 0; row < this.currentGridSize; row++) {
                    for (let col = 0; col < this.currentGridSize; col++) {
                        const cell = this.grid[row][col];
                        if (cell && !cell.userData.occupied) {
                            cell.material.color.setHex(0x2a2a3e);
                            cell.scale.set(1, 1, 1);
                        }
                    }
                }
                
                // Highlight hovered cube
                if (intersects.length > 0) {
                    const intersected = intersects[0].object;
                    if (intersected.userData && !intersected.userData.occupied) {
                        intersected.material.color.setHex(0x4ecdc4);
                        intersected.scale.set(1.1, 1.1, 1.1);
                    }
                }
            }
            
            // Canvas Click
            onCanvasClick(event) {
                if (!this.gameRunning || this.paused || !this.fallingLetter) return;
                
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children);
                
                if (intersects.length > 0) {
                    const intersected = intersects[0].object;
                    if (intersected.userData && !intersected.userData.occupied) {
                        this.placeLetter3D(intersected.userData.row, intersected.userData.col, event);
                    }
                }
            }
            
            // Place Letter in 3D
            placeLetter3D(row, col, event) {
                console.log('üéØ placeLetter3D() called - row:', row, 'col:', col, 'letters remaining:', this.letters.length);
                
                if (this.letterQueue.length === 0) {
                    this.generateLetterQueue();
                }
                
                const letter = this.letterQueue.shift();
                const cell = this.grid[row][col];
                
                if (!cell || cell.userData.occupied) {
                    console.warn('‚ö†Ô∏è Cell already occupied or invalid');
                    return;
                }
                
                // Create 3D text
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const context = canvas.getContext('2d');
                
                // Create gradient background
                const gradient = context.createLinearGradient(0, 0, 128, 128);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 128, 128);
                
                // Add text shadow
                context.shadowColor = 'rgba(0, 0, 0, 0.5)';
                context.shadowBlur = 4;
                context.shadowOffsetX = 2;
                context.shadowOffsetY = 2;
                
                // Draw letter
                context.fillStyle = 'white';
                context.font = 'bold 72px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(letter, 64, 64);
                
                // Create texture
                const texture = new THREE.CanvasTexture(canvas);
                const textGeometry = new THREE.PlaneGeometry(0.8, 0.8);
                const textMaterial = new THREE.MeshBasicMaterial({ 
                    map: texture,
                    transparent: true,
                    alphaTest: 0.5
                });
                
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.copy(cell.position);
                textMesh.position.y += 0.6;
                textMesh.rotation.x = -Math.PI / 2;
                
                // Add glow effect
                const glowGeometry = new THREE.PlaneGeometry(1, 1);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x4ecdc4,
                    transparent: true,
                    opacity: 0.3
                });
                
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.position.copy(textMesh.position);
                glowMesh.position.y += 0.01;
                glowMesh.rotation.x = -Math.PI / 2;
                
                // Add to scene
                this.scene.add(textMesh);
                this.scene.add(glowMesh);
                
                // Update cell data
                cell.userData.letter = textMesh;
                cell.userData.glow = glowMesh;
                cell.userData.occupied = true;
                cell.userData.letterValue = letter;
                
                // Change cube color
                cell.material.color.setHex(0x4ecdc4);
                
                // Add scale animation
                this.addPulseAnimation(textMesh);
                this.addPulseAnimation(glowMesh);
                
                // Update game state
                this.stats.lettersPlaced++;
                this.audioManager.playPlace();
                this.particleSystem.createPlacementEffect3D(cell.position);
                
                // Check for word completion
                this.checkWordCompletion();
                
                // Update display
                this.updateDisplay();
                
                console.log('‚úÖ Letter placed successfully in 3D scene');
            }
            
            // Add Pulse Animation
            addPulseAnimation(mesh) {
                const scale = { value: 1 };
                const tween = new TWEEN.Tween(scale)
                    .to({ value: 1.2 }, 200)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .onUpdate(() => {
                        mesh.scale.set(scale.value, scale.value, scale.value);
                    })
                    .yoyo(true)
                    .repeat(1)
                    .start();
            }
            
            // Generate Letter Queue
            generateLetterQueue() {
                console.log('üìù Generating 3D letter queue...');
                this.letterQueue = [];
                const vowels = ['A', 'E', 'I', 'O', 'U'];
                const consonants = ['B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z'];
                
                // Balanced letter distribution
                for (let i = 0; i < 10; i++) {
                    if (Math.random() < 0.4) {
                        this.letterQueue.push(vowels[Math.floor(Math.random() * vowels.length)]);
                    } else {
                        this.letterQueue.push(consonants[Math.floor(Math.random() * consonants.length)]);
                    }
                }
                
                console.log('‚úÖ 3D letter queue generated:', this.letterQueue);
                this.updateLetterQueueDisplay();
            }
            
            // Word Detection for 3D
            checkWordCompletion() {
                if (this.mode === '3d') {
                    console.log('üéÆ Checking 3D word completion');
                    this.checkWordCompletion3D();
                }
            }
            
            checkWordCompletion3D() {
                console.log('üéÆ checkWordCompletion3D() called');
                
                // Create 2D grid from 3D grid data
                const grid = [];
                for (let row = 0; row < this.currentGridSize; row++) {
                    grid[row] = [];
                    for (let col = 0; col < this.currentGridSize; col++) {
                        // Extract letter from 3D mesh (simplified)
                        grid[row][col] = this.getLetterFrom3DMesh(this.grid[row][col].userData.letter) || '';
                    }
                }
                
                console.log('üìê 3D grid created:', grid);
                
                // Use word detector
                const words = this.wordDetector.scanGrid(grid);
                console.log('üìù Words found in 3D:', words);
                
                if (words.length > 0) {
                    words.forEach(word => {
                        this.completeWord3D(word);
                    });
                    
                    // Update combo
                    this.combo += words.length;
                    if (this.combo > this.maxCombo) {
                        this.maxCombo = this.combo;
                    }
                    
                    // Add combo bonus
                    if (this.combo > 1) {
                        const comboBonus = this.combo * 50;
                        this.addScore(comboBonus);
                        this.showComboEffect3D(comboBonus);
                    }
                } else {
                    this.combo = 0;
                }
                
                this.updateDisplay();
            }
            
            getLetterFrom3DMesh(mesh) {
                console.log('üîç getLetterFrom3DMesh() called for mesh:', mesh);
                if (!mesh || !mesh.userData) return null;
                return mesh.userData.letterValue;
            }
            
            completeWord3D(word) {
                console.log('üèÜ Word completed in 3D:', word);
                
                // Add word to found list
                this.wordsFound.push(word);
                
                // Calculate score
                const wordScore = word.length * 10;
                this.addScore(wordScore);
                
                // Remove word from 3D grid
                this.removeWordFrom3DGrid(word);
                
                // Create 3D particle effect
                this.particleSystem.createWordCompletionEffect3D(word);
                
                // Play sound
                this.audioManager.playWordComplete();
                
                // Check level progression
                this.levelManager.checkLevelProgression(this.wordsFound.length);
                
                console.log('‚úÖ 3D word completed:', word, 'Score:', wordScore);
            }
            
            removeWordFrom3DGrid(word) {
                // Find and remove letters of the word from 3D grid
                for (let row = 0; row < this.currentGridSize; row++) {
                    for (let col = 0; col < this.currentGridSize; col++) {
                        const cell = this.grid[row][col];
                        if (cell.userData.letterValue === word[0]) {
                            // Check if this is the start of the word
                            if (this.checkWordAt3DPosition(row, col, word)) {
                                this.removeWordAt3DPosition(row, col, word);
                                return;
                            }
                        }
                    }
                }
            }
            
            checkWordAt3DPosition(row, col, word) {
                // Check horizontal
                if (col + word.length <= this.currentGridSize) {
                    let match = true;
                    for (let i = 0; i < word.length; i++) {
                        if (this.grid[row][col + i].userData.letterValue !== word[i]) {
                            match = false;
                            break;
                        }
                    }
                    if (match) return true;
                }
                
                // Check vertical
                if (row + word.length <= this.currentGridSize) {
                    let match = true;
                    for (let i = 0; i < word.length; i++) {
                        if (this.grid[row + i][col].userData.letterValue !== word[i]) {
                            match = false;
                            break;
                        }
                    }
                    if (match) return true;
                }
                
                return false;
            }
            
            removeWordAt3DPosition(row, col, word) {
                // Remove letters from 3D grid
                for (let i = 0; i < word.length; i++) {
                    const cell = this.grid[row][col + i];
                    if (cell.userData.letter) {
                        this.scene.remove(cell.userData.letter);
                    }
                    if (cell.userData.glow) {
                        this.scene.remove(cell.userData.glow);
                    }
                    cell.userData.letter = null;
                    cell.userData.glow = null;
                    cell.userData.occupied = false;
                    cell.userData.letterValue = null;
                    cell.material.color.setHex(0x2a2a3e);
                }
            }
            
            // Scoring System
            addScore(points) {
                console.log('üí∞ Adding 3D score:', points);
                this.score += points;
                this.stats.totalScore += points;
                
                // Update high score
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    this.saveHighScore();
                }
                
                this.scoreManager.updateScore(this.score);
                this.updateDisplay();
            }
            
            // Game Controls
            startGame() {
                console.log('‚ñ∂Ô∏è Starting 3D game...');
                
                if (this.gameRunning) return;
                
                this.gameRunning = true;
                this.paused = false;
                this.gameOver = false;
                this.stats.startTime = Date.now();
                this.startTime = Date.now();
                
                this.audioManager.playStart();
                console.log('‚úÖ 3D game started');
            }
            
            pauseGame() {
                console.log('‚è∏Ô∏è Pausing 3D game...');
                
                if (!this.gameRunning) return;
                
                this.paused = !this.paused;
                
                if (this.paused) {
                    this.audioManager.playPause();
                } else {
                    this.audioManager.playResume();
                }
                
                this.updateDisplay();
                console.log('‚úÖ 3D game paused:', this.paused);
            }
            
            resetGame() {
                console.log('üîÑ Resetting 3D game...');
                
                this.gameRunning = false;
                this.paused = false;
                this.gameOver = false;
                this.score = 0;
                this.level = 1;
                this.combo = 0;
                this.maxCombo = 0;
                this.wordsFound = [];
                this.fallSpeed = 1000;
                
                this.clear3DGrid();
                this.generateLetterQueue();
                this.updateDisplay();
                
                this.audioManager.playReset();
                console.log('‚úÖ 3D game reset');
            }
            
            clear3DGrid() {
                console.log('üéÆ Clearing 3D grid');
                
                for (let row = 0; row < this.currentGridSize; row++) {
                    for (let col = 0; col < this.currentGridSize; col++) {
                        const cell = this.grid[row][col];
                        if (cell.userData.letter) {
                            this.scene.remove(cell.userData.letter);
                        }
                        if (cell.userData.glow) {
                            this.scene.remove(cell.userData.glow);
                        }
                        cell.userData.letter = null;
                        cell.userData.glow = null;
                        cell.userData.occupied = false;
                        cell.userData.letterValue = null;
                        cell.material.color.setHex(0x2a2a3e);
                        cell.material.opacity = 1;
                    }
                }
            }
            
            // Display Updates
            updateDisplay() {
                console.log('üìä updateDisplay() called - score:', this.score, 'level:', this.level, 'mode:', this.mode);
                
                const scoreElement = document.getElementById('scoreDisplay');
                const levelElement = document.getElementById('levelDisplay');
                const timeElement = document.getElementById('timeDisplay');
                const wordsElement = document.getElementById('wordsCompleted');
                const modeElement = document.getElementById('currentMode');
                const gridElement = document.getElementById('currentGrid');
                
                console.log('üì¶ Display elements found:', {
                    score: scoreElement,
                    level: levelElement,
                    time: timeElement,
                    words: wordsElement,
                    mode: modeElement,
                    grid: gridElement
                });
                
                if (scoreElement) scoreElement.textContent = this.score;
                if (levelElement) levelElement.textContent = this.level;
                
                // Update mode display
                if (modeElement) {
                    const modeText = this.mode === '3d' ? '3D' : '2D';
                    modeElement.textContent = modeText;
                    console.log('üéÆ Mode display updated to:', modeText);
                }
                
                // Update grid size display
                if (gridElement) {
                    gridElement.textContent = `${this.currentGridSize}√ó${this.currentGridSize}`;
                    console.log('üìê Grid display updated to:', `${this.currentGridSize}√ó${this.currentGridSize}`);
                }
                
                // Update time if game is running
                if (this.gameRunning && this.startTime) {
                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    if (timeElement) timeElement.textContent = `${Math.floor(elapsed / 60)}:${(elapsed % 60).toString().padStart(2, '0')}`;
                }
                
                if (wordsElement) wordsElement.textContent = this.wordsFound.length;
                
                // Update mode buttons to reflect current mode
                this.updateModeButtons();
                
                console.log('‚úÖ Display updated');
            }
            
            updateModeButtons() {
                console.log('üéÆ updateModeButtons() called - current mode:', this.mode);
                
                const modeButtons = document.querySelectorAll('.mode-btn');
                modeButtons.forEach(btn => {
                    const btnMode = btn.dataset.mode;
                    if (btnMode === this.mode) {
                        btn.classList.add('active');
                        console.log('‚úÖ Mode button activated:', btnMode);
                    } else {
                        btn.classList.remove('active');
                        console.log('‚ùå Mode button deactivated:', btnMode);
                    }
                });
            }
            
            // Enhanced Animation Loop
            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (!this.gameRunning || this.paused) {
                    this.renderer.render(this.scene, this.camera);
                    return;
                }
                
                // Enhanced camera movement
                this.updateCamera();
                
                // Update falling letter
                this.updateFallingLetter();
                
                // Update particles
                this.particleSystem.update();
                
                // Update letter animations
                this.updateLetterAnimations();
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
            }
            
            // Enhanced Camera Movement
            updateCamera() {
                const time = Date.now() * 0.001;
                
                // Gentle camera movement
                this.camera.position.x = Math.sin(time * 0.5) * 2;
                this.camera.position.y = 15 + Math.sin(time * 0.3) * 1;
                this.camera.position.z = 20 + Math.cos(time * 0.5) * 2;
                
                // Look at the center of the grid
                this.camera.lookAt(0, 0, 0);
            }
            
            // Enhanced Letter Animations
            updateLetterAnimations() {
                this.textMeshes.forEach(mesh => {
                    if (mesh.userData.isFalling) {
                        // Pulsing animation for falling letters
                        const time = Date.now() * 0.005;
                        const pulse = Math.sin(time) * 0.1 + 1;
                        mesh.scale.setScalar(pulse);
                        
                        // Update glow effect
                        if (mesh.userData.glowMesh) {
                            mesh.userData.glowMesh.scale.setScalar(pulse * 1.1);
                            mesh.userData.glowMesh.material.opacity = 0.3 * pulse;
                        }
                    } else {
                        // Gentle floating animation for placed letters
                        const time = Date.now() * 0.002;
                        mesh.position.y = mesh.userData.originalY + Math.sin(time + mesh.userData.offset) * 0.05;
                    }
                });
            }
            
            // Enhanced Falling Letter Update
            updateFallingLetter() {
                if (!this.fallingLetter) return;
                
                const time = Date.now() * 0.001;
                
                // Update falling letter position
                this.fallingLetter.y += 0.02;
                
                // Check collision
                if (this.checkCollision3D(this.fallingLetter.x, this.fallingLetter.y, this.fallingLetter.z)) {
                    this.placeLetter3D();
                }
                
                // Update visual representation
                this.updateFallingLetterVisual();
            }
            
            // Enhanced Letter Placement
            placeLetter3D() {
                if (!this.fallingLetter) return;
                
                const { x, y, z, letter } = this.fallingLetter;
                
                console.log('üìù Placing 3D letter:', letter, 'at position:', { x, y, z });
                
                // Place letter in grid
                const gridX = Math.floor((x + this.currentGridSize * (this.cellSize + this.gap) / 2) / (this.cellSize + this.gap));
                const gridZ = Math.floor((z + this.currentGridSize * (this.cellSize + this.gap) / 2) / (this.cellSize + this.gap));
                
                if (gridX >= 0 && gridX < this.currentGridSize && gridZ >= 0 && gridZ < this.currentGridSize) {
                    this.grid[gridZ][gridX] = letter;
                    
                    // Create visual letter
                    this.createLetter3D(letter, x, y, z, false);
                    
                    // Create placement effect
                    this.particleSystem.createPlacementEffect3D(x, y, z);
                    
                    // Play sound
                    this.audioManager.playPlace();
                    
                    // Check for word completion
                    this.checkWordCompletion3D();
                    
                    // Create new falling letter
                    this.createFallingLetter3D();
                }
            }
            
            // Utility Methods
            updateLetterQueueDisplay() {
                const queueElement = document.getElementById('letterQueue');
                if (queueElement) {
                    queueElement.innerHTML = '';
                    this.letterQueue.slice(0, 5).forEach(letter => {
                        const span = document.createElement('span');
                        span.textContent = letter;
                        span.className = 'queue-letter';
                        queueElement.appendChild(span);
                    });
                }
            }
            
            showComboEffect3D(bonus) {
                this.particleSystem.createComboEffect3D(bonus);
            }
            
            // Storage
            saveHighScore() {
                localStorage.setItem('lettersCascade3DHighScore', this.highScore.toString());
            }
            
            loadHighScore() {
                const saved = localStorage.getItem('lettersCascade3DHighScore');
                return saved ? parseInt(saved) : 0;
            }
            
            loadDictionary() {
                // French dictionary for word validation
                return new Set([
                    'BONJOUR', 'AU REVOIR', 'MERCI', 'SIL VOUS PLAIT', 'PARDON',
                    'OUI', 'NON', 'PEUT ETRE', 'CERTAINEMENT', 'PROBABLEMENT',
                    'MAINTENANT', 'AUJOURDHUI', 'HIER', 'DEMAIN', 'TOUJOURS',
                    'JAMAIS', 'PARFOIS', 'SOUVENT', 'RAREMENT', 'QUELQUEFOIS',
                    'BON', 'MAUVAIS', 'GRAND', 'PETIT', 'NOUVEAU', 'VIEUX',
                    'BEAU', 'JOLI', 'MOCHE', 'FORT', 'FAIBLE', 'RAPIDE', 'LENT',
                    'CHALEUREUX', 'FROID', 'CHAUD', 'DOUX', 'DUR', 'MOLLE',
                    'CLAIR', 'SOMBRE', 'LUMINEUX', 'OBSCUR', 'TRANSPARENT',
                    'OPAQUE', 'COLORE', 'BLANC', 'NOIR', 'ROUGE', 'BLEU',
                    'VERT', 'JAUNE', 'ORANGE', 'VIOLET', 'ROSE', 'GRIS',
                    'MARRON', 'BEIGE', 'DORE', 'ARGENTE', 'BRONZE', 'CUIVRE'
                ]);
            }
            
            // Mode and Grid Selection Methods
            selectMode(mode) {
                console.log('üéÆ selectMode called with mode:', mode);
                this.mode = mode;
                this.updateDisplay();
                this.updateModeButtons();
            }
            
            selectGrid(size) {
                console.log('üéÆ selectGrid called with size:', size);
                if (this.gridSizes.includes(size)) {
                    this.currentGridSize = size;
                    this.create3DGrid();
                    this.generateLetterQueue();
                    this.updateDisplay();
                }
            }

            // Enhanced 3D Grid Creation
            create3DGrid() {
                console.log('üèóÔ∏è Creating enhanced 3D grid...');
                
                this.grid = [];
                this.cubes = [];
                
                const gridSize = this.currentGridSize;
                const cellSize = this.cellSize;
                const gap = this.gap;
                const totalSize = gridSize * (cellSize + gap) - gap;
                const startX = -totalSize / 2;
                const startZ = -totalSize / 2;
                
                // Create grid array
                for (let row = 0; row < gridSize; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < gridSize; col++) {
                        this.grid[row][col] = null;
                    }
                }
                
                // Create visual grid cells
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        const x = startX + col * (cellSize + gap) + cellSize / 2;
                        const z = startZ + row * (cellSize + gap) + cellSize / 2;
                        const y = 0;
                        
                        // Create enhanced cube geometry
                        const geometry = new THREE.BoxGeometry(cellSize, 0.1, cellSize);
                        
                        // Create enhanced material with glass effect
                        const material = new THREE.MeshPhongMaterial({
                            color: 0xffffff,
                            transparent: true,
                            opacity: 0.3,
                            shininess: 100,
                            specular: 0x444444
                        });
                        
                        const cube = new THREE.Mesh(geometry, material);
                        cube.position.set(x, y, z);
                        cube.castShadow = true;
                        cube.receiveShadow = true;
                        cube.userData = { row, col, type: 'grid' };
                        
                        this.scene.add(cube);
                        this.cubes.push(cube);
                    }
                }
                
                console.log('‚úÖ Enhanced 3D grid created with', this.cubes.length, 'cells');
            }
            
            // Enhanced Letter Creation
            createLetter3D(letter, x, y, z, isFalling = false) {
                console.log('üìù Creating 3D letter:', letter, 'at position:', { x, y, z });
                
                // Create enhanced text geometry
                const loader = new THREE.FontLoader();
                const fontUrl = 'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json';
                
                loader.load(fontUrl, (font) => {
                    const textGeometry = new THREE.TextGeometry(letter, {
                        font: font,
                        size: 0.8,
                        height: 0.2,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.03,
                        bevelSize: 0.02,
                        bevelOffset: 0,
                        bevelSegments: 5
                    });
                    
                    // Center the geometry
                    textGeometry.computeBoundingBox();
                    const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
                    
                    // Create enhanced material
                    const material = new THREE.MeshPhongMaterial({
                        color: isFalling ? 0x667eea : 0x4f46e5,
                        transparent: true,
                        opacity: 0.9,
                        shininess: 80,
                        specular: 0x222222
                    });
                    
                    const textMesh = new THREE.Mesh(textGeometry, material);
                    textMesh.position.set(x + centerOffset, y, z);
                    textMesh.castShadow = true;
                    textMesh.receiveShadow = true;
                    textMesh.userData = { letter, isFalling, type: 'letter' };
                    
                    // Add glow effect for falling letters
                    if (isFalling) {
                        const glowGeometry = textGeometry.clone();
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            color: 0x667eea,
                            transparent: true,
                            opacity: 0.3
                        });
                        const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                        glowMesh.position.set(x + centerOffset, y, z);
                        glowMesh.scale.setScalar(1.1);
                        this.scene.add(glowMesh);
                        textMesh.userData.glowMesh = glowMesh;
                    }
                    
                    this.scene.add(textMesh);
                    this.textMeshes.push(textMesh);
                    
                    console.log('‚úÖ 3D letter created:', letter);
                });
            }

            // Fullscreen functionality
            toggleFullScreen() {
                console.log('üñ•Ô∏è Game3D.toggleFullScreen() called');
                
                const gameContainer = document.querySelector('.game-container');
                const fullscreenBtn = document.querySelector('button[onclick="game3D.toggleFullScreen()"]');
                
                console.log('üì¶ Game container found:', gameContainer);
                console.log('üîò Fullscreen button found:', fullscreenBtn);
                
                if (gameContainer.classList.contains('fullscreen')) {
                    console.log('üì§ Exiting fullscreen mode');
                    this.exitFullScreen();
                } else {
                    console.log('üì• Entering fullscreen mode');
                    this.enterFullScreen();
                }
            }
            
            enterFullScreen() {
                console.log('üì• Game3D.enterFullScreen() called');
                
                const gameContainer = document.querySelector('.game-container');
                const fullscreenBtn = document.querySelector('button[onclick="game3D.toggleFullScreen()"]');
                
                gameContainer.classList.add('fullscreen');
                if (fullscreenBtn) {
                    fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i> Sortir';
                }
                
                // Add exit button
                const exitBtn = document.createElement('div');
                exitBtn.className = 'fullscreen-exit';
                exitBtn.innerHTML = '<i class="fas fa-times"></i>';
                exitBtn.onclick = () => this.exitFullScreen();
                gameContainer.appendChild(exitBtn);
                
                // Resize 3D renderer for full screen
                if (this.renderer) {
                    const container = gameContainer.querySelector('.game-grid-container');
                    const containerRect = container.getBoundingClientRect();
                    const maxWidth = Math.min(containerRect.width * 0.9, window.innerWidth * 0.8);
                    const maxHeight = Math.min(containerRect.height * 0.9, window.innerHeight * 0.7);
                    const canvasSize = Math.min(maxWidth, maxHeight);
                    
                    console.log('üìê Fullscreen dimensions:', {
                        containerWidth: containerRect.width,
                        containerHeight: containerRect.height,
                        maxWidth: maxWidth,
                        maxHeight: maxHeight,
                        canvasSize: canvasSize
                    });
                    
                    this.renderer.setSize(canvasSize, canvasSize);
                    
                    // Update camera aspect ratio
                    if (this.camera) {
                        this.camera.aspect = canvasSize / canvasSize;
                        this.camera.updateProjectionMatrix();
                        console.log('üì∑ Camera aspect ratio updated for fullscreen');
                    }
                    
                    // Enhance 3D scene for full screen
                    if (this.scene) {
                        // Adjust camera position for better view
                        this.camera.position.set(0, 0, 18);
                        this.camera.lookAt(0, 0, 0);
                        
                        // Enhance lighting for full screen
                        this.scene.children.forEach(child => {
                            if (child.type === 'DirectionalLight') {
                                child.intensity = 1.5;
                            } else if (child.type === 'PointLight') {
                                child.intensity = 1.2;
                            }
                        });
                        
                        console.log('üé¨ 3D scene enhanced for fullscreen');
                    }
                } else {
                    console.warn('‚ö†Ô∏è Renderer not available for fullscreen resize');
                }
                
                // Add keyboard shortcuts for full screen
                document.addEventListener('keydown', this.handleFullScreenKeyboard.bind(this));
                
                console.log('‚úÖ Entered full screen mode');
            }
            
            exitFullScreen() {
                console.log('üì§ Game3D.exitFullScreen() called');
                
                const gameContainer = document.querySelector('.game-container');
                const fullscreenBtn = document.querySelector('button[onclick="game3D.toggleFullScreen()"]');
                
                gameContainer.classList.remove('fullscreen');
                if (fullscreenBtn) {
                    fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> Plein √âcran';
                }
                
                // Remove exit button
                const exitBtn = gameContainer.querySelector('.fullscreen-exit');
                if (exitBtn) {
                    gameContainer.removeChild(exitBtn);
                }
                
                // Reset 3D renderer size
                if (this.renderer) {
                    const container = gameContainer.querySelector('.game-grid-container');
                    const containerRect = container.getBoundingClientRect();
                    const size = Math.min(containerRect.width, containerRect.height);
                    
                    this.renderer.setSize(size, size);
                    
                    // Reset camera aspect ratio
                    if (this.camera) {
                        this.camera.aspect = size / size;
                        this.camera.updateProjectionMatrix();
                        console.log('üì∑ Camera aspect ratio reset');
                    }
                    
                    // Reset lighting
                    if (this.scene) {
                        this.scene.children.forEach(child => {
                            if (child.type === 'DirectionalLight') {
                                child.intensity = 1.0;
                            } else if (child.type === 'PointLight') {
                                child.intensity = 0.8;
                            }
                        });
                        
                        console.log('üé¨ 3D scene lighting reset');
                    }
                }
                
                // Remove keyboard shortcuts
                document.removeEventListener('keydown', this.handleFullScreenKeyboard.bind(this));
                
                console.log('‚úÖ Exited full screen mode');
            }
            
            handleFullScreenKeyboard(event) {
                if (event.key === 'Escape') {
                    this.exitFullScreen();
                }
            }

            // üéØ INTELLIGENT BALANCING METHODS (3D)
            
            calculateLetterFrequency() {
                console.log('üìä Calculating letter frequency for 3D target words...');
                
                const frequency = {};
                const allLetters = this.targetWords.join('').split('');
                
                // Count letter frequency
                allLetters.forEach(letter => {
                    frequency[letter] = (frequency[letter] || 0) + 1;
                });
                
                // Calculate percentages
                const totalLetters = allLetters.length;
                Object.keys(frequency).forEach(letter => {
                    frequency[letter] = {
                        count: frequency[letter],
                        percentage: (frequency[letter] / totalLetters) * 100,
                        priority: frequency[letter] / totalLetters
                    };
                });
                
                console.log('üìà 3D Letter frequency calculated:', frequency);
                return frequency;
            }
            
            applyBalancing() {
                console.log('‚öñÔ∏è Applying intelligent game balancing for 3D...');
                
                // 1. Adjust fall speed based on level and complexity
                this.adjustFallSpeed();
                
                // 2. Optimize grid size for current words
                this.optimizeGridSize();
                
                // 3. Generate balanced letter queue
                this.generateBalancedLetterQueue();
                
                // 4. Update target words based on level
                this.updateTargetWords();
                
                console.log('‚úÖ 3D Balancing applied:', {
                    fallSpeed: this.fallSpeed,
                    gridSize: this.currentGridSize,
                    targetWords: this.targetWords,
                    queueLength: this.letterQueue.length
                });
            }
            
            adjustFallSpeed() {
                const baseSpeed = this.balancingSystem.baseFallSpeed;
                const levelMultiplier = 1 + (this.level - 1) * this.balancingSystem.levelBalance.speedIncrease;
                const complexityMultiplier = this.calculateComplexityMultiplier();
                
                this.fallSpeed = Math.max(
                    this.balancingSystem.minFallSpeed,
                    Math.min(
                        this.balancingSystem.maxFallSpeed,
                        baseSpeed * levelMultiplier * complexityMultiplier
                    )
                );
                
                console.log('‚ö° 3D Fall speed adjusted:', {
                    level: this.level,
                    baseSpeed: baseSpeed,
                    levelMultiplier: levelMultiplier,
                    complexityMultiplier: complexityMultiplier,
                    finalSpeed: this.fallSpeed
                });
            }
            
            calculateComplexityMultiplier() {
                const avgWordLength = this.targetWords.reduce((sum, word) => sum + word.length, 0) / this.targetWords.length;
                const complexityScore = avgWordLength / 5; // Normalize to 5-letter words
                
                // More complex words = slower speed for better control
                return Math.max(0.8, Math.min(1.2, 1.1 - (complexityScore - 1) * 0.1));
            }
            
            optimizeGridSize() {
                const maxWordLength = Math.max(...this.targetWords.map(word => word.length));
                const avgWordLength = this.targetWords.reduce((sum, word) => sum + word.length, 0) / this.targetWords.length;
                
                // Calculate optimal grid size based on word lengths
                let optimalSize = Math.max(8, Math.min(12, Math.ceil(maxWordLength * 1.5)));
                
                // Adjust for number of words
                if (this.targetWords.length > 6) {
                    optimalSize = Math.min(optimalSize + 1, 12);
                }
                
                // Ensure grid size is in available options
                if (!this.gridSizes.includes(optimalSize)) {
                    optimalSize = this.gridSizes.reduce((prev, curr) => 
                        Math.abs(curr - optimalSize) < Math.abs(prev - optimalSize) ? curr : prev
                    );
                }
                
                this.currentGridSize = optimalSize;
                
                console.log('üìê 3D Grid size optimized:', {
                    maxWordLength: maxWordLength,
                    avgWordLength: avgWordLength,
                    wordCount: this.targetWords.length,
                    optimalSize: optimalSize
                });
            }
            
            generateBalancedLetterQueue() {
                console.log('üé≤ Generating balanced letter queue for 3D...');
                
                this.letterQueue = [];
                const frequency = this.balancingSystem.letterFrequency;
                const targetQueueSize = 15; // Optimal queue size
                
                // Create weighted letter pool
                const letterPool = [];
                Object.keys(frequency).forEach(letter => {
                    const weight = Math.ceil(frequency[letter].priority * 100);
                    for (let i = 0; i < weight; i++) {
                        letterPool.push(letter);
                    }
                });
                
                // Add some common letters for variety
                const commonLetters = ['A', 'E', 'I', 'O', 'U', 'R', 'S', 'T', 'N', 'L'];
                commonLetters.forEach(letter => {
                    if (!frequency[letter]) {
                        for (let i = 0; i < 5; i++) {
                            letterPool.push(letter);
                        }
                    }
                });
                
                // Generate balanced queue
                for (let i = 0; i < targetQueueSize; i++) {
                    const randomIndex = Math.floor(Math.random() * letterPool.length);
                    this.letterQueue.push(letterPool[randomIndex]);
                }
                
                console.log('üìã 3D Balanced letter queue generated:', {
                    queueLength: this.letterQueue.length,
                    uniqueLetters: [...new Set(this.letterQueue)].length,
                    nextLetters: this.letterQueue.slice(0, 5)
                });
            }
            
            updateTargetWords() {
                console.log('üìù Updating 3D target words for level', this.level);
                
                const difficulty = this.getDifficultyForLevel();
                const wordCount = Math.min(3 + Math.floor(this.level / 2), 8);
                
                // Select words based on difficulty and level
                let selectedWords = [];
                
                if (difficulty === 'easy') {
                    selectedWords = [...this.balancingSystem.wordDifficulty.easy];
                } else if (difficulty === 'medium') {
                    selectedWords = [
                        ...this.balancingSystem.wordDifficulty.easy,
                        ...this.balancingSystem.wordDifficulty.medium
                    ];
                } else {
                    selectedWords = [
                        ...this.balancingSystem.wordDifficulty.easy,
                        ...this.balancingSystem.wordDifficulty.medium,
                        ...this.balancingSystem.wordDifficulty.hard
                    ];
                }
                
                // Shuffle and select appropriate number
                selectedWords = this.shuffleArray(selectedWords).slice(0, wordCount);
                
                this.targetWords = selectedWords;
                
                console.log('üéØ 3D Target words updated:', {
                    level: this.level,
                    difficulty: difficulty,
                    wordCount: this.targetWords.length,
                    words: this.targetWords
                });
            }
            
            getDifficultyForLevel() {
                if (this.level <= 3) return 'easy';
                if (this.level <= 6) return 'medium';
                return 'hard';
            }
            
            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
            
            // Update balancing when level changes
            updateBalancingForLevel() {
                console.log('üîÑ Updating 3D balancing for level', this.level);
                
                this.applyBalancing();
                
                // Update display
                this.updateDisplay();
                
                // Show level up effect
                this.showLevelUpEffect();
            }
            
            // Helper method to ensure proper letter display
            ensureLetterDisplay(letter) {
                // Map common problematic characters
                const letterMap = {
                    'B': 'B',
                    '6': 'B', // Fix for B appearing as 6
                    '8': 'B',
                    '0': 'O',
                    'O': 'O',
                    '1': 'I',
                    'I': 'I',
                    '5': 'S',
                    'S': 'S',
                    'Z': 'Z',
                    '2': 'Z'
                };
                
                // Return mapped letter or original if no mapping
                return letterMap[letter] || letter;
            }
        }
        
        // 3D Word Detection System
        class WordDetector3D {
            constructor(dictionary) {
                this.dictionary = dictionary;
            }
            
            scanGrid(grid) {
                const words = [];
                
                // Scan horizontal
                for (let row = 0; row < grid.length; row++) {
                    const rowWords = this.findWordsInRow(grid[row]);
                    words.push(...rowWords);
                }
                
                // Scan vertical
                for (let col = 0; col < grid[0].length; col++) {
                    const colLetters = grid.map(row => row[col]);
                    const colWords = this.findWordsInRow(colLetters);
                    words.push(...colWords);
                }
                
                return words;
            }
            
            findWordsInRow(letters) {
                const words = [];
                const rowString = letters.map(letter => letter || ' ').join('');
                
                // Find all possible words of 3+ letters
                for (let start = 0; start < rowString.length; start++) {
                    for (let length = 3; length <= rowString.length - start; length++) {
                        const word = rowString.substr(start, length).replace(/\s/g, '');
                        if (word.length >= 3 && this.validateWord(word)) {
                            words.push(word);
                        }
                    }
                }
                
                return words;
            }
            
            validateWord(word) {
                return this.dictionary.has(word.toUpperCase());
            }
        }
        
        // 3D Scoring System
        class ScoreManager3D {
            constructor() {
                this.currentScore = 0;
                this.highScore = 0;
            }
            
            updateScore(score) {
                this.currentScore = score;
                if (score > this.highScore) {
                    this.highScore = score;
                }
            }
            
            getScore() {
                return this.currentScore;
            }
            
            getHighScore() {
                return this.highScore;
            }
        }
        
        // 3D Level System
        class LevelManager3D {
            constructor() {
                this.levels = [
                    { minWords: 0, maxWords: 5, speed: 1000 },
                    { minWords: 5, maxWords: 10, speed: 900 },
                    { minWords: 10, maxWords: 15, speed: 800 },
                    { minWords: 15, maxWords: 20, speed: 700 },
                    { minWords: 20, maxWords: 25, speed: 600 },
                    { minWords: 25, maxWords: 30, speed: 500 },
                    { minWords: 30, maxWords: 35, speed: 400 },
                    { minWords: 35, maxWords: 40, speed: 300 },
                    { minWords: 40, maxWords: 45, speed: 200 },
                    { minWords: 45, maxWords: 50, speed: 150 }
                ];
            }
            
            getCurrentLevel(wordsFound) {
                for (let i = this.levels.length - 1; i >= 0; i--) {
                    if (wordsFound >= this.levels[i].minWords) {
                        return i + 1;
                    }
                }
                return 1;
            }
            
            checkLevelProgression(wordsFound) {
                const newLevel = this.getCurrentLevel(wordsFound);
                return newLevel;
            }
        }
        
        // 3D Audio System
        class AudioManager3D {
            constructor() {
                this.sounds = {};
                this.muted = false;
            }
            
            playStart() {
                this.playSound('start');
            }
            
            playPause() {
                this.playSound('pause');
            }
            
            playResume() {
                this.playSound('resume');
            }
            
            playReset() {
                this.playSound('reset');
            }
            
            playMove() {
                this.playSound('move');
            }
            
            playRotate() {
                this.playSound('rotate');
            }
            
            playPlace() {
                this.playSound('place');
            }
            
            playWordComplete() {
                this.playSound('wordComplete');
            }
            
            playLevelUp() {
                this.playSound('levelUp');
            }
            
            playSound(type) {
                if (this.muted) return;
                
                // Create audio context if not exists
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Generate simple tones for different sounds
                const frequency = this.getFrequencyForSound(type);
                const duration = 0.1;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            getFrequencyForSound(type) {
                const frequencies = {
                    start: 440,
                    pause: 330,
                    resume: 440,
                    reset: 220,
                    move: 660,
                    rotate: 550,
                    place: 880,
                    wordComplete: 1100,
                    levelUp: 1320
                };
                return frequencies[type] || 440;
            }
        }
        
        // Enhanced 3D Particle System
        class ParticleSystem3D {
            constructor() {
                this.particles = [];
                this.scene = null;
            }
            
            setScene(scene) {
                this.scene = scene;
            }
            
            createPlacementEffect3D(x, y, z) {
                console.log('‚ú® Creating 3D placement effect at:', { x, y, z });
                
                for (let i = 0; i < 20; i++) {
                    const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0x667eea,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.set(x, y, z);
                    
                    // Random velocity
                    particle.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        Math.random() * 0.3,
                        (Math.random() - 0.5) * 0.2
                    );
                    
                    particle.userData.life = 1.0;
                    particle.userData.maxLife = 1.0;
                    
                    this.scene.add(particle);
                    this.particles.push(particle);
                }
            }
            
            createWordCompletionEffect3D(word, x, y, z) {
                console.log('üéâ Creating 3D word completion effect for:', word);
                
                // Create letter particles for each letter in the word
                for (let i = 0; i < word.length; i++) {
                    for (let j = 0; j < 10; j++) {
                        const geometry = new THREE.SphereGeometry(0.03, 6, 6);
                        const material = new THREE.MeshBasicMaterial({
                            color: 0x10b981,
                            transparent: true,
                            opacity: 0.9
                        });
                        
                        const particle = new THREE.Mesh(geometry, material);
                        particle.position.set(x + i * 0.5, y, z);
                        
                        // Explosive velocity
                        particle.userData.velocity = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.5,
                            Math.random() * 0.8,
                            (Math.random() - 0.5) * 0.5
                        );
                        
                        particle.userData.life = 1.5;
                        particle.userData.maxLife = 1.5;
                        particle.userData.letter = word[i];
                        
                        this.scene.add(particle);
                        this.particles.push(particle);
                    }
                }
                
                // Create celebration particles
                for (let i = 0; i < 30; i++) {
                    const geometry = new THREE.SphereGeometry(0.02, 4, 4);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xffd700,
                        transparent: true,
                        opacity: 1.0
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.set(x, y, z);
                    
                    // Spherical explosion
                    const angle = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const radius = 0.5 + Math.random() * 0.5;
                    
                    particle.userData.velocity = new THREE.Vector3(
                        Math.sin(phi) * Math.cos(angle) * radius,
                        Math.cos(phi) * radius,
                        Math.sin(phi) * Math.sin(angle) * radius
                    );
                    
                    particle.userData.life = 2.0;
                    particle.userData.maxLife = 2.0;
                    
                    this.scene.add(particle);
                    this.particles.push(particle);
                }
            }
            
            createLevelUpEffect3D() {
                console.log('üèÜ Creating 3D level up effect');
                
                // Create spiral effect
                for (let i = 0; i < 50; i++) {
                    const geometry = new THREE.SphereGeometry(0.04, 6, 6);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0x8b5cf6,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.set(0, 0, 0);
                    
                    // Spiral trajectory
                    const angle = (i / 50) * Math.PI * 4;
                    const radius = 2 + (i / 50) * 3;
                    const height = (i / 50) * 5;
                    
                    particle.userData.velocity = new THREE.Vector3(
                        Math.cos(angle) * radius * 0.1,
                        height * 0.1,
                        Math.sin(angle) * radius * 0.1
                    );
                    
                    particle.userData.life = 3.0;
                    particle.userData.maxLife = 3.0;
                    
                    this.scene.add(particle);
                    this.particles.push(particle);
                }
            }
            
            update() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    // Update position
                    particle.position.add(particle.userData.velocity);
                    
                    // Update life
                    particle.userData.life -= 0.016; // 60 FPS
                    
                    // Update opacity
                    particle.material.opacity = particle.userData.life / particle.userData.maxLife;
                    
                    // Update scale
                    particle.scale.setScalar(1 + (1 - particle.userData.life / particle.userData.maxLife) * 0.5);
                    
                    // Remove dead particles
                    if (particle.userData.life <= 0) {
                        this.scene.remove(particle);
                        this.particles.splice(i, 1);
                    }
                }
            }
        }

        // Global game instance
        let game3D;

        // Global functions for button controls
        function selectMode(mode) {
            if (game3D) game3D.selectMode(mode);
        }

        function selectGrid(size) {
            if (game3D) game3D.selectGrid(size);
        }

        function startGame() {
            if (game3D) game3D.startGame();
        }

        function resetGame() {
            if (game3D) game3D.resetGame();
        }

        function pauseGame() {
            if (game3D) game3D.pauseGame();
        }

        function clearGrid() {
            if (game3D) game3D.clearGrid();
        }

        // Initialize 3D game when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ DOM Content Loaded - Initializing 3D game...');
            
            // Check if Three.js is available
            if (typeof THREE === 'undefined') {
                console.error('‚ùå THREE.js not loaded!');
                // Show error message to user
                const container = document.getElementById('gameGrid');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: #ff6b6b;">
                            <h3>‚ùå Erreur de chargement</h3>
                            <p>Three.js n'a pas pu √™tre charg√©. Veuillez rafra√Æchir la page.</p>
                        </div>
                    `;
                }
                return;
            }
            
            console.log('‚úÖ THREE.js available, creating Game3D instance...');
            
            try {
                game3D = new Game3D();
                console.log('üéÆ 3D Game initialized successfully');
                
                // Check if Utils is available
                if (typeof Utils !== 'undefined') {
                    console.log('‚úÖ Utils available for sound and particle effects');
                } else {
                    console.warn('‚ö†Ô∏è Utils not available - sound and particle effects disabled');
                }
                
                // Update display after initialization
                setTimeout(() => {
                    if (game3D && typeof game3D.updateDisplay === 'function') {
                        game3D.updateDisplay();
                        console.log('üìä Display updated after initialization');
                    }
                }, 100);
                
            } catch (error) {
                console.error('‚ùå Error initializing 3D game:', error);
                const container = document.getElementById('gameGrid');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: #ff6b6b;">
                            <h3>‚ùå Erreur d'initialisation</h3>
                            <p>Le jeu 3D n'a pas pu √™tre initialis√©: ${error.message}</p>
                            <button onclick="location.reload()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                Rafra√Æchir la page
                            </button>
                        </div>
                    `;
                }
            }
        });

        // Fullscreen function
        function toggleFullScreen() {
            console.log('üñ•Ô∏è toggleFullScreen() called');
            
            const gameContainer = document.querySelector('.game-container');
            const fullscreenBtn = document.querySelector('button[onclick="game3D.toggleFullScreen()"]');
            
            console.log('üì¶ Game container found:', gameContainer);
            console.log('üîò Fullscreen button found:', fullscreenBtn);
            
            if (gameContainer.classList.contains('fullscreen')) {
                console.log('üì§ Exiting fullscreen mode');
                exitFullScreen();
            } else {
                console.log('üì• Entering fullscreen mode');
                enterFullScreen();
            }
        }

        function enterFullScreen() {
            console.log('üì• enterFullScreen() called');
            
            const gameContainer = document.querySelector('.game-container');
            const fullscreenBtn = document.querySelector('button[onclick="game3D.toggleFullScreen()"]');
            
            gameContainer.classList.add('fullscreen');
            fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i> Sortir';
            
            // Add exit button
            const exitBtn = document.createElement('div');
            exitBtn.className = 'fullscreen-exit';
            exitBtn.innerHTML = '<i class="fas fa-times"></i>';
            exitBtn.onclick = exitFullScreen;
            gameContainer.appendChild(exitBtn);
            
            // Resize 3D canvas for full screen
            const canvas = document.getElementById('threejsCanvas');
            console.log('üé® Canvas found for fullscreen:', canvas);
            
            if (canvas && game3D && game3D.renderer) {
                // Calculate optimal canvas size for full screen
                const container = gameContainer.querySelector('.game-grid-container');
                const containerRect = container.getBoundingClientRect();
                const maxWidth = Math.min(containerRect.width * 0.9, window.innerWidth * 0.8);
                const maxHeight = Math.min(containerRect.height * 0.9, window.innerHeight * 0.7);
                const canvasSize = Math.min(maxWidth, maxHeight);
                
                console.log('üìê Fullscreen dimensions:', {
                    containerWidth: containerRect.width,
                    containerHeight: containerRect.height,
                    maxWidth: maxWidth,
                    maxHeight: maxHeight,
                    canvasSize: canvasSize
                });
                
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                game3D.renderer.setSize(canvasSize, canvasSize);
                
                // Update camera aspect ratio
                if (game3D.camera) {
                    game3D.camera.aspect = canvasSize / canvasSize;
                    game3D.camera.updateProjectionMatrix();
                    console.log('üì∑ Camera aspect ratio updated for fullscreen');
                }
                
                // Enhance 3D scene for full screen
                if (game3D.scene) {
                    // Adjust camera position for better view
                    game3D.camera.position.set(0, 0, 18);
                    game3D.camera.lookAt(0, 0, 0);
                    
                    // Enhance lighting for full screen
                    game3D.scene.children.forEach(child => {
                        if (child.type === 'DirectionalLight') {
                            child.intensity = 1.5;
                        } else if (child.type === 'PointLight') {
                            child.intensity = 1.2;
                        }
                    });
                    
                    console.log('üé¨ 3D scene enhanced for fullscreen');
                }
            } else {
                console.warn('‚ö†Ô∏è Canvas or renderer not available for fullscreen resize');
            }
            
            // Add keyboard shortcuts for full screen
            document.addEventListener('keydown', handleFullScreenKeyboard);
            
            console.log('‚úÖ Entered full screen mode');
        }

        function exitFullScreen() {
            console.log('üì§ exitFullScreen() called');
            
            const gameContainer = document.querySelector('.game-container');
            const fullscreenBtn = document.querySelector('button[onclick="game3D.toggleFullScreen()"]');
            
            gameContainer.classList.remove('fullscreen');
            fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> Plein √âcran';
            
            // Remove exit button
            const exitBtn = gameContainer.querySelector('.fullscreen-exit');
            if (exitBtn) {
                exitBtn.remove();
                console.log('‚ùå Exit button removed');
            }
            
            // Reset 3D canvas size
            const canvas = document.getElementById('threejsCanvas');
            console.log('üé® Canvas found for exit fullscreen:', canvas);
            
            if (canvas && game3D && game3D.renderer) {
                canvas.width = 500;
                canvas.height = 500;
                game3D.renderer.setSize(500, 500);
                
                // Update camera aspect ratio
                if (game3D.camera) {
                    game3D.camera.aspect = 1;
                    game3D.camera.updateProjectionMatrix();
                    console.log('üì∑ Camera aspect ratio reset');
                }
                
                // Reset 3D scene to normal mode
                if (game3D.scene) {
                    // Reset camera position
                    game3D.camera.position.set(0, 0, 15);
                    game3D.camera.lookAt(0, 0, 0);
                    
                    // Reset lighting
                    game3D.scene.children.forEach(child => {
                        if (child.type === 'DirectionalLight') {
                            child.intensity = 1.2;
                        } else if (child.type === 'PointLight') {
                            child.intensity = 1;
                        }
                    });
                    
                    console.log('üé¨ 3D scene reset to normal mode');
                }
            } else {
                console.warn('‚ö†Ô∏è Canvas or renderer not available for fullscreen exit resize');
            }
            
            // Remove keyboard shortcuts
            document.removeEventListener('keydown', handleFullScreenKeyboard);
            
            console.log('‚úÖ Exited full screen mode');
        }

        function handleFullScreenKeyboard(event) {
            switch(event.key) {
                case 'Escape':
                    console.log('‚å®Ô∏è Escape key pressed - exiting fullscreen');
                    event.preventDefault();
                    exitFullScreen();
                    break;
                case 'F11':
                    console.log('‚å®Ô∏è F11 key pressed - exiting fullscreen');
                    event.preventDefault();
                    exitFullScreen();
                    break;
                case ' ':
                    console.log('‚å®Ô∏è Space key pressed - toggling game pause');
                    event.preventDefault();
                    if (game3D) {
                        if (game3D.gameRunning && !game3D.paused) {
                            game3D.pauseGame();
                        } else if (game3D.gameRunning && game3D.paused) {
                            game3D.startGame();
                        }
                    }
                    break;
                case 'r':
                case 'R':
                    console.log('‚å®Ô∏è R key pressed - resetting game');
                    event.preventDefault();
                    if (game3D) {
                        game3D.resetGame();
                    }
                    break;
                case 's':
                case 'S':
                    console.log('‚å®Ô∏è S key pressed - starting game');
                    event.preventDefault();
                    if (game3D && !game3D.gameRunning) {
                        game3D.startGame();
                    }
                    break;
            }
        }

        // Keyboard shortcut for full screen (F11)
        document.addEventListener('keydown', function(event) {
            if (event.key === 'F11') {
                console.log('‚å®Ô∏è F11 key pressed - toggling fullscreen');
                event.preventDefault();
                toggleFullScreen();
            }
        });
    </script>
</body>
</html>