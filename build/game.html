<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maquette 3D - Letters Cascade Challenge</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎮</text></svg>">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/shared.css">
    <script src="js/utils.js"></script>
    <style>
        /* ENHANCED LAYOUT - BEAUTIFUL AND ORGANIZED */
        .page-layout {
            display: grid;
            grid-template-columns: 180px 1fr;
            gap: var(--spacing-md);
            height: 100vh;
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--spacing-md);
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .main-content {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            height: 100vh;
            overflow: hidden;
        }

        /* ENHANCED GAME HEADER */
        .game-header {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.9));
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-align: center;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .game-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .game-header h1 {
            color: var(--primary-color);
            font-size: 1.5rem;
            font-weight: 800;
            margin: 0;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
            z-index: 1;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .game-header p {
            display: none;
        }

        /* ENHANCED GAME CONTAINER */
        .game-container {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.9));
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--spacing-lg);
            height: calc(100vh - 120px);
            position: relative;
            overflow: hidden;
            flex: 1;
        }

        /* ENHANCED GAME STATS - BEAUTIFUL CARDS */
        .game-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--spacing-md);
            padding: var(--spacing-md);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.08), rgba(118, 75, 162, 0.08));
            border-radius: var(--radius-lg);
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: absolute;
            top: var(--spacing-md);
            left: var(--spacing-md);
            right: var(--spacing-md);
            z-index: 10;
            backdrop-filter: blur(15px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.8));
            border-radius: var(--radius-md);
            padding: var(--spacing-sm);
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s ease;
        }

        .stat-card:hover::before {
            left: 100%;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 800;
            color: var(--primary-color);
            margin-bottom: var(--spacing-xs);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .stat-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--gray-600);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* ENHANCED 3D CANVAS */
        #gameCanvas {
            border-radius: var(--radius-lg);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 2px solid rgba(255, 255, 255, 0.5);
            margin: auto;
            display: block;
            max-width: 100%;
            max-height: 100%;
        }

        /* ENHANCED GAME CONTROLS */
        .game-controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--spacing-md);
            padding: var(--spacing-md);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.8));
            border-radius: var(--radius-lg);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(15px);
        }

        .game-controls button {
            padding: var(--spacing-md);
            border: none;
            border-radius: var(--radius-md);
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .game-controls button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .game-controls button:hover::before {
            left: 100%;
        }

        .game-controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d, #495057);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107, #ff8f00);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
        }

        /* ENHANCED SIDEBAR */
        .nav-sidebar {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.9));
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            height: fit-content;
            position: sticky;
            top: var(--spacing-md);
        }

        .nav-sidebar h3 {
            color: var(--primary-color);
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: var(--spacing-md);
            text-align: center;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .nav-links {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .nav-links a {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm) var(--spacing-md);
            color: var(--gray-600);
            text-decoration: none;
            border-radius: var(--radius-md);
            transition: all 0.3s ease;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .nav-links a::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .nav-links a:hover::before {
            left: 100%;
        }

        .nav-links a:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            color: var(--primary-color);
            transform: translateX(4px);
        }

        .nav-links a.active {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        /* RESPONSIVE DESIGN */
        @media (max-width: 1200px) {
            .page-layout {
                grid-template-columns: 160px 1fr;
                gap: var(--spacing-sm);
                padding: var(--spacing-sm);
            }
        }

        @media (max-width: 768px) {
            .page-layout {
                grid-template-columns: 1fr;
                gap: var(--spacing-sm);
            }
            
            .nav-sidebar {
                order: 2;
                position: static;
            }
            
            .game-stats {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .game-controls {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="page-layout">
            <!-- Navigation Sidebar -->
            <nav class="nav-sidebar">
                <h3>Navigation</h3>
                <div class="nav-links">
                    <a href="index.html"><i class="fas fa-home"></i> Accueil</a>
                    <a href="prototype.html"><i class="fas fa-flask"></i> Maquette 2D</a>
                    <a href="game.html" class="active"><i class="fas fa-gamepad"></i> Maquette 3D</a>
                    <a href="GDD.html"><i class="fas fa-file-alt"></i> Documentation</a>
                    <a href="rules.html"><i class="fas fa-list"></i> Règles</a>
                    <a href="moodboard.html"><i class="fas fa-palette"></i> Moodboard</a>
                    <a href="sitemap.html"><i class="fas fa-sitemap"></i> Plan de Site</a>
                </div>
            </nav>

            <!-- Main Content -->
            <div class="main-content">
                <!-- Game Header -->
                <div class="game-header">
                    <h1><i class="fas fa-gamepad"></i> Maquette 3D - Letters Cascade Challenge</h1>
                </div>

                <!-- Game Container -->
                <div class="game-container">
                    <!-- Game Stats Overlay -->
                    <div class="game-stats">
                        <div class="stat-card">
                            <div class="stat-value" id="scoreDisplay">0</div>
                            <div class="stat-label">Score</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="levelDisplay">1</div>
                            <div class="stat-label">Niveau</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="wordsCompleted">0</div>
                            <div class="stat-label">Mots Complétés</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="comboDisplay">0</div>
                            <div class="stat-label">Combo</div>
                        </div>
                    </div>

                    <!-- Game Canvas -->
                    <canvas id="gameCanvas" width="800" height="600"></canvas>

                    <!-- Game Controls -->
                    <div class="game-controls">
                        <button class="btn btn-primary" onclick="game3D.startGame()">
                            <i class="fas fa-play"></i> Démarrer
                        </button>
                        <button class="btn btn-secondary" onclick="game3D.resetGame()">
                            <i class="fas fa-redo"></i> Reset
                        </button>
                        <button class="btn btn-warning" onclick="game3D.pauseGame()">
                            <i class="fas fa-pause"></i> Pause
                        </button>
                        <button class="btn btn-success" onclick="window.open('game-fullscreen.html', '_blank')">
                            <i class="fas fa-expand"></i> Version Immersive
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script>
        // Complete 3D Game Engine for Letters Cascade Challenge
        // Implements all functionalities from technical specifications
        class Game3D {
            constructor() {
                console.log('🔧 Game3D constructor called');
                
                // Game Configuration
                this.mode = '3d';
                this.gridSizes = [8, 10, 12];
                this.currentGridSize = 10;
                this.cellSize = 1.2;
                this.gap = 0.2;
                
                // Game State
                this.gameRunning = false;
                this.paused = false;
                this.gameOver = false;
                this.gameOverReason = '';
                this.level = 1;
                this.score = 0;
                this.highScore = this.loadHighScore();
                this.combo = 0;
                this.maxCombo = 0;
                this.startTime = null;
                
                // Game Over State
                this.gameOverScreen = {
                    visible: false,
                    fadeIn: 0,
                    showStats: false,
                    finalStats: {
                        totalScore: 0,
                        wordsCompleted: 0,
                        lettersPlaced: 0,
                        playTime: 0,
                        levelReached: 1,
                        maxCombo: 1
                    }
                };
                
                // Game Over Conditions
                this.gameOverConditions = {
                    gridFull: false,
                    timeLimit: false,
                    noValidMoves: false,
                    scoreThreshold: false
                };
                
                // Game Limits
                this.gameLimits = {
                    maxGridFill: 0.85, // 85% grid fill triggers game over
                    timeLimit: 300000, // 5 minutes in milliseconds
                    minScoreForLevel: 100,
                    maxLevel: 10
                };
                
                // 3D Scene Components
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.raycaster = null;
                this.mouse = null;
                
                // Game Mechanics
                this.grid = [];
                this.letters = [];
                this.letterQueue = [];
                this.wordsFound = [];
                this.targetWords = ['CHAT', 'MAISON', 'MUSIQUE', 'JARDIN', 'LIVRE', 'TABLE', 'FENÊTRE', 'PORTE'];
                this.fallingLetter = null;
                this.fallingLetterPosition = { row: 0, col: 0 };
                this.fallSpeed = 1000;
                this.fallTimer = null;
                
                // 🎯 INTELLIGENT BALANCING SYSTEM (3D)
                this.balancingSystem = {
                    // Letter Distribution based on target words
                    letterFrequency: this.calculateLetterFrequency(),
                    
                    // Dynamic speed adjustment
                    baseFallSpeed: 1000,
                    minFallSpeed: 600,
                    maxFallSpeed: 2000,
                    speedMultiplier: 1.0,
                    
                    // Grid size optimization
                    optimalGridSize: 10,
                    gridSizeAdjustment: 0,
                    
                    // Word difficulty scaling
                    wordDifficulty: {
                        easy: ['CHAT', 'LIVRE', 'TABLE'],
                        medium: ['MAISON', 'JARDIN', 'PORTE'],
                        hard: ['MUSIQUE', 'FENÊTRE']
                    },
                    
                    // Level progression balance
                    levelBalance: {
                        lettersPerLevel: 3,
                        speedIncrease: 0.1,
                        complexityIncrease: 0.15
                    }
                };
                
                // 3D Specific
                this.cubes = [];
                this.textMeshes = [];
                this.lights = [];
                this.particles = [];
                
                // Word Detection System
                this.dictionary = this.loadDictionary();
                this.wordDetector = new WordDetector3D(this.dictionary);
                
                // Scoring System
                this.scoreManager = new ScoreManager3D();
                
                // Level System
                this.levelManager = new LevelManager3D();
                
                // Audio System
                this.audioManager = new AudioManager3D();
                
                // Particle System
                this.particleSystem = new ParticleSystem3D();
                
                // Statistics
                this.stats = {
                    lettersPlaced: 0,
                    wordsCompleted: 0,
                    totalScore: 0,
                    playTime: 0,
                    startTime: null,
                    mode: '3D'
                };
                
                // Apply initial balancing
                this.applyBalancing();
                
                console.log('🔧 Game3D constructor completed, calling init()');
                this.init();
            }
            
            // Initialize 3D game
            init() {
                console.log('🚀 Initializing 3D game...');
                
                // Check WebGL support
                if (!this.checkWebGLSupport()) {
                    console.error('❌ WebGL not supported');
                    this.showWebGLError();
                    return;
                }
                
                // Initialize Three.js components
                this.initThreeJS();
                this.create3DGrid();
                this.setupEnhancedLighting();
                this.setupCamera();
                this.setupControls();
                this.generateLetterQueue();
                
                // Start animation loop
                this.animate();
                
                console.log('✅ 3D game initialized successfully');
            }
            
            // Enhanced Three.js Initialization
            initThreeJS() {
                console.log('🎨 Initializing Three.js components...');
                
                // Create scene with enhanced background
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a0a);
                
                // Add atmospheric fog
                this.scene.fog = new THREE.Fog(0x0a0a0a, 10, 50);
                
                // Create enhanced camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 15, 20);
                this.camera.lookAt(0, 0, 0);
                
                // Create enhanced renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
                
                // Add renderer to DOM
                const container = document.getElementById('gameGrid');
                if (container) {
                    container.appendChild(this.renderer.domElement);
                }
                
                // Setup raycaster for mouse interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                console.log('✅ Three.js components initialized');
            }
            
            // Enhanced Lighting Setup
            setupEnhancedLighting() {
                console.log('💡 Setting up enhanced lighting...');
                
                // Ambient light for overall illumination
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // Main directional light with shadows
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -10;
                directionalLight.shadow.camera.right = 10;
                directionalLight.shadow.camera.top = 10;
                directionalLight.shadow.camera.bottom = -10;
                this.scene.add(directionalLight);
                
                // Point light for dramatic effect
                const pointLight = new THREE.PointLight(0x667eea, 0.8, 30);
                pointLight.position.set(0, 15, 0);
                this.scene.add(pointLight);
                
                // Spot light for focused illumination
                const spotLight = new THREE.SpotLight(0xffffff, 0.5, 30, Math.PI / 4, 0.5);
                spotLight.position.set(0, 20, 0);
                spotLight.target.position.set(0, 0, 0);
                this.scene.add(spotLight);
                this.scene.add(spotLight.target);
                
                console.log('✅ Enhanced lighting setup completed');
            }
            
            // WebGL Support Check
            checkWebGLSupport() {
                try {
                    const canvas = document.createElement('canvas');
                    return !!(window.WebGLRenderingContext && 
                        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
                } catch (e) {
                    return false;
                }
            }
            
            showWebGLError() {
                const container = document.getElementById('gameGrid');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: #ef4444;">
                            <h3>❌ WebGL Not Supported</h3>
                            <p>Your browser doesn't support WebGL. Please try a different browser or enable hardware acceleration.</p>
                            <button onclick="location.reload()" class="btn btn-primary">Reload Page</button>
                        </div>
                    `;
                }
            }
            
            // Setup Camera
            setupCamera() {
                this.camera.position.set(0, 0, 15);
                this.camera.lookAt(0, 0, 0);
            }
            
            // Setup Controls
            setupControls() {
                // Keyboard controls
                document.addEventListener('keydown', (event) => {
                    if (!this.gameRunning || this.paused) return;
                    
                    switch(event.key) {
                        case 'ArrowLeft':
                            this.moveFallingLetter(-1);
                            break;
                        case 'ArrowRight':
                            this.moveFallingLetter(1);
                            break;
                        case 'ArrowDown':
                            this.dropFallingLetter();
                            break;
                        case ' ':
                            this.rotateFallingLetter();
                            break;
                        case 'p':
                        case 'P':
                            this.togglePause();
                            break;
                        case 'r':
                        case 'R':
                            this.resetGame();
                            break;
                    }
                });
            }
            
            // Event Listeners
            setupEventListeners() {
                const canvas = this.renderer.domElement;
                
                // Mouse move for hover effects
                canvas.addEventListener('mousemove', (event) => {
                    this.onMouseMove(event);
                });
                
                // Mouse click for letter placement
                canvas.addEventListener('click', (event) => {
                    this.onCanvasClick(event);
                });
            }
            
            // Mouse Interaction
            onMouseMove(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children);
                
                // Reset all cube colors
                for (let row = 0; row < this.currentGridSize; row++) {
                    for (let col = 0; col < this.currentGridSize; col++) {
                        const cell = this.grid[row][col];
                        if (cell && !cell.userData.occupied) {
                            cell.material.color.setHex(0x2a2a3e);
                            cell.scale.set(1, 1, 1);
                        }
                    }
                }
                
                // Highlight hovered cube
                if (intersects.length > 0) {
                    const intersected = intersects[0].object;
                    if (intersected.userData && !intersected.userData.occupied) {
                        intersected.material.color.setHex(0x4ecdc4);
                        intersected.scale.set(1.1, 1.1, 1.1);
                    }
                }
            }
            
            // Canvas Click
            onCanvasClick(event) {
                if (!this.gameRunning || this.paused || !this.fallingLetter) return;
                
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children);
                
                if (intersects.length > 0) {
                    const intersected = intersects[0].object;
                    if (intersected.userData && !intersected.userData.occupied) {
                        this.placeLetter3D(intersected.userData.row, intersected.userData.col, event);
                    }
                }
            }
            
            // Place Letter in 3D
            placeLetter3D(row, col, event) {
                console.log('🎯 placeLetter3D() called - row:', row, 'col:', col, 'letters remaining:', this.letters.length);
                
                if (this.letterQueue.length === 0) {
                    this.generateLetterQueue();
                }
                
                const letter = this.letterQueue.shift();
                const cell = this.grid[row][col];
                
                if (!cell || cell.userData.occupied) {
                    console.warn('⚠️ Cell already occupied or invalid');
                    return;
                }
                
                // Create 3D text
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const context = canvas.getContext('2d');
                
                // Create gradient background
                const gradient = context.createLinearGradient(0, 0, 128, 128);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 128, 128);
                
                // Add text shadow
                context.shadowColor = 'rgba(0, 0, 0, 0.5)';
                context.shadowBlur = 4;
                context.shadowOffsetX = 2;
                context.shadowOffsetY = 2;
                
                // Draw letter
                context.fillStyle = 'white';
                context.font = 'bold 72px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(letter, 64, 64);
                
                // Create texture
                const texture = new THREE.CanvasTexture(canvas);
                const textGeometry = new THREE.PlaneGeometry(0.8, 0.8);
                const textMaterial = new THREE.MeshBasicMaterial({ 
                    map: texture,
                    transparent: true,
                    alphaTest: 0.5
                });
                
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.copy(cell.position);
                textMesh.position.y += 0.6;
                textMesh.rotation.x = -Math.PI / 2;
                
                // Add glow effect
                const glowGeometry = new THREE.PlaneGeometry(1, 1);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x4ecdc4,
                    transparent: true,
                    opacity: 0.3
                });
                
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.position.copy(textMesh.position);
                glowMesh.position.y += 0.01;
                glowMesh.rotation.x = -Math.PI / 2;
                
                // Add to scene
                this.scene.add(textMesh);
                this.scene.add(glowMesh);
                
                // Update cell data
                cell.userData.letter = textMesh;
                cell.userData.glow = glowMesh;
                cell.userData.occupied = true;
                cell.userData.letterValue = letter;
                
                // Change cube color
                cell.material.color.setHex(0x4ecdc4);
                
                // Add scale animation
                this.addPulseAnimation(textMesh);
                this.addPulseAnimation(glowMesh);
                
                // Update game state
                this.stats.lettersPlaced++;
                this.audioManager.playPlace();
                this.particleSystem.createPlacementEffect3D(cell.position);
                
                // Check for word completion
                this.checkWordCompletion();
                
                // Update display
                this.updateDisplay();
                
                console.log('✅ Letter placed successfully in 3D scene');
            }
            
            // Add Pulse Animation
            addPulseAnimation(mesh) {
                const scale = { value: 1 };
                const tween = new TWEEN.Tween(scale)
                    .to({ value: 1.2 }, 200)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .onUpdate(() => {
                        mesh.scale.set(scale.value, scale.value, scale.value);
                    })
                    .yoyo(true)
                    .repeat(1)
                    .start();
            }
            
            // Generate Letter Queue
            generateLetterQueue() {
                console.log('📝 Generating 3D letter queue...');
                this.letterQueue = [];
                const vowels = ['A', 'E', 'I', 'O', 'U'];
                const consonants = ['B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z'];
                
                // Balanced letter distribution
                for (let i = 0; i < 10; i++) {
                    if (Math.random() < 0.4) {
                        this.letterQueue.push(vowels[Math.floor(Math.random() * vowels.length)]);
                    } else {
                        this.letterQueue.push(consonants[Math.floor(Math.random() * consonants.length)]);
                    }
                }
                
                console.log('✅ 3D letter queue generated:', this.letterQueue);
                this.updateLetterQueueDisplay();
            }
            
            // Word Detection for 3D
            checkWordCompletion() {
                if (this.mode === '3d') {
                    console.log('🎮 Checking 3D word completion');
                    this.checkWordCompletion3D();
                }
            }
            
            checkWordCompletion3D() {
                console.log('🎮 checkWordCompletion3D() called');
                
                // Create 2D grid from 3D grid data
                const grid = [];
                for (let row = 0; row < this.currentGridSize; row++) {
                    grid[row] = [];
                    for (let col = 0; col < this.currentGridSize; col++) {
                        // Extract letter from 3D mesh (simplified)
                        grid[row][col] = this.getLetterFrom3DMesh(this.grid[row][col].userData.letter) || '';
                    }
                }
                
                console.log('📐 3D grid created:', grid);
                
                // Use word detector
                const words = this.wordDetector.scanGrid(grid);
                console.log('📝 Words found in 3D:', words);
                
                if (words.length > 0) {
                    words.forEach(word => {
                        this.completeWord3D(word);
                    });
                    
                    // Update combo
                    this.combo += words.length;
                    if (this.combo > this.maxCombo) {
                        this.maxCombo = this.combo;
                    }
                    
                    // Add combo bonus
                    if (this.combo > 1) {
                        const comboBonus = this.combo * 50;
                        this.addScore(comboBonus);
                        this.showComboEffect3D(comboBonus);
                    }
                } else {
                    this.combo = 0;
                }
                
                this.updateDisplay();
            }
            
            getLetterFrom3DMesh(mesh) {
                console.log('🔍 getLetterFrom3DMesh() called for mesh:', mesh);
                if (!mesh || !mesh.userData) return null;
                return mesh.userData.letterValue;
            }
            
            completeWord3D(word) {
                console.log('🏆 Word completed in 3D:', word);
                
                // Add word to found list
                this.wordsFound.push(word);
                
                // Calculate score
                const wordScore = word.length * 10;
                this.addScore(wordScore);
                
                // Remove word from 3D grid
                this.removeWordFrom3DGrid(word);
                
                // Create 3D particle effect
                this.particleSystem.createWordCompletionEffect3D(word);
                
                // Play sound
                this.audioManager.playWordComplete();
                
                // Check level progression
                this.levelManager.checkLevelProgression(this.wordsFound.length);
                
                console.log('✅ 3D word completed:', word, 'Score:', wordScore);
            }
            
            removeWordFrom3DGrid(word) {
                // Find and remove letters of the word from 3D grid
                for (let row = 0; row < this.currentGridSize; row++) {
                    for (let col = 0; col < this.currentGridSize; col++) {
                        const cell = this.grid[row][col];
                        if (cell.userData.letterValue === word[0]) {
                            // Check if this is the start of the word
                            if (this.checkWordAt3DPosition(row, col, word)) {
                                this.removeWordAt3DPosition(row, col, word);
                                return;
                            }
                        }
                    }
                }
            }
            
            checkWordAt3DPosition(row, col, word) {
                // Check horizontal
                if (col + word.length <= this.currentGridSize) {
                    let match = true;
                    for (let i = 0; i < word.length; i++) {
                        if (this.grid[row][col + i].userData.letterValue !== word[i]) {
                            match = false;
                            break;
                        }
                    }
                    if (match) return true;
                }
                
                // Check vertical
                if (row + word.length <= this.currentGridSize) {
                    let match = true;
                    for (let i = 0; i < word.length; i++) {
                        if (this.grid[row + i][col].userData.letterValue !== word[i]) {
                            match = false;
                            break;
                        }
                    }
                    if (match) return true;
                }
                
                return false;
            }
            
            removeWordAt3DPosition(row, col, word) {
                // Remove letters from 3D grid
                for (let i = 0; i < word.length; i++) {
                    const cell = this.grid[row][col + i];
                    if (cell.userData.letter) {
                        this.scene.remove(cell.userData.letter);
                    }
                    if (cell.userData.glow) {
                        this.scene.remove(cell.userData.glow);
                    }
                    cell.userData.letter = null;
                    cell.userData.glow = null;
                    cell.userData.occupied = false;
                    cell.userData.letterValue = null;
                    cell.material.color.setHex(0x2a2a3e);
                }
            }
            
            // Scoring System
            addScore(points) {
                console.log('💰 Adding 3D score:', points);
                this.score += points;
                this.stats.totalScore += points;
                
                // Update high score
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    this.saveHighScore();
                }
                
                this.scoreManager.updateScore(this.score);
                this.updateDisplay();
            }
            
            // Game Controls
            startGame() {
                console.log('▶️ Starting 3D game...');
                
                if (this.gameRunning) return;
                
                this.gameRunning = true;
                this.paused = false;
                this.gameOver = false;
                this.stats.startTime = Date.now();
                this.startTime = Date.now();
                
                this.audioManager.playStart();
                console.log('✅ 3D game started');
            }
            
            pauseGame() {
                console.log('⏸️ Pausing 3D game...');
                
                if (!this.gameRunning) return;
                
                this.paused = !this.paused;
                
                if (this.paused) {
                    this.audioManager.playPause();
                } else {
                    this.audioManager.playResume();
                }
                
                this.updateDisplay();
                console.log('✅ 3D game paused:', this.paused);
            }
            
            resetGame() {
                console.log('🔄 Resetting 3D game...');
                
                this.gameRunning = false;
                this.paused = false;
                this.gameOver = false;
                this.score = 0;
                this.level = 1;
                this.combo = 0;
                this.maxCombo = 0;
                this.wordsFound = [];
                this.letters = [];
                this.letterQueue = [];
                this.fallingLetter = null;
                
                this.clear3DGrid();
                this.generateLetterQueue();
                this.updateDisplay();
                
                this.audioManager.playReset();
                console.log('✅ 3D game reset');
            }
            
            // Add missing falling letter control methods
            moveFallingLetter(direction) {
                console.log('⬅️➡️ moveFallingLetter() called - direction:', direction);
                
                if (!this.gameRunning || this.paused || !this.fallingLetter) {
                    console.log('❌ Cannot move falling letter - game not running, paused, or no falling letter');
                    return;
                }
                
                // Calculate new position
                const newCol = this.fallingLetterPosition.col + direction;
                
                // Check bounds
                if (newCol < 0 || newCol >= this.currentGridSize) {
                    console.log('❌ Cannot move - out of bounds');
                    return;
                }
                
                // Check if target position is occupied
                if (this.grid[this.fallingLetterPosition.row][newCol].userData.occupied) {
                    console.log('❌ Cannot move - target position occupied');
                    return;
                }
                
                // Update position
                this.fallingLetterPosition.col = newCol;
                
                // Update 3D position
                this.fallingLetter.position.x = (newCol - this.currentGridSize / 2 + 0.5) * this.cellSize;
                
                console.log('✅ Falling letter moved to column:', newCol);
            }
            
            dropFallingLetter() {
                console.log('⬇️ dropFallingLetter() called');
                
                if (!this.gameRunning || this.paused || !this.fallingLetter) {
                    console.log('❌ Cannot drop falling letter - game not running, paused, or no falling letter');
                    return;
                }
                
                // Find the lowest available position
                let targetRow = this.fallingLetterPosition.row;
                
                for (let row = this.fallingLetterPosition.row + 1; row < this.currentGridSize; row++) {
                    if (this.grid[row][this.fallingLetterPosition.col].userData.occupied) {
                        break;
                    }
                    targetRow = row;
                }
                
                // Place the letter at the target position
                this.placeLetter3D(targetRow, this.fallingLetterPosition.col);
                
                console.log('✅ Falling letter dropped at row:', targetRow);
            }
            
            rotateFallingLetter() {
                console.log('🔄 rotateFallingLetter() called');
                
                if (!this.gameRunning || this.paused || !this.fallingLetter) {
                    console.log('❌ Cannot rotate falling letter - game not running, paused, or no falling letter');
                    return;
                }
                
                // Rotate the letter 90 degrees around Y axis
                this.fallingLetter.rotation.y += Math.PI / 2;
                
                console.log('✅ Falling letter rotated');
            }
            
            togglePause() {
                console.log('⏸️ togglePause() called');
                this.pauseGame();
            }
            
            clear3DGrid() {
                console.log('🎮 Clearing 3D grid');
                
                for (let row = 0; row < this.currentGridSize; row++) {
                    for (let col = 0; col < this.currentGridSize; col++) {
                        const cell = this.grid[row][col];
                        if (cell.userData.letter) {
                            this.scene.remove(cell.userData.letter);
                        }
                        if (cell.userData.glow) {
                            this.scene.remove(cell.userData.glow);
                        }
                        cell.userData.letter = null;
                        cell.userData.glow = null;
                        cell.userData.occupied = false;
                        cell.userData.letterValue = null;
                        cell.material.color.setHex(0x2a2a3e);
                        cell.material.opacity = 1;
                    }
                }
            }
            
            // Display Updates
            updateDisplay() {
                console.log('📊 updateDisplay() called - score:', this.score, 'level:', this.level, 'mode:', this.mode);
                
                const scoreElement = document.getElementById('scoreDisplay');
                const levelElement = document.getElementById('levelDisplay');
                const timeElement = document.getElementById('timeDisplay');
                const wordsElement = document.getElementById('wordsCompleted');
                const modeElement = document.getElementById('currentMode');
                const gridElement = document.getElementById('currentGrid');
                
                console.log('📦 Display elements found:', {
                    score: scoreElement,
                    level: levelElement,
                    time: timeElement,
                    words: wordsElement,
                    mode: modeElement,
                    grid: gridElement
                });
                
                if (scoreElement) scoreElement.textContent = this.score;
                if (levelElement) levelElement.textContent = this.level;
                
                // Update mode display
                if (modeElement) {
                    const modeText = this.mode === '3d' ? '3D' : '2D';
                    modeElement.textContent = modeText;
                    console.log('🎮 Mode display updated to:', modeText);
                }
                
                // Update grid size display
                if (gridElement) {
                    gridElement.textContent = `${this.currentGridSize}×${this.currentGridSize}`;
                    console.log('📐 Grid display updated to:', `${this.currentGridSize}×${this.currentGridSize}`);
                }
                
                // Update time if game is running
                if (this.gameRunning && this.startTime) {
                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    if (timeElement) timeElement.textContent = `${Math.floor(elapsed / 60)}:${(elapsed % 60).toString().padStart(2, '0')}`;
                }
                
                if (wordsElement) wordsElement.textContent = this.wordsFound.length;
                
                // Update mode buttons to reflect current mode
                this.updateModeButtons();
                
                console.log('✅ Display updated');
            }
            
            updateModeButtons() {
                console.log('🎮 updateModeButtons() called - current mode:', this.mode);
                
                const modeButtons = document.querySelectorAll('.mode-btn');
                modeButtons.forEach(btn => {
                    const btnMode = btn.dataset.mode;
                    if (btnMode === this.mode) {
                        btn.classList.add('active');
                        console.log('✅ Mode button activated:', btnMode);
                    } else {
                        btn.classList.remove('active');
                        console.log('❌ Mode button deactivated:', btnMode);
                    }
                });
            }
            
            // Enhanced Animation Loop
            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (!this.gameRunning || this.paused) {
                    this.renderer.render(this.scene, this.camera);
                    return;
                }
                
                // Check game over conditions
                if (this.checkGameOverConditions()) {
                    // Render game over screen
                    this.renderGameOverScreen();
                    return;
                }
                
                // Enhanced camera movement
                this.updateCamera();
                
                // Update falling letter
                this.updateFallingLetter();
                
                // Update particles
                this.particleSystem.update();
                
                // Update letter animations
                this.updateLetterAnimations();
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
            }
            
            // Render Game Over Screen (3D)
            renderGameOverScreen() {
                // Render the 3D scene first
                this.renderer.render(this.scene, this.camera);
                
                // Create 2D overlay for game over screen
                const canvas = this.renderer.domElement;
                const ctx = canvas.getContext('2d');
                
                // Create beautiful gradient overlay
                ctx.save();
                ctx.globalAlpha = this.gameOverScreen.fadeIn * 0.9;
                
                // Create gradient background
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(102, 126, 234, 0.95)');
                gradient.addColorStop(0.5, 'rgba(118, 75, 162, 0.95)');
                gradient.addColorStop(1, 'rgba(255, 71, 87, 0.95)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
                
                // Add animated particles in background
                this.drawGameOverParticles3D(ctx, canvas);
                
                // Game Over Title with enhanced styling
                ctx.save();
                ctx.globalAlpha = this.gameOverScreen.fadeIn;
                
                // Create text gradient
                const textGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                textGradient.addColorStop(0, '#ff4757');
                textGradient.addColorStop(0.5, '#ff3838');
                textGradient.addColorStop(1, '#c44569');
                
                ctx.fillStyle = textGradient;
                ctx.font = 'bold 64px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Enhanced glow effect
                ctx.shadowColor = '#ff4757';
                ctx.shadowBlur = 30;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Add stroke for better visibility
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.strokeText('GAME OVER', canvas.width / 2, canvas.height / 2 - 120);
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 120);
                ctx.restore();
                
                // Game Over Reason with better styling
                ctx.save();
                ctx.globalAlpha = this.gameOverScreen.fadeIn;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 28px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 10;
                ctx.fillText(this.gameOverReason, canvas.width / 2, canvas.height / 2 - 60);
                ctx.restore();
                
                // Final Stats
                if (this.gameOverScreen.showStats) {
                    this.renderGameOverStats(ctx, canvas);
                }
                
                // Action Buttons
                if (this.gameOverScreen.showStats) {
                    this.renderGameOverButtons(ctx, canvas);
                }
            }
            
            drawGameOverParticles3D(ctx, canvas) {
                const time = Date.now() * 0.001;
                
                // Create floating particles
                for (let i = 0; i < 15; i++) {
                    const x = (i * 100 + time * 50) % canvas.width;
                    const y = (i * 80 + time * 30) % canvas.height;
                    const size = Math.sin(time + i) * 3 + 4;
                    const alpha = Math.sin(time + i) * 0.3 + 0.2;
                    
                    ctx.save();
                    ctx.globalAlpha = alpha * this.gameOverScreen.fadeIn;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            renderGameOverStats(ctx, canvas) {
                const stats = this.gameOverScreen.finalStats;
                
                // Enhanced stats background with glass morphism effect
                ctx.save();
                ctx.globalAlpha = this.gameOverScreen.fadeIn;
                
                // Create gradient background
                const statsGradient = ctx.createLinearGradient(0, 0, 0, 250);
                statsGradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                statsGradient.addColorStop(1, 'rgba(255, 255, 255, 0.85)');
                
                ctx.fillStyle = statsGradient;
                
                // Rounded rectangle effect
                const statsX = canvas.width / 2 - 220;
                const statsY = canvas.height / 2 - 40;
                const statsWidth = 440;
                const statsHeight = 220;
                const radius = 20;
                
                ctx.beginPath();
                ctx.moveTo(statsX + radius, statsY);
                ctx.lineTo(statsX + statsWidth - radius, statsY);
                ctx.quadraticCurveTo(statsX + statsWidth, statsY, statsX + statsWidth, statsY + radius);
                ctx.lineTo(statsX + statsWidth, statsY + statsHeight - radius);
                ctx.quadraticCurveTo(statsX + statsWidth, statsY + statsHeight, statsX + statsWidth - radius, statsY + statsHeight);
                ctx.lineTo(statsX + radius, statsY + statsHeight);
                ctx.quadraticCurveTo(statsX, statsY + statsHeight, statsX, statsY + statsHeight - radius);
                ctx.lineTo(statsX, statsY + radius);
                ctx.quadraticCurveTo(statsX, statsY, statsX + radius, statsY);
                ctx.closePath();
                ctx.fill();
                
                // Add shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 20;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 10;
                ctx.restore();
                
                // Stats title with gradient
                ctx.save();
                ctx.globalAlpha = this.gameOverScreen.fadeIn;
                
                const titleGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                titleGradient.addColorStop(0, '#667eea');
                titleGradient.addColorStop(1, '#764ba2');
                
                ctx.fillStyle = titleGradient;
                ctx.font = 'bold 32px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 5;
                ctx.fillText('🏆 Statistiques Finales 3D', canvas.width / 2, canvas.height / 2 - 20);
                ctx.restore();
                
                // Stats content with better layout
                const statsContentY = canvas.height / 2 + 20;
                const statsData = [
                    { label: '🎯 Score Final', value: stats.totalScore, color: '#667eea' },
                    { label: '📝 Mots Complétés', value: stats.wordsCompleted, color: '#764ba2' },
                    { label: '🔤 Lettres Placées', value: stats.lettersPlaced, color: '#4ecdc4' },
                    { label: '⏱️ Temps de Jeu', value: `${Math.floor(stats.playTime / 60)}:${(stats.playTime % 60).toFixed(0).padStart(2, '0')}`, color: '#ff6b6b' },
                    { label: '📈 Niveau Atteint', value: stats.levelReached, color: '#ffa726' },
                    { label: '🔥 Combo Max', value: stats.maxCombo, color: '#ff4757' }
                ];
                
                ctx.save();
                ctx.globalAlpha = this.gameOverScreen.fadeIn;
                ctx.font = 'bold 18px Inter';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                
                statsData.forEach((stat, index) => {
                    const y = statsContentY + (index * 35);
                    const x = canvas.width / 2 - 180;
                    
                    // Label with color
                    ctx.fillStyle = stat.color;
                    ctx.fillText(stat.label, x, y);
                    
                    // Value
                    ctx.fillStyle = '#333';
                    ctx.fillText(`: ${stat.value}`, x + 200, y);
                });
                ctx.restore();
            }
            
            renderGameOverButtons(ctx, canvas) {
                // Restart Button
                const restartBtn = {
                    x: canvas.width / 2 - 140,
                    y: canvas.height / 2 + 120,
                    width: 120,
                    height: 50,
                    text: '🔄 Recommencer',
                    gradient: ['#667eea', '#764ba2']
                };
                
                // Main Menu Button
                const menuBtn = {
                    x: canvas.width / 2 + 20,
                    y: canvas.height / 2 + 120,
                    width: 120,
                    height: 50,
                    text: '🏠 Menu Principal',
                    gradient: ['#ff6b6b', '#ff4757']
                };
                
                // Draw buttons with enhanced styling
                [restartBtn, menuBtn].forEach(btn => {
                    ctx.save();
                    ctx.globalAlpha = this.gameOverScreen.fadeIn;
                    
                    // Create button gradient
                    const btnGradient = ctx.createLinearGradient(btn.x, btn.y, btn.x, btn.y + btn.height);
                    btnGradient.addColorStop(0, btn.gradient[0]);
                    btnGradient.addColorStop(1, btn.gradient[1]);
                    
                    // Button background with rounded corners
                    ctx.fillStyle = btnGradient;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 5;
                    
                    // Rounded rectangle
                    const radius = 25;
                    ctx.beginPath();
                    ctx.moveTo(btn.x + radius, btn.y);
                    ctx.lineTo(btn.x + btn.width - radius, btn.y);
                    ctx.quadraticCurveTo(btn.x + btn.width, btn.y, btn.x + btn.width, btn.y + radius);
                    ctx.lineTo(btn.x + btn.width, btn.y + btn.height - radius);
                    ctx.quadraticCurveTo(btn.x + btn.width, btn.y + btn.height, btn.x + btn.width - radius, btn.y + btn.height);
                    ctx.lineTo(btn.x + radius, btn.y + btn.height);
                    ctx.quadraticCurveTo(btn.x, btn.y + btn.height, btn.x, btn.y + btn.height - radius);
                    ctx.lineTo(btn.x, btn.y + radius);
                    ctx.quadraticCurveTo(btn.x, btn.y, btn.x + radius, btn.y);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Button text
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 16px Inter';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 3;
                    ctx.fillText(btn.text, btn.x + btn.width / 2, btn.y + btn.height / 2);
                    ctx.restore();
                });
                
                // Store button positions for click handling
                this.gameOverButtons = { restartBtn, menuBtn };
            }
            
            // Enhanced Camera Movement
            updateCamera() {
                const time = Date.now() * 0.001;
                
                // Gentle camera movement
                this.camera.position.x = Math.sin(time * 0.5) * 2;
                this.camera.position.y = 15 + Math.sin(time * 0.3) * 1;
                this.camera.position.z = 20 + Math.cos(time * 0.5) * 2;
                
                // Look at the center of the grid
                this.camera.lookAt(0, 0, 0);
            }
            
            // Enhanced Letter Animations
            updateLetterAnimations() {
                this.textMeshes.forEach(mesh => {
                    if (mesh.userData.isFalling) {
                        // Pulsing animation for falling letters
                        const time = Date.now() * 0.005;
                        const pulse = Math.sin(time) * 0.1 + 1;
                        mesh.scale.setScalar(pulse);
                        
                        // Update glow effect
                        if (mesh.userData.glowMesh) {
                            mesh.userData.glowMesh.scale.setScalar(pulse * 1.1);
                            mesh.userData.glowMesh.material.opacity = 0.3 * pulse;
                        }
                    } else {
                        // Gentle floating animation for placed letters
                        const time = Date.now() * 0.002;
                        mesh.position.y = mesh.userData.originalY + Math.sin(time + mesh.userData.offset) * 0.05;
                    }
                });
            }
            
            // Enhanced Falling Letter Update
            updateFallingLetter() {
                if (!this.fallingLetter) return;
                
                const time = Date.now() * 0.001;
                
                // Update falling letter position
                this.fallingLetter.y += 0.02;
                
                // Check collision
                if (this.checkCollision3D(this.fallingLetter.x, this.fallingLetter.y, this.fallingLetter.z)) {
                    this.placeLetter3D();
                }
                
                // Update visual representation
                this.updateFallingLetterVisual();
            }
            
            // Enhanced Letter Placement
            placeLetter3D() {
                if (!this.fallingLetter) return;
                
                const { x, y, z, letter } = this.fallingLetter;
                
                console.log('📝 Placing 3D letter:', letter, 'at position:', { x, y, z });
                
                // Place letter in grid
                const gridX = Math.floor((x + this.currentGridSize * (this.cellSize + this.gap) / 2) / (this.cellSize + this.gap));
                const gridZ = Math.floor((z + this.currentGridSize * (this.cellSize + this.gap) / 2) / (this.cellSize + this.gap));
                
                if (gridX >= 0 && gridX < this.currentGridSize && gridZ >= 0 && gridZ < this.currentGridSize) {
                    this.grid[gridZ][gridX] = letter;
                    
                    // Create visual letter
                    this.createLetter3D(letter, x, y, z, false);
                    
                    // Create placement effect
                    this.particleSystem.createPlacementEffect3D(x, y, z);
                    
                    // Play sound
                    this.audioManager.playPlace();
                    
                    // Check for word completion
                    this.checkWordCompletion3D();
                    
                    // Create new falling letter
                    this.createFallingLetter3D();
                }
            }
            
            // Utility Methods
            updateLetterQueueDisplay() {
                const queueElement = document.getElementById('letterQueue');
                if (queueElement) {
                    queueElement.innerHTML = '';
                    this.letterQueue.slice(0, 5).forEach(letter => {
                        const span = document.createElement('span');
                        span.textContent = letter;
                        span.className = 'queue-letter';
                        queueElement.appendChild(span);
                    });
                }
            }
            
            showComboEffect3D(bonus) {
                this.particleSystem.createComboEffect3D(bonus);
            }
            
            // Storage
            saveHighScore() {
                localStorage.setItem('lettersCascade3DHighScore', this.highScore.toString());
            }
            
            loadHighScore() {
                const saved = localStorage.getItem('lettersCascade3DHighScore');
                return saved ? parseInt(saved) : 0;
            }
            
            loadDictionary() {
                // French dictionary for word validation
                return new Set([
                    'BONJOUR', 'AU REVOIR', 'MERCI', 'SIL VOUS PLAIT', 'PARDON',
                    'OUI', 'NON', 'PEUT ETRE', 'CERTAINEMENT', 'PROBABLEMENT',
                    'MAINTENANT', 'AUJOURDHUI', 'HIER', 'DEMAIN', 'TOUJOURS',
                    'JAMAIS', 'PARFOIS', 'SOUVENT', 'RAREMENT', 'QUELQUEFOIS',
                    'BON', 'MAUVAIS', 'GRAND', 'PETIT', 'NOUVEAU', 'VIEUX',
                    'BEAU', 'JOLI', 'MOCHE', 'FORT', 'FAIBLE', 'RAPIDE', 'LENT',
                    'CHALEUREUX', 'FROID', 'CHAUD', 'DOUX', 'DUR', 'MOLLE',
                    'CLAIR', 'SOMBRE', 'LUMINEUX', 'OBSCUR', 'TRANSPARENT',
                    'OPAQUE', 'COLORE', 'BLANC', 'NOIR', 'ROUGE', 'BLEU',
                    'VERT', 'JAUNE', 'ORANGE', 'VIOLET', 'ROSE', 'GRIS',
                    'MARRON', 'BEIGE', 'DORE', 'ARGENTE', 'BRONZE', 'CUIVRE'
                ]);
            }
            
            // Mode and Grid Selection Methods
            selectMode(mode) {
                console.log('🎮 selectMode called with mode:', mode);
                this.mode = mode;
                this.updateDisplay();
                this.updateModeButtons();
            }
            
            selectGrid(size) {
                console.log('🎮 selectGrid called with size:', size);
                if (this.gridSizes.includes(size)) {
                    this.currentGridSize = size;
                    this.create3DGrid();
                    this.generateLetterQueue();
                    this.updateDisplay();
                }
            }

            // Enhanced 3D Grid Creation
            create3DGrid() {
                console.log('🏗️ Creating enhanced 3D grid...');
                
                this.grid = [];
                this.cubes = [];
                
                const gridSize = this.currentGridSize;
                const cellSize = this.cellSize;
                const gap = this.gap;
                const totalSize = gridSize * (cellSize + gap) - gap;
                const startX = -totalSize / 2;
                const startZ = -totalSize / 2;
                
                // Create grid array
                for (let row = 0; row < gridSize; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < gridSize; col++) {
                        this.grid[row][col] = null;
                    }
                }
                
                // Create visual grid cells
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        const x = startX + col * (cellSize + gap) + cellSize / 2;
                        const z = startZ + row * (cellSize + gap) + cellSize / 2;
                        const y = 0;
                        
                        // Create enhanced cube geometry
                        const geometry = new THREE.BoxGeometry(cellSize, 0.1, cellSize);
                        
                        // Create enhanced material with glass effect
                        const material = new THREE.MeshPhongMaterial({
                            color: 0xffffff,
                            transparent: true,
                            opacity: 0.3,
                            shininess: 100,
                            specular: 0x444444
                        });
                        
                        const cube = new THREE.Mesh(geometry, material);
                        cube.position.set(x, y, z);
                        cube.castShadow = true;
                        cube.receiveShadow = true;
                        cube.userData = { row, col, type: 'grid' };
                        
                        this.scene.add(cube);
                        this.cubes.push(cube);
                    }
                }
                
                console.log('✅ Enhanced 3D grid created with', this.cubes.length, 'cells');
            }
            
            // Enhanced Letter Creation
            createLetter3D(letter, x, y, z, isFalling = false) {
                console.log('📝 Creating 3D letter:', letter, 'at position:', { x, y, z });
                
                // Create enhanced text geometry
                const loader = new THREE.FontLoader();
                const fontUrl = 'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json';
                
                loader.load(fontUrl, (font) => {
                    const textGeometry = new THREE.TextGeometry(letter, {
                        font: font,
                        size: 0.8,
                        height: 0.2,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.03,
                        bevelSize: 0.02,
                        bevelOffset: 0,
                        bevelSegments: 5
                    });
                    
                    // Center the geometry
                    textGeometry.computeBoundingBox();
                    const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
                    
                    // Create enhanced material
                    const material = new THREE.MeshPhongMaterial({
                        color: isFalling ? 0x667eea : 0x4f46e5,
                        transparent: true,
                        opacity: 0.9,
                        shininess: 80,
                        specular: 0x222222
                    });
                    
                    const textMesh = new THREE.Mesh(textGeometry, material);
                    textMesh.position.set(x + centerOffset, y, z);
                    textMesh.castShadow = true;
                    textMesh.receiveShadow = true;
                    textMesh.userData = { letter, isFalling, type: 'letter' };
                    
                    // Add glow effect for falling letters
                    if (isFalling) {
                        const glowGeometry = textGeometry.clone();
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            color: 0x667eea,
                            transparent: true,
                            opacity: 0.3
                        });
                        const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                        glowMesh.position.set(x + centerOffset, y, z);
                        glowMesh.scale.setScalar(1.1);
                        this.scene.add(glowMesh);
                        textMesh.userData.glowMesh = glowMesh;
                    }
                    
                    this.scene.add(textMesh);
                    this.textMeshes.push(textMesh);
                    
                    console.log('✅ 3D letter created:', letter);
                });
            }

            // Fullscreen functionality
            toggleFullScreen() {
                console.log('🖥️ Game3D.toggleFullScreen() called');
                
                const gameContainer = document.querySelector('.game-container');
                const fullscreenBtn = document.querySelector('button[onclick="game3D.toggleFullScreen()"]');
                
                console.log('📦 Game container found:', gameContainer);
                console.log('🔘 Fullscreen button found:', fullscreenBtn);
                
                if (gameContainer.classList.contains('fullscreen')) {
                    console.log('📤 Exiting fullscreen mode');
                    this.exitFullScreen();
                } else {
                    console.log('📥 Entering fullscreen mode');
                    this.enterFullScreen();
                }
            }
            
            enterFullScreen() {
                console.log('📥 Game3D.enterFullScreen() called');
                
                const gameContainer = document.querySelector('.game-container');
                const fullscreenBtn = document.querySelector('button[onclick="game3D.toggleFullScreen()"]');
                
                gameContainer.classList.add('fullscreen');
                if (fullscreenBtn) {
                    fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i> Sortir';
                }
                
                // Add exit button
                const exitBtn = document.createElement('div');
                exitBtn.className = 'fullscreen-exit';
                exitBtn.innerHTML = '<i class="fas fa-times"></i>';
                exitBtn.onclick = () => this.exitFullScreen();
                gameContainer.appendChild(exitBtn);
                
                // Resize 3D renderer for full screen
                if (this.renderer) {
                    const container = gameContainer.querySelector('.game-grid-container');
                    const containerRect = container.getBoundingClientRect();
                    const maxWidth = Math.min(containerRect.width * 0.9, window.innerWidth * 0.8);
                    const maxHeight = Math.min(containerRect.height * 0.9, window.innerHeight * 0.7);
                    const canvasSize = Math.min(maxWidth, maxHeight);
                    
                    console.log('📐 Fullscreen dimensions:', {
                        containerWidth: containerRect.width,
                        containerHeight: containerRect.height,
                        maxWidth: maxWidth,
                        maxHeight: maxHeight,
                        canvasSize: canvasSize
                    });
                    
                    this.renderer.setSize(canvasSize, canvasSize);
                    
                    // Update camera aspect ratio
                    if (this.camera) {
                        this.camera.aspect = canvasSize / canvasSize;
                        this.camera.updateProjectionMatrix();
                        console.log('📷 Camera aspect ratio updated for fullscreen');
                    }
                    
                    // Enhance 3D scene for full screen
                    if (this.scene) {
                        // Adjust camera position for better view
                        this.camera.position.set(0, 0, 18);
                        this.camera.lookAt(0, 0, 0);
                        
                        // Enhance lighting for full screen
                        this.scene.children.forEach(child => {
                            if (child.type === 'DirectionalLight') {
                                child.intensity = 1.5;
                            } else if (child.type === 'PointLight') {
                                child.intensity = 1.2;
                            }
                        });
                        
                        console.log('🎬 3D scene enhanced for fullscreen');
                    }
                } else {
                    console.warn('⚠️ Renderer not available for fullscreen resize');
                }
                
                // Add keyboard shortcuts for full screen
                document.addEventListener('keydown', this.handleFullScreenKeyboard.bind(this));
                
                console.log('✅ Entered full screen mode');
            }
            
            exitFullScreen() {
                console.log('📤 Game3D.exitFullScreen() called');
                
                const gameContainer = document.querySelector('.game-container');
                const fullscreenBtn = document.querySelector('button[onclick="game3D.toggleFullScreen()"]');
                
                gameContainer.classList.remove('fullscreen');
                if (fullscreenBtn) {
                    fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> Plein Écran';
                }
                
                // Remove exit button
                const exitBtn = gameContainer.querySelector('.fullscreen-exit');
                if (exitBtn) {
                    gameContainer.removeChild(exitBtn);
                }
                
                // Reset 3D renderer size
                if (this.renderer) {
                    const container = gameContainer.querySelector('.game-grid-container');
                    const containerRect = container.getBoundingClientRect();
                    const size = Math.min(containerRect.width, containerRect.height);
                    
                    this.renderer.setSize(size, size);
                    
                    // Reset camera aspect ratio
                    if (this.camera) {
                        this.camera.aspect = size / size;
                        this.camera.updateProjectionMatrix();
                        console.log('📷 Camera aspect ratio reset');
                    }
                    
                    // Reset lighting
                    if (this.scene) {
                        this.scene.children.forEach(child => {
                            if (child.type === 'DirectionalLight') {
                                child.intensity = 1.0;
                            } else if (child.type === 'PointLight') {
                                child.intensity = 0.8;
                            }
                        });
                        
                        console.log('🎬 3D scene lighting reset');
                    }
                }
                
                // Remove keyboard shortcuts
                document.removeEventListener('keydown', this.handleFullScreenKeyboard.bind(this));
                
                console.log('✅ Exited full screen mode');
            }
            
            handleFullScreenKeyboard(event) {
                if (event.key === 'Escape') {
                    this.exitFullScreen();
                }
            }

            // 🎯 INTELLIGENT BALANCING METHODS (3D)
            
            calculateLetterFrequency() {
                console.log('📊 Calculating letter frequency for 3D target words...');
                
                const frequency = {};
                const allLetters = this.targetWords.join('').split('');
                
                // Count letter frequency
                allLetters.forEach(letter => {
                    frequency[letter] = (frequency[letter] || 0) + 1;
                });
                
                // Calculate percentages
                const totalLetters = allLetters.length;
                Object.keys(frequency).forEach(letter => {
                    frequency[letter] = {
                        count: frequency[letter],
                        percentage: (frequency[letter] / totalLetters) * 100,
                        priority: frequency[letter] / totalLetters
                    };
                });
                
                console.log('📈 3D Letter frequency calculated:', frequency);
                return frequency;
            }
            
            applyBalancing() {
                console.log('⚖️ Applying intelligent game balancing for 3D...');
                
                // 1. Adjust fall speed based on level and complexity
                this.adjustFallSpeed();
                
                // 2. Optimize grid size for current words
                this.optimizeGridSize();
                
                // 3. Generate balanced letter queue
                this.generateBalancedLetterQueue();
                
                // 4. Update target words based on level
                this.updateTargetWords();
                
                console.log('✅ 3D Balancing applied:', {
                    fallSpeed: this.fallSpeed,
                    gridSize: this.currentGridSize,
                    targetWords: this.targetWords,
                    queueLength: this.letterQueue.length
                });
            }
            
            adjustFallSpeed() {
                const baseSpeed = this.balancingSystem.baseFallSpeed;
                const levelMultiplier = 1 + (this.level - 1) * this.balancingSystem.levelBalance.speedIncrease;
                const complexityMultiplier = this.calculateComplexityMultiplier();
                
                this.fallSpeed = Math.max(
                    this.balancingSystem.minFallSpeed,
                    Math.min(
                        this.balancingSystem.maxFallSpeed,
                        baseSpeed * levelMultiplier * complexityMultiplier
                    )
                );
                
                console.log('⚡ 3D Fall speed adjusted:', {
                    level: this.level,
                    baseSpeed: baseSpeed,
                    levelMultiplier: levelMultiplier,
                    complexityMultiplier: complexityMultiplier,
                    finalSpeed: this.fallSpeed
                });
            }
            
            calculateComplexityMultiplier() {
                const avgWordLength = this.targetWords.reduce((sum, word) => sum + word.length, 0) / this.targetWords.length;
                const complexityScore = avgWordLength / 5; // Normalize to 5-letter words
                
                // More complex words = slower speed for better control
                return Math.max(0.8, Math.min(1.2, 1.1 - (complexityScore - 1) * 0.1));
            }
            
            optimizeGridSize() {
                const maxWordLength = Math.max(...this.targetWords.map(word => word.length));
                const avgWordLength = this.targetWords.reduce((sum, word) => sum + word.length, 0) / this.targetWords.length;
                
                // Calculate optimal grid size based on word lengths
                let optimalSize = Math.max(8, Math.min(12, Math.ceil(maxWordLength * 1.5)));
                
                // Adjust for number of words
                if (this.targetWords.length > 6) {
                    optimalSize = Math.min(optimalSize + 1, 12);
                }
                
                // Ensure grid size is in available options
                if (!this.gridSizes.includes(optimalSize)) {
                    optimalSize = this.gridSizes.reduce((prev, curr) => 
                        Math.abs(curr - optimalSize) < Math.abs(prev - optimalSize) ? curr : prev
                    );
                }
                
                this.currentGridSize = optimalSize;
                
                console.log('📐 3D Grid size optimized:', {
                    maxWordLength: maxWordLength,
                    avgWordLength: avgWordLength,
                    wordCount: this.targetWords.length,
                    optimalSize: optimalSize
                });
            }
            
            generateBalancedLetterQueue() {
                console.log('🎲 Generating balanced letter queue for 3D...');
                
                this.letterQueue = [];
                const frequency = this.balancingSystem.letterFrequency;
                const targetQueueSize = 15; // Optimal queue size
                
                // Create weighted letter pool
                const letterPool = [];
                Object.keys(frequency).forEach(letter => {
                    const weight = Math.ceil(frequency[letter].priority * 100);
                    for (let i = 0; i < weight; i++) {
                        letterPool.push(letter);
                    }
                });
                
                // Add some common letters for variety
                const commonLetters = ['A', 'E', 'I', 'O', 'U', 'R', 'S', 'T', 'N', 'L'];
                commonLetters.forEach(letter => {
                    if (!frequency[letter]) {
                        for (let i = 0; i < 5; i++) {
                            letterPool.push(letter);
                        }
                    }
                });
                
                // Generate balanced queue
                for (let i = 0; i < targetQueueSize; i++) {
                    const randomIndex = Math.floor(Math.random() * letterPool.length);
                    this.letterQueue.push(letterPool[randomIndex]);
                }
                
                console.log('📋 3D Balanced letter queue generated:', {
                    queueLength: this.letterQueue.length,
                    uniqueLetters: [...new Set(this.letterQueue)].length,
                    nextLetters: this.letterQueue.slice(0, 5)
                });
            }
            
            updateTargetWords() {
                console.log('📝 Updating 3D target words for level', this.level);
                
                const difficulty = this.getDifficultyForLevel();
                const wordCount = Math.min(3 + Math.floor(this.level / 2), 8);
                
                // Select words based on difficulty and level
                let selectedWords = [];
                
                if (difficulty === 'easy') {
                    selectedWords = [...this.balancingSystem.wordDifficulty.easy];
                } else if (difficulty === 'medium') {
                    selectedWords = [
                        ...this.balancingSystem.wordDifficulty.easy,
                        ...this.balancingSystem.wordDifficulty.medium
                    ];
                } else {
                    selectedWords = [
                        ...this.balancingSystem.wordDifficulty.easy,
                        ...this.balancingSystem.wordDifficulty.medium,
                        ...this.balancingSystem.wordDifficulty.hard
                    ];
                }
                
                // Shuffle and select appropriate number
                selectedWords = this.shuffleArray(selectedWords).slice(0, wordCount);
                
                this.targetWords = selectedWords;
                
                console.log('🎯 3D Target words updated:', {
                    level: this.level,
                    difficulty: difficulty,
                    wordCount: this.targetWords.length,
                    words: this.targetWords
                });
            }
            
            getDifficultyForLevel() {
                if (this.level <= 3) return 'easy';
                if (this.level <= 6) return 'medium';
                return 'hard';
            }
            
            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
            
            // Update balancing when level changes
            updateBalancingForLevel() {
                console.log('🔄 Updating 3D balancing for level', this.level);
                
                this.applyBalancing();
                
                // Update display
                this.updateDisplay();
                
                // Show level up effect
                this.showLevelUpEffect();
            }
            
            // Helper method to ensure proper letter display
            ensureLetterDisplay(letter) {
                // Map common problematic characters
                const letterMap = {
                    'B': 'B',
                    '6': 'B', // Fix for B appearing as 6
                    '8': 'B',
                    '0': 'O',
                    'O': 'O',
                    '1': 'I',
                    'I': 'I',
                    '5': 'S',
                    'S': 'S',
                    'Z': 'Z',
                    '2': 'Z'
                };
                
                // Return mapped letter or original if no mapping
                return letterMap[letter] || letter;
            }

            // Game Over Detection and Handling (3D)
            checkGameOverConditions() {
                console.log('🔍 Checking 3D game over conditions...');
                
                // Check if grid is too full
                const filledCells = this.letters.length;
                const totalCells = this.currentGridSize * this.currentGridSize;
                const fillPercentage = filledCells / totalCells;
                
                if (fillPercentage >= this.gameLimits.maxGridFill) {
                    console.log('❌ 3D Game Over: Grid too full');
                    this.triggerGameOver('Grid trop plein !', 'gridFull');
                    return true;
                }
                
                // Check time limit
                if (this.stats.startTime) {
                    const currentTime = Date.now();
                    const elapsedTime = currentTime - this.stats.startTime;
                    
                    if (elapsedTime >= this.gameLimits.timeLimit) {
                        console.log('❌ 3D Game Over: Time limit reached');
                        this.triggerGameOver('Temps écoulé !', 'timeLimit');
                        return true;
                    }
                }
                
                // Check if no valid moves are possible
                if (this.checkNoValidMoves()) {
                    console.log('❌ 3D Game Over: No valid moves');
                    this.triggerGameOver('Aucun mouvement possible !', 'noValidMoves');
                    return true;
                }
                
                // Check score threshold for level progression
                if (this.score < this.gameLimits.minScoreForLevel && this.level > 1) {
                    console.log('❌ 3D Game Over: Score too low for level');
                    this.triggerGameOver('Score insuffisant !', 'scoreThreshold');
                    return true;
                }
                
                return false;
            }
            
            checkNoValidMoves() {
                // Check if there's space for the falling letter
                if (!this.fallingLetter) return false;
                
                // Check if the falling letter can be placed anywhere
                for (let row = 0; row < this.currentGridSize; row++) {
                    for (let col = 0; col < this.currentGridSize; col++) {
                        if (!this.checkCollision(col, row)) {
                            return false; // Found a valid position
                        }
                    }
                }
                
                return true; // No valid positions found
            }
            
            triggerGameOver(reason, condition) {
                console.log('🎯 Triggering 3D Game Over:', reason);
                
                this.gameOver = true;
                this.gameOverReason = reason;
                this.gameOverConditions[condition] = true;
                
                // Stop game loop
                this.stopFallTimer();
                this.gameRunning = false;
                
                // Calculate final stats
                this.calculateFinalStats();
                
                // Show game over screen
                this.showGameOverScreen();
                
                // Play game over sound
                this.audioManager.playGameOver();
                
                // Save high score if applicable
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    this.saveHighScore();
                    this.showNewHighScoreNotification();
                }
                
                // Create game over particles
                this.particleSystem.createGameOverEffect();
            }
            
            calculateFinalStats() {
                const currentTime = Date.now();
                const playTime = this.stats.startTime ? 
                    (currentTime - this.stats.startTime) / 1000 : 0;
                
                this.gameOverScreen.finalStats = {
                    totalScore: this.score,
                    wordsCompleted: this.wordsFound.length,
                    lettersPlaced: this.stats.lettersPlaced,
                    playTime: playTime,
                    levelReached: this.level,
                    maxCombo: this.maxCombo
                };
                
                console.log('📊 3D Final Stats:', this.gameOverScreen.finalStats);
            }
            
            showGameOverScreen() {
                console.log('🎮 Showing 3D Game Over Screen');
                this.gameOverScreen.visible = true;
                this.gameOverScreen.fadeIn = 0;
                this.gameOverScreen.showStats = false;
                
                // Animate the game over screen
                this.animateGameOverScreen();
            }
            
            animateGameOverScreen() {
                const animate = () => {
                    if (!this.gameOverScreen.visible) return;
                    
                    // Fade in animation
                    if (this.gameOverScreen.fadeIn < 1) {
                        this.gameOverScreen.fadeIn += 0.02;
                    } else {
                        // Show stats after fade in
                        if (!this.gameOverScreen.showStats) {
                            this.gameOverScreen.showStats = true;
                        }
                    }
                    
                    requestAnimationFrame(animate);
                };
                
                animate();
            }
            
            showNewHighScoreNotification() {
                const notification = document.createElement('div');
                notification.className = 'high-score-notification';
                notification.innerHTML = `
                    <div class="notification-content">
                        <h3>🏆 Nouveau Record 3D !</h3>
                        <p>Score: ${this.score}</p>
                        <p>Félicitations !</p>
                    </div>
                `;
                
                document.body.appendChild(notification);
                
                // Remove after 5 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 5000);
            }
            
            restartGame() {
                console.log('🔄 Restarting 3D Game');
                
                // Reset game state
                this.gameOver = false;
                this.gameOverReason = '';
                this.gameOverScreen.visible = false;
                this.gameOverScreen.fadeIn = 0;
                this.gameOverScreen.showStats = false;
                
                // Reset game conditions
                Object.keys(this.gameOverConditions).forEach(key => {
                    this.gameOverConditions[key] = false;
                });
                
                // Reset game data
                this.score = 0;
                this.level = 1;
                this.combo = 0;
                this.maxCombo = 0;
                this.wordsFound = [];
                this.letters = [];
                this.letterQueue = [];
                this.fallingLetter = null;
                
                // Reset stats
                this.stats = {
                    lettersPlaced: 0,
                    wordsCompleted: 0,
                    totalScore: 0,
                    playTime: 0,
                    startTime: null,
                    mode: '3D'
                };
                
                // Reset balancing
                this.applyBalancing();
                
                // Start new game
                this.startGame();
            }
        }
        
        // 3D Word Detection System
        class WordDetector3D {
            constructor(dictionary) {
                this.dictionary = dictionary;
            }
            
            scanGrid(grid) {
                const words = [];
                
                // Scan horizontal
                for (let row = 0; row < grid.length; row++) {
                    const rowWords = this.findWordsInRow(grid[row]);
                    words.push(...rowWords);
                }
                
                // Scan vertical
                for (let col = 0; col < grid[0].length; col++) {
                    const colLetters = grid.map(row => row[col]);
                    const colWords = this.findWordsInRow(colLetters);
                    words.push(...colWords);
                }
                
                return words;
            }
            
            findWordsInRow(letters) {
                const words = [];
                const rowString = letters.map(letter => letter || ' ').join('');
                
                // Find all possible words of 3+ letters
                for (let start = 0; start < rowString.length; start++) {
                    for (let length = 3; length <= rowString.length - start; length++) {
                        const word = rowString.substr(start, length).replace(/\s/g, '');
                        if (word.length >= 3 && this.validateWord(word)) {
                            words.push(word);
                        }
                    }
                }
                
                return words;
            }
            
            validateWord(word) {
                return this.dictionary.has(word.toUpperCase());
            }
        }
        
        // 3D Scoring System
        class ScoreManager3D {
            constructor() {
                this.currentScore = 0;
                this.highScore = 0;
            }
            
            updateScore(score) {
                this.currentScore = score;
                if (score > this.highScore) {
                    this.highScore = score;
                }
            }
            
            getScore() {
                return this.currentScore;
            }
            
            getHighScore() {
                return this.highScore;
            }
        }
        
        // 3D Level System
        class LevelManager3D {
            constructor() {
                this.levels = [
                    { minWords: 0, maxWords: 5, speed: 1000 },
                    { minWords: 5, maxWords: 10, speed: 900 },
                    { minWords: 10, maxWords: 15, speed: 800 },
                    { minWords: 15, maxWords: 20, speed: 700 },
                    { minWords: 20, maxWords: 25, speed: 600 },
                    { minWords: 25, maxWords: 30, speed: 500 },
                    { minWords: 30, maxWords: 35, speed: 400 },
                    { minWords: 35, maxWords: 40, speed: 300 },
                    { minWords: 40, maxWords: 45, speed: 200 },
                    { minWords: 45, maxWords: 50, speed: 150 }
                ];
            }
            
            getCurrentLevel(wordsFound) {
                for (let i = this.levels.length - 1; i >= 0; i--) {
                    if (wordsFound >= this.levels[i].minWords) {
                        return i + 1;
                    }
                }
                return 1;
            }
            
            checkLevelProgression(wordsFound) {
                const newLevel = this.getCurrentLevel(wordsFound);
                return newLevel;
            }
        }
        
        // 3D Audio System
        class AudioManager3D {
            constructor() {
                this.sounds = {};
                this.muted = false;
            }
            
            playStart() {
                this.playSound('start');
            }
            
            playPause() {
                this.playSound('pause');
            }
            
            playResume() {
                this.playSound('resume');
            }
            
            playReset() {
                this.playSound('reset');
            }
            
            playMove() {
                this.playSound('move');
            }
            
            playRotate() {
                this.playSound('rotate');
            }
            
            playPlace() {
                this.playSound('place');
            }
            
            playWordComplete() {
                this.playSound('wordComplete');
            }
            
            playLevelUp() {
                this.playSound('levelUp');
            }
            
            playSound(type) {
                if (this.muted) return;
                
                // Create audio context if not exists
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Generate simple tones for different sounds
                const frequency = this.getFrequencyForSound(type);
                const duration = 0.1;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            getFrequencyForSound(type) {
                const frequencies = {
                    start: 440,
                    pause: 330,
                    resume: 440,
                    reset: 220,
                    move: 660,
                    rotate: 550,
                    place: 880,
                    wordComplete: 1100,
                    levelUp: 1320
                };
                return frequencies[type] || 440;
            }
        }
        
        // Enhanced 3D Particle System
        class ParticleSystem3D {
            constructor() {
                this.particles = [];
                this.scene = null;
            }
            
            setScene(scene) {
                this.scene = scene;
            }
            
            createPlacementEffect3D(x, y, z) {
                console.log('✨ Creating 3D placement effect at:', { x, y, z });
                
                for (let i = 0; i < 20; i++) {
                    const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0x667eea,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.set(x, y, z);
                    
                    // Random velocity
                    particle.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        Math.random() * 0.3,
                        (Math.random() - 0.5) * 0.2
                    );
                    
                    particle.userData.life = 1.0;
                    particle.userData.maxLife = 1.0;
                    
                    this.scene.add(particle);
                    this.particles.push(particle);
                }
            }
            
            createWordCompletionEffect3D(word, x, y, z) {
                console.log('🎉 Creating 3D word completion effect for:', word);
                
                // Create letter particles for each letter in the word
                for (let i = 0; i < word.length; i++) {
                    for (let j = 0; j < 10; j++) {
                        const geometry = new THREE.SphereGeometry(0.03, 6, 6);
                        const material = new THREE.MeshBasicMaterial({
                            color: 0x10b981,
                            transparent: true,
                            opacity: 0.9
                        });
                        
                        const particle = new THREE.Mesh(geometry, material);
                        particle.position.set(x + i * 0.5, y, z);
                        
                        // Explosive velocity
                        particle.userData.velocity = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.5,
                            Math.random() * 0.8,
                            (Math.random() - 0.5) * 0.5
                        );
                        
                        particle.userData.life = 1.5;
                        particle.userData.maxLife = 1.5;
                        particle.userData.letter = word[i];
                        
                        this.scene.add(particle);
                        this.particles.push(particle);
                    }
                }
                
                // Create celebration particles
                for (let i = 0; i < 30; i++) {
                    const geometry = new THREE.SphereGeometry(0.02, 4, 4);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xffd700,
                        transparent: true,
                        opacity: 1.0
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.set(x, y, z);
                    
                    // Spherical explosion
                    const angle = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const radius = 0.5 + Math.random() * 0.5;
                    
                    particle.userData.velocity = new THREE.Vector3(
                        Math.sin(phi) * Math.cos(angle) * radius,
                        Math.cos(phi) * radius,
                        Math.sin(phi) * Math.sin(angle) * radius
                    );
                    
                    particle.userData.life = 2.0;
                    particle.userData.maxLife = 2.0;
                    
                    this.scene.add(particle);
                    this.particles.push(particle);
                }
            }
            
            createLevelUpEffect3D() {
                console.log('🏆 Creating 3D level up effect');
                
                // Create spiral effect
                for (let i = 0; i < 50; i++) {
                    const geometry = new THREE.SphereGeometry(0.04, 6, 6);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0x8b5cf6,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.set(0, 0, 0);
                    
                    // Spiral trajectory
                    const angle = (i / 50) * Math.PI * 4;
                    const radius = 2 + (i / 50) * 3;
                    const height = (i / 50) * 5;
                    
                    particle.userData.velocity = new THREE.Vector3(
                        Math.cos(angle) * radius * 0.1,
                        height * 0.1,
                        Math.sin(angle) * radius * 0.1
                    );
                    
                    particle.userData.life = 3.0;
                    particle.userData.maxLife = 3.0;
                    
                    this.scene.add(particle);
                    this.particles.push(particle);
                }
            }
            
            update() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    // Update position
                    particle.position.add(particle.userData.velocity);
                    
                    // Update life
                    particle.userData.life -= 0.016; // 60 FPS
                    
                    // Update opacity
                    particle.material.opacity = particle.userData.life / particle.userData.maxLife;
                    
                    // Update scale
                    particle.scale.setScalar(1 + (1 - particle.userData.life / particle.userData.maxLife) * 0.5);
                    
                    // Remove dead particles
                    if (particle.userData.life <= 0) {
                        this.scene.remove(particle);
                        this.particles.splice(i, 1);
                    }
                }
            }
        }

        // Global game instance
        let game3D;

        // Global functions for button controls
        function selectMode(mode) {
            if (game3D) game3D.selectMode(mode);
        }

        function selectGrid(size) {
            if (game3D) game3D.selectGrid(size);
        }

        function startGame() {
            if (game3D) game3D.startGame();
        }

        function resetGame() {
            if (game3D) game3D.resetGame();
        }

        function pauseGame() {
            if (game3D) game3D.pauseGame();
        }

        function clearGrid() {
            if (game3D) game3D.clearGrid();
        }

        // Initialize 3D game when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 DOM Content Loaded - Initializing 3D game...');
            
            // Check if Three.js is available
            if (typeof THREE === 'undefined') {
                console.error('❌ THREE.js not loaded!');
                // Show error message to user
                const container = document.getElementById('gameGrid');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: #ff6b6b;">
                            <h3>❌ Erreur de chargement</h3>
                            <p>Three.js n'a pas pu être chargé. Veuillez rafraîchir la page.</p>
                        </div>
                    `;
                }
                return;
            }
            
            console.log('✅ THREE.js available, creating Game3D instance...');
            
            try {
                game3D = new Game3D();
                console.log('🎮 3D Game initialized successfully');
                
                // Check if Utils is available
                if (typeof Utils !== 'undefined') {
                    console.log('✅ Utils available for sound and particle effects');
                } else {
                    console.warn('⚠️ Utils not available - sound and particle effects disabled');
                }
                
                // Update display after initialization
                setTimeout(() => {
                    if (game3D && typeof game3D.updateDisplay === 'function') {
                        game3D.updateDisplay();
                        console.log('📊 Display updated after initialization');
                    }
                }, 100);
                
            } catch (error) {
                console.error('❌ Error initializing 3D game:', error);
                const container = document.getElementById('gameGrid');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: #ff6b6b;">
                            <h3>❌ Erreur d'initialisation</h3>
                            <p>Le jeu 3D n'a pas pu être initialisé: ${error.message}</p>
                            <button onclick="location.reload()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                Rafraîchir la page
                            </button>
                        </div>
                    `;
                }
            }
        });

        // Fullscreen function
        function toggleFullScreen() {
            console.log('🖥️ toggleFullScreen() called');
            
            const gameContainer = document.querySelector('.game-container');
            const fullscreenBtn = document.querySelector('button[onclick="game3D.toggleFullScreen()"]');
            
            console.log('📦 Game container found:', gameContainer);
            console.log('🔘 Fullscreen button found:', fullscreenBtn);
            
            if (gameContainer.classList.contains('fullscreen')) {
                console.log('📤 Exiting fullscreen mode');
                exitFullScreen();
            } else {
                console.log('📥 Entering fullscreen mode');
                enterFullScreen();
            }
        }

        function enterFullScreen() {
            console.log('📥 enterFullScreen() called');
            
            const gameContainer = document.querySelector('.game-container');
            const fullscreenBtn = document.querySelector('button[onclick="game3D.toggleFullScreen()"]');
            
            gameContainer.classList.add('fullscreen');
            fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i> Sortir';
            
            // Add exit button
            const exitBtn = document.createElement('div');
            exitBtn.className = 'fullscreen-exit';
            exitBtn.innerHTML = '<i class="fas fa-times"></i>';
            exitBtn.onclick = exitFullScreen;
            gameContainer.appendChild(exitBtn);
            
            // Resize 3D canvas for full screen
            const canvas = document.getElementById('threejsCanvas');
            console.log('🎨 Canvas found for fullscreen:', canvas);
            
            if (canvas && game3D && game3D.renderer) {
                // Calculate optimal canvas size for full screen
                const container = gameContainer.querySelector('.game-grid-container');
                const containerRect = container.getBoundingClientRect();
                const maxWidth = Math.min(containerRect.width * 0.9, window.innerWidth * 0.8);
                const maxHeight = Math.min(containerRect.height * 0.9, window.innerHeight * 0.7);
                const canvasSize = Math.min(maxWidth, maxHeight);
                
                console.log('📐 Fullscreen dimensions:', {
                    containerWidth: containerRect.width,
                    containerHeight: containerRect.height,
                    maxWidth: maxWidth,
                    maxHeight: maxHeight,
                    canvasSize: canvasSize
                });
                
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                game3D.renderer.setSize(canvasSize, canvasSize);
                
                // Update camera aspect ratio
                if (game3D.camera) {
                    game3D.camera.aspect = canvasSize / canvasSize;
                    game3D.camera.updateProjectionMatrix();
                    console.log('📷 Camera aspect ratio updated for fullscreen');
                }
                
                // Enhance 3D scene for full screen
                if (game3D.scene) {
                    // Adjust camera position for better view
                    game3D.camera.position.set(0, 0, 18);
                    game3D.camera.lookAt(0, 0, 0);
                    
                    // Enhance lighting for full screen
                    game3D.scene.children.forEach(child => {
                        if (child.type === 'DirectionalLight') {
                            child.intensity = 1.5;
                        } else if (child.type === 'PointLight') {
                            child.intensity = 1.2;
                        }
                    });
                    
                    console.log('🎬 3D scene enhanced for fullscreen');
                }
            } else {
                console.warn('⚠️ Canvas or renderer not available for fullscreen resize');
            }
            
            // Add keyboard shortcuts for full screen
            document.addEventListener('keydown', handleFullScreenKeyboard);
            
            console.log('✅ Entered full screen mode');
        }

        function exitFullScreen() {
            console.log('📤 exitFullScreen() called');
            
            const gameContainer = document.querySelector('.game-container');
            const fullscreenBtn = document.querySelector('button[onclick="game3D.toggleFullScreen()"]');
            
            gameContainer.classList.remove('fullscreen');
            fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> Plein Écran';
            
            // Remove exit button
            const exitBtn = gameContainer.querySelector('.fullscreen-exit');
            if (exitBtn) {
                exitBtn.remove();
                console.log('❌ Exit button removed');
            }
            
            // Reset 3D canvas size
            const canvas = document.getElementById('threejsCanvas');
            console.log('🎨 Canvas found for exit fullscreen:', canvas);
            
            if (canvas && game3D && game3D.renderer) {
                canvas.width = 500;
                canvas.height = 500;
                game3D.renderer.setSize(500, 500);
                
                // Update camera aspect ratio
                if (game3D.camera) {
                    game3D.camera.aspect = 1;
                    game3D.camera.updateProjectionMatrix();
                    console.log('📷 Camera aspect ratio reset');
                }
                
                // Reset 3D scene to normal mode
                if (game3D.scene) {
                    // Reset camera position
                    game3D.camera.position.set(0, 0, 15);
                    game3D.camera.lookAt(0, 0, 0);
                    
                    // Reset lighting
                    game3D.scene.children.forEach(child => {
                        if (child.type === 'DirectionalLight') {
                            child.intensity = 1.2;
                        } else if (child.type === 'PointLight') {
                            child.intensity = 1;
                        }
                    });
                    
                    console.log('🎬 3D scene reset to normal mode');
                }
            } else {
                console.warn('⚠️ Canvas or renderer not available for fullscreen exit resize');
            }
            
            // Remove keyboard shortcuts
            document.removeEventListener('keydown', handleFullScreenKeyboard);
            
            console.log('✅ Exited full screen mode');
        }

        function handleFullScreenKeyboard(event) {
            switch(event.key) {
                case 'Escape':
                    console.log('⌨️ Escape key pressed - exiting fullscreen');
                    event.preventDefault();
                    exitFullScreen();
                    break;
                case 'F11':
                    console.log('⌨️ F11 key pressed - exiting fullscreen');
                    event.preventDefault();
                    exitFullScreen();
                    break;
                case ' ':
                    console.log('⌨️ Space key pressed - toggling game pause');
                    event.preventDefault();
                    if (game3D) {
                        if (game3D.gameRunning && !game3D.paused) {
                            game3D.pauseGame();
                        } else if (game3D.gameRunning && game3D.paused) {
                            game3D.startGame();
                        }
                    }
                    break;
                case 'r':
                case 'R':
                    console.log('⌨️ R key pressed - resetting game');
                    event.preventDefault();
                    if (game3D) {
                        game3D.resetGame();
                    }
                    break;
                case 's':
                case 'S':
                    console.log('⌨️ S key pressed - starting game');
                    event.preventDefault();
                    if (game3D && !game3D.gameRunning) {
                        game3D.startGame();
                    }
                    break;
            }
        }

        // Keyboard shortcut for full screen (F11)
        document.addEventListener('keydown', function(event) {
            if (event.key === 'F11') {
                console.log('⌨️ F11 key pressed - toggling fullscreen');
                event.preventDefault();
                toggleFullScreen();
            }
        });
    </script>
</body>
</html>