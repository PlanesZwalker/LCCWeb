<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maquette 3D - Letters Cascade Challenge</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÆ</text></svg>">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/shared.css">
    <script src="js/utils.js"></script>
    <style>
        /* Enhanced 3D Game Layout - Optimized for single screen */
        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: var(--spacing-md);
            max-width: 1400px;
            margin: 0 auto;
            height: 100vh;
            overflow: hidden;
        }

        .game-section {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            height: 100%;
            overflow-y: auto;
        }

        /* Enhanced Game Header - Compact */
        .game-header {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .game-header h1 {
            font-size: 1.5rem;
            margin-bottom: var(--spacing-xs);
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .game-header p {
            font-size: 0.9rem;
            color: var(--gray-300);
            margin: 0;
        }

        /* Enhanced Game Container - Compact */
        .game-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-xl);
            padding: var(--spacing-md);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Enhanced Controls Section - Compact */
        .controls-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
            padding: var(--spacing-md);
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--radius-lg);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .control-group h3 {
            font-size: 0.9rem;
            color: var(--gray-300);
            margin-bottom: var(--spacing-xs);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Enhanced Game Controls - Compact */
        .game-controls {
            display: flex;
            gap: var(--spacing-sm);
            flex-wrap: wrap;
        }

        .game-controls .btn {
            padding: var(--spacing-sm) var(--spacing-md);
            font-size: 0.9rem;
            min-width: auto;
        }

        /* Enhanced Mode and Grid Selection */
        .mode-selection, .grid-selection {
            display: flex;
            gap: var(--spacing-sm);
            flex-wrap: wrap;
        }

        .mode-btn, .grid-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm) var(--spacing-md);
            color: var(--white);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .mode-btn:hover, .grid-btn:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .mode-btn.active, .grid-btn.active {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-color: var(--accent-color);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        /* Enhanced Game Grid */
        .game-grid-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: var(--spacing-lg);
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-lg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 400px;
        }

        /* Full Screen Styles for 3D Game */
        .game-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
            background: var(--bg-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: var(--spacing-lg);
        }

        .game-container.fullscreen .game-grid-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .game-container.fullscreen #threejsCanvas {
            max-width: 90vw;
            max-height: 90vh;
            width: auto;
            height: auto;
        }

        .game-container.fullscreen .controls-section {
            position: absolute;
            top: var(--spacing-lg);
            left: var(--spacing-lg);
            right: var(--spacing-lg);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
        }

        .game-container.fullscreen .game-info {
            position: absolute;
            bottom: var(--spacing-lg);
            left: var(--spacing-lg);
            right: var(--spacing-lg);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
        }

        .fullscreen-exit {
            position: absolute;
            top: var(--spacing-md);
            right: var(--spacing-md);
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--white);
            padding: var(--spacing-sm);
            border-radius: var(--radius-sm);
            cursor: pointer;
            z-index: 10000;
        }

        #gameGrid {
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        /* Enhanced Game Info - Compact */
        .game-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }

        .info-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm);
            text-align: center;
        }

        .info-section h4 {
            font-size: 0.8rem;
            color: var(--gray-300);
            margin-bottom: var(--spacing-xs);
            text-transform: uppercase;
        }

        .info-section .value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--primary-color);
        }

        /* Enhanced Score Display - Compact */
        .score-display {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm);
            text-align: center;
            margin-bottom: var(--spacing-md);
        }

        .score-display span {
            display: block;
            font-size: 0.9rem;
            color: var(--gray-300);
            margin-bottom: var(--spacing-xs);
        }

        .score-display strong {
            font-size: 1.5rem;
            color: var(--accent-color);
            font-weight: bold;
        }

        /* Enhanced Word List - Compact */
        .word-list {
            max-height: 120px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
        }

        .word-list li {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-sm);
            padding: var(--spacing-xs) var(--spacing-sm);
            margin-bottom: var(--spacing-xs);
            color: var(--white);
            font-weight: 600;
            font-size: 0.9rem;
            transition: var(--transition);
            cursor: pointer;
        }

        .word-list li.completed {
            background: rgba(76, 175, 80, 0.3);
            border-color: rgba(76, 175, 80, 0.5);
        }

        /* Enhanced Letter Queue - Compact */
        .letter-queue {
            display: flex;
            gap: var(--spacing-xs);
            justify-content: center;
            margin-bottom: var(--spacing-sm);
        }

        .queue-letter {
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--white);
            font-weight: bold;
            font-size: 0.9rem;
            transition: var(--transition);
        }

        /* Enhanced Sidebar Sections - Compact */
        .sidebar-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        .sidebar-section h3 {
            font-size: 1rem;
            margin-bottom: var(--spacing-sm);
            color: var(--white);
        }

        .sidebar-section p {
            font-size: 0.9rem;
            color: var(--gray-300);
            margin-bottom: var(--spacing-sm);
        }

        /* Enhanced Concept Showcase */
        .concept-showcase {
            display: grid;
            gap: var(--spacing-lg);
        }

        .concept-showcase-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-md);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .concept-showcase-item img {
            width: 100%;
            height: 150px;
            object-fit: cover;
        }

        .concept-info {
            padding: var(--spacing-md);
        }

        .concept-info h4 {
            font-size: 1rem;
            margin-bottom: var(--spacing-xs);
            color: var(--accent-color);
        }

        .concept-info p {
            font-size: 0.9rem;
            color: var(--gray-400);
            margin: 0;
        }

        /* Loading Indicator */
        .loading-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-md);
            padding: var(--spacing-lg);
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-lg);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr 250px;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr auto;
            }
            
            .controls-section {
                grid-template-columns: 1fr;
            }
            
            .game-info {
                grid-template-columns: 1fr;
            }
        }

        /* Animations */
        @keyframes queueBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="page-layout">
            <!-- Navigation Menu -->
            <div class="nav-sidebar">
                <h3>Navigation</h3>
                <div class="nav-links">
                    <a href="index.html"><i class="fas fa-home"></i> Accueil</a>
                    <a href="prototype.html"><i class="fas fa-flask"></i> Maquette 2D</a>
                    <a href="game.html" class="active"><i class="fas fa-gamepad"></i> Maquette 3D</a>
                    <a href="GDD.html"><i class="fas fa-file-alt"></i> Documentation</a>
                    <a href="moodboard.html"><i class="fas fa-palette"></i> Moodboard</a>
                    <a href="sitemap.html"><i class="fas fa-sitemap"></i> Plan de Site</a>
                </div>
        </div>

            <div class="main-content">
                <div class="game-section">
                    <!-- Enhanced Game Header -->
                    <div class="game-header">
                        <h1>üéÆ Maquette 3D - Letters Cascade Challenge</h1>
                        <p>Mode immersif avec grille 3D - Jouabilit√© avanc√©e</p>
        </div>

                    <div class="game-container">
                        <!-- Enhanced Controls Section -->
                        <div class="controls-section">
                            <div class="control-group">
                                <h3><i class="fas fa-gamepad"></i> Contr√¥les du Jeu</h3>
                                <div class="game-controls">
                                    <button id="startBtn" class="btn">
                                        <i class="fas fa-play"></i> D√©marrer
                                    </button>
                                    <button id="pauseBtn" class="btn">
                                        <i class="fas fa-pause"></i> Pause
                                    </button>
                                    <button id="resetBtn" class="btn">
                                        <i class="fas fa-redo"></i> Reset
                                    </button>
                                    <button id="fullscreenBtn" class="btn" onclick="toggleFullScreen()">
                                        <i class="fas fa-expand"></i> Plein √âcran
                                    </button>
                                </div>
            </div>

                            <div class="control-group">
                                <h3><i class="fas fa-cog"></i> Configuration</h3>
                                <div class="mode-selection">
                                    <button class="mode-btn" data-mode="2d">
                                        <i class="fas fa-square"></i> Mode 2D
                                    </button>
                                    <button class="mode-btn active" data-mode="3d">
                                        <i class="fas fa-cube"></i> Mode 3D
                                    </button>
                    </div>
                                <div class="grid-selection">
                                    <button class="grid-btn" data-size="8x8">8√ó8</button>
                                    <button class="grid-btn active" data-size="10x10">10√ó10</button>
                                    <button class="grid-btn" data-size="12x12">12√ó12</button>
                </div>
                </div>
            </div>

                        <!-- Enhanced Game Grid -->
                        <div class="game-grid-container">
                            <div id="gameContainer" class="grid-3d">
                                <div id="gameGrid" class="grid-cube grid-10x10">
                                    <!-- Grid will be generated by JavaScript -->
                </div>
            </div>
        </div>

                        <!-- Enhanced Game Info -->
                        <div class="game-info">
                            <div class="info-section">
                                <h4>Score</h4>
                                <strong class="value" id="scoreValue">0</strong>
            </div>
                                    <div class="info-section">
                                        <h4>Niveau</h4>
                                        <strong class="value" id="levelValue">1</strong>
            </div>
                                    <div class="info-section">
                                        <h4>Mode</h4>
                                        <strong class="value" id="currentMode">2D</strong>
            </div>
                                    <div class="info-section">
                                        <h4>Grille</h4>
                                        <strong class="value" id="currentGrid">10√ó10</strong>
            </div>
                                    <div class="info-section">
                                        <h4>Temps</h4>
                                        <strong class="value" id="timeValue">00:00</strong>
        </div>
                                    <div class="info-section">
                                        <h4>Mots</h4>
                                        <strong class="value" id="wordsValue">0</strong>
        </div>
        </div>
        </div>

                            <div class="info-section">
                                <h3><i class="fas fa-list-check"></i> Mots √† compl√©ter</h3>
                                <div class="word-list">
                                    <ul id="wordsFound">
                                        <li>CHAT</li>
                                        <li>MAISON</li>
                                        <li>MUSIQUE</li>
                                        <li>PLANTE</li>
                                        <li>LUMI√àRE</li>
            </ul>
        </div>
                                <div class="letter-queue">
                                    <h4><i class="fas fa-queue"></i> Prochaines lettres</h4>
                                    <div id="letterQueue" class="queue-display"></div>
            </div>
            </div>
        </div>

                        <div id="loadingIndicator" class="loading-indicator" style="display: none;">
                            <div class="loading-spinner"></div>
                            Chargement du jeu...
            </div>
            </div>
            </div>

                <!-- Enhanced Sidebar -->
                <div class="sidebar">
                    <div class="sidebar-section">
                        <h3><i class="fas fa-info-circle"></i> √Ä propos de la Maquette 3D</h3>
                        <p>Cette version pr√©sente le mode immersif 3D du jeu Letters Cascade Challenge.</p>
                        <p><strong>Caract√©ristiques :</strong> Grille 3D multi-couches, effets visuels avanc√©s, gameplay immersif.</p>
                        <p><strong>Note :</strong> Interface et design uniquement - logique de jeu en d√©veloppement.</p>
            </div>

                    <div class="sidebar-section">
                        <h3><i class="fas fa-book"></i> R√®gles du Jeu 3D</h3>
                        <ul style="list-style: none; padding: 0; margin: 0;">
                            <li style="margin-bottom: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm);">
                                üéØ <strong>Formation de Mots:</strong> Formez des mots de 3+ lettres en utilisant les lettres qui tombent
                            </li>
                            <li style="margin-bottom: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm);">
                                üèÜ <strong>Score:</strong> 1 point par lettre + bonus longueur √ó 10
                            </li>
                            <li style="margin-bottom: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm);">
                                üéÆ <strong>Contr√¥les:</strong> Fl√®ches pour d√©placer, Espace pour rotation
                            </li>
                            <li style="margin-bottom: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm);">
                                üåü <strong>Bonus 3D:</strong> +50 points pour formation 3D
                            </li>
                        </ul>
            </div>

                    <div class="sidebar-section">
                        <h3><i class="fas fa-mobile-alt"></i> Support Mobile 3D</h3>
                        <div style="margin-bottom: var(--spacing-md);">
                            <strong>üì± Portrait:</strong> Grille 120√ó120px, contr√¥les compacts, une main suffit
            </div>
                        <div>
                            <strong>üîÑ Paysage:</strong> Grille 100√ó100px, sidebar compl√®te, deux mains recommand√©es
                    </div>
                </div>

                    <div class="sidebar-section">
                        <h3><i class="fas fa-chart-bar"></i> Progression 3D</h3>
                        <div style="display: grid; gap: var(--spacing-sm);">
                            <div style="padding: var(--spacing-sm); background: rgba(76, 175, 80, 0.1); border-radius: var(--radius-sm); border-left: 3px solid #4caf50;">
                                üü¢ <strong>Facile:</strong> 8√ó8, 2-3s par chute, mots 3-4 lettres
                            </div>
                            <div style="padding: var(--spacing-sm); background: rgba(255, 193, 7, 0.1); border-radius: var(--radius-sm); border-left: 3px solid #ffc107;">
                                üü° <strong>Moyen:</strong> 10√ó10, 1.5-2s par chute, mots 4-5 lettres
                        </div>
                            <div style="padding: var(--spacing-sm); background: rgba(255, 152, 0, 0.1); border-radius: var(--radius-sm); border-left: 3px solid #ff9800;">
                                üü† <strong>Difficile:</strong> 12√ó12, 1-1.5s par chute, mots 5-6 lettres
                        </div>
                            <div style="padding: var(--spacing-sm); background: rgba(244, 67, 54, 0.1); border-radius: var(--radius-sm); border-left: 3px solid #f44336;">
                                üî¥ <strong>Expert:</strong> 12√ó12, 0.5-1s par chute, mots 6+ lettres
                </div>
            </div>
        </div>

                    <div class="sidebar-section">
                        <h3><i class="fas fa-cube"></i> Mode 3D Avanc√©</h3>
                        <ul style="list-style: none; padding: 0; margin: 0;">
                            <li style="margin-bottom: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm);">
                                üéØ <strong>6 Directions:</strong> Horizontal, vertical, profondeur, diagonales
                            </li>
                            <li style="margin-bottom: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm);">
                                üèóÔ∏è <strong>3 Couches:</strong> Avant, milieu, arri√®re pour combos avanc√©s
                            </li>
                            <li style="margin-bottom: var(--spacing-sm); padding: var(--spacing-sm); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-sm);">
                                üåü <strong>Bonus 3D:</strong> +50 points pour formation 3D
                            </li>
                    </ul>
                </div>

                    <!-- Enhanced Concept Images Section -->
                    <div class="sidebar-section">
                        <h3><i class="fas fa-palette"></i> Concepts Visuels</h3>
                        <div class="concept-showcase">
                            <div class="concept-showcase-item">
                                <img src="images/Cascade Letters - 02 - Decor concept 01.png" alt="Environment Concept - KridVOID" onerror="this.src='https://via.placeholder.com/250x150/667eea/ffffff?text=Environment'">
                                <div class="concept-info">
                                    <h4>Environnement 3D</h4>
                                    <p>Concepts d'environnement immersif avec cascades et √©l√©ments naturels</p>
                </div>
                </div>
                            <div class="concept-showcase-item">
                                <img src="images/HighresScreenshot00002.png" alt="High Resolution Interface - KridVOID" onerror="this.src='https://via.placeholder.com/250x150/764ba2/ffffff?text=Interface'">
                                <div class="concept-info">
                                    <h4>Interface Haute R√©solution</h4>
                                    <p>D√©tails visuels et qualit√© graphique pour une exp√©rience premium</p>
                </div>
            </div>
        </div>
            </div>
            </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Complete 3D Game Engine for Letters Cascade Challenge
        class Game3D {
            constructor() {
                console.log('üîß Game3D constructor called');
                this.mode = '3d';
                this.gridSize = 10;
                this.score = 0;
                this.level = 1;
                this.wordsFound = 0;
                this.gameRunning = false;
                this.paused = false;
                this.startTime = null;
                this.letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
                this.targetWords = ['CHAT', 'MAISON', 'MUSIQUE', 'JARDIN', 'LIVRE', 'TABLE', 'FEN√äTRE', 'PORTE'];
                this.completedWords = [];
                this.currentLetter = null;
                this.letterPosition = { x: 0, y: 0 };
                this.gameSpeed = 1000;
                this.gameInterval = null;
                
                // Three.js properties
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.grid = [];
                this.raycaster = null;
                this.mouse = null;
                
                console.log('üîß Game3D constructor completed, calling init()');
                this.init();
            }

            init() {
                console.log('üöÄ init() called - mode:', this.mode, 'THREE available:', typeof THREE !== 'undefined');
                
                if (this.mode === '3d' && typeof THREE !== 'undefined') {
                    console.log('üéÆ Three.js loaded, checking WebGL support...');
                    
                    // Check WebGL support
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    
                    if (gl) {
                        console.log('‚úÖ WebGL supported, creating 3D game...');
                        this.initThreeJS();
                    } else {
                        console.warn('‚ö†Ô∏è WebGL not supported, falling back to 2D grid...');
                        this.createGrid(); // Fallback to original 2D grid
                    }
                } else {
                    console.log('üì± Using 2D grid mode...');
                    this.createGrid(); // Use 2D grid
                }
                
                console.log('üîÑ Calling updateLetterQueue()');
                this.updateLetterQueue();
                
                console.log('üìä Calling updateDisplay()');
                this.updateDisplay();
                
                console.log('üéØ Calling setupEventListeners()');
                this.setupEventListeners();
                
                if (typeof Utils !== 'undefined') {
                    console.log('‚úÖ Game initialized with Utils');
                } else {
                    console.warn('‚ö†Ô∏è Utils not available');
                }
                
                console.log('üéâ init() completed successfully');
            }

            initThreeJS() {
                console.log('üéÆ initThreeJS() called');
                
                const container = document.getElementById('gameGrid');
                console.log('üì¶ Container found:', container);
                
                if (!container) {
                    console.error('‚ùå gameGrid container not found!');
                    return;
                }
                
                const canvas = document.createElement('canvas');
                canvas.id = 'threejsCanvas';
                canvas.width = 500;
                canvas.height = 500;
                canvas.style.border = '2px solid rgba(255, 255, 255, 0.3)';
                canvas.style.borderRadius = '12px';
                canvas.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.3)';
                container.innerHTML = '';
                container.appendChild(canvas);
                
                console.log('üé® Canvas created and added to container');

                // Enhanced scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1a1a2e);
                console.log('üåå Scene created');
                
                // Enhanced camera with better positioning
                this.camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);
                this.camera.position.set(0, 0, 15);
                this.camera.lookAt(0, 0, 0);
                console.log('üì∑ Camera created and positioned');

                // Enhanced renderer with better quality
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    alpha: true, 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                
                this.renderer.setSize(canvas.width, canvas.height);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
                console.log('üé® Renderer created with enhanced settings');

                // Create enhanced 3D grid
                const cellSize = 1.2;
                const gap = 0.2;
                this.grid = [];
                console.log('üèóÔ∏è Creating 3D grid with size:', this.gridSize, 'cellSize:', cellSize);

                for (let row = 0; row < this.gridSize; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < this.gridSize; col++) {
                        // Enhanced cube geometry
                        const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
                        
                        // Enhanced material with gradient effect
                        const material = new THREE.MeshPhongMaterial({ 
                            color: 0x2a2a3e, 
                            transparent: true, 
                            opacity: 0.8,
                            shininess: 100,
                            specular: 0x444444
                        });
                        
                        const cube = new THREE.Mesh(geometry, material);
                        cube.position.set(
                            (col - this.gridSize/2) * (cellSize + gap),
                            (row - this.gridSize/2) * (cellSize + gap),
                            0
                        );
                        cube.castShadow = true;
                        cube.receiveShadow = true;
                        
                        // Add user data for interaction
                        cube.userData = { row, col, hovered: false };
                        
                        this.scene.add(cube);
                        this.grid[row][col] = { 
                            mesh: cube, 
                            letter: null, 
                            filled: false,
                            row,
                            col
                        };
                    }
                }
                console.log('‚úÖ 3D grid created successfully');

                // Enhanced lighting system
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                console.log('üí° Ambient light added');
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -10;
                directionalLight.shadow.camera.right = 10;
                directionalLight.shadow.camera.top = 10;
                directionalLight.shadow.camera.bottom = -10;
                this.scene.add(directionalLight);
                console.log('üí° Directional light added');

                // Multiple point lights for better illumination
                const pointLight1 = new THREE.PointLight(0x4ecdc4, 0.8, 15);
                pointLight1.position.set(5, 5, 5);
                this.scene.add(pointLight1);

                const pointLight2 = new THREE.PointLight(0x667eea, 0.6, 12);
                pointLight2.position.set(-5, 3, -5);
                this.scene.add(pointLight2);
                console.log('üí° Point lights added');

                // Add subtle fog for depth
                this.scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);
                console.log('üå´Ô∏è Fog added');

                // Setup raycaster for mouse interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                console.log('üéØ Raycaster and mouse setup complete');

                // Animation loop
                this.animate();
                console.log('üîÑ Animation loop started');

                // Add click event
                canvas.addEventListener('click', (event) => this.onCanvasClick(event));
                console.log('üñ±Ô∏è Click event listener added');
                
                // Add mouse move event for hover effects
                canvas.addEventListener('mousemove', (event) => this.onMouseMove(event));
                console.log('üñ±Ô∏è Mouse move event listener added');
                
                console.log('üéâ Enhanced 3D scene initialized successfully');
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Enhanced animation with floating effect
                if (this.scene) {
                    this.scene.rotation.y += 0.002;
                    
                    // Add floating animation to cubes
                    this.grid.forEach(row => {
                        row.forEach(cell => {
                            if (cell.mesh) {
                                cell.mesh.position.y += Math.sin(Date.now() * 0.001 + cell.row + cell.col) * 0.001;
                            }
                        });
                    });
                }
                
                this.renderer.render(this.scene, this.camera);
            }

            onCanvasClick(event) {
                console.log('üñ±Ô∏è Canvas click detected at:', event.clientX, event.clientY);
                
                const rect = event.target.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                console.log('üéØ Mouse coordinates:', this.mouse.x, this.mouse.y);

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children);
                
                console.log('üéØ Intersections found:', intersects.length);

                if (intersects.length > 0) {
                    const clickedCube = intersects[0].object;
                    const userData = clickedCube.userData;
                    
                    console.log('üéØ Clicked cube userData:', userData);
                    
                    if (userData && !this.grid[userData.row][userData.col].filled) {
                        console.log('‚úÖ Valid click - placing letter at row:', userData.row, 'col:', userData.col);
                        this.placeLetter3D(userData.row, userData.col, event);
                    } else {
                        console.log('‚ùå Invalid click - cube already filled or no userData');
                    }
                } else {
                    console.log('‚ùå No intersections found');
                }
            }

            // Add hover effects for 3D cubes
            onMouseMove(event) {
                if (!this.raycaster || !this.mouse) {
                    console.log('‚ö†Ô∏è Raycaster or mouse not initialized');
                    return;
                }
                
                const rect = event.target.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children);

                // Reset all cube colors
                this.grid.forEach(row => {
                    row.forEach(cell => {
                        if (cell.mesh && !cell.filled) {
                            cell.mesh.material.color.setHex(0x2a2a3e);
                            cell.mesh.scale.set(1, 1, 1);
                        }
                    });
                });

                // Highlight hovered cube
                if (intersects.length > 0) {
                    const hoveredCube = intersects[0].object;
                    const userData = hoveredCube.userData;
                    
                    if (userData && !this.grid[userData.row][userData.col].filled) {
                        hoveredCube.material.color.setHex(0x4ecdc4);
                        hoveredCube.scale.set(1.1, 1.1, 1.1);
                    }
                }
            }

            placeLetter3D(row, col, event) {
                console.log('üéØ placeLetter3D() called - row:', row, 'col:', col, 'letters remaining:', this.letters.length);
                
                if (this.letters.length > 0) {
                    const letter = this.letters.shift();
                    console.log('üìù Placing letter:', letter);
                    
                    // Create enhanced 3D text
                    const textGeometry = new THREE.PlaneGeometry(0.8, 0.8);
                    
                    // Create canvas for better text rendering
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 128;
                    canvas.height = 128;
                    
                    // Create gradient background
                    const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
                    gradient.addColorStop(0, '#4ecdc4');
                    gradient.addColorStop(1, '#667eea');
                    context.fillStyle = gradient;
                    context.fillRect(0, 0, 128, 128);
                    
                    // Add text with shadow
                    context.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    context.shadowBlur = 4;
                    context.shadowOffsetX = 2;
                    context.shadowOffsetY = 2;
                    context.fillStyle = '#ffffff';
                    context.font = 'bold 72px Arial';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText(letter, 64, 64);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const textMaterial = new THREE.MeshBasicMaterial({ 
                        map: texture,
                        transparent: true,
                        opacity: 0.95
                    });
                    
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    
                    // Position the text with offset
                    textMesh.position.set(
                        (col - this.gridSize/2) * 1.4,
                        (row - this.gridSize/2) * 1.4,
                        0.8
                    );

                    // Add glow effect
                    const glowGeometry = new THREE.PlaneGeometry(1.2, 1.2);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x4ecdc4,
                        transparent: true,
                        opacity: 0.3
                    });
                    const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                    glowMesh.position.copy(textMesh.position);
                    glowMesh.position.z = 0.7;
                    
                    this.scene.add(glowMesh);
                    this.scene.add(textMesh);
                    
                    this.grid[row][col].letter = textMesh;
                    this.grid[row][col].glow = glowMesh;
                    this.grid[row][col].filled = true;
                    
                    console.log('‚úÖ Letter placed successfully in 3D scene');
                    
                    // Enhanced animation
                    textMesh.scale.set(0, 0, 0);
                    glowMesh.scale.set(0, 0, 0);
                    
                    const animate = () => {
                        textMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.15);
                        glowMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                        
                        if (textMesh.scale.x < 0.95) {
                            requestAnimationFrame(animate);
                        } else {
                            // Add pulse animation
                            this.addPulseAnimation(textMesh);
                        }
                    };
                    animate();
                    
                    // Update cube color when letter is placed
                    const cube = this.grid[row][col].mesh;
                    cube.material.color.setHex(0x4ecdc4);
                    cube.material.opacity = 0.9;
                    
                    this.score += 10;
                    console.log('üìä Score updated:', this.score);
                    
                    this.updateDisplay();
                    this.updateLetterQueue();
                    this.checkWordCompletion();
                    
                    // Enhanced particle effects
                    if (typeof Utils !== 'undefined') {
                        console.log('‚ú® Creating particle effects');
                        Utils.createParticleEffect(
                            event.clientX,
                            event.clientY,
                            8,
                            '#4ecdc4'
                        );
                        Utils.playSound('place', 600, 0.15);
                    } else {
                        console.warn('‚ö†Ô∏è Utils not available for particle effects');
                    }
                } else {
                    console.warn('‚ö†Ô∏è No letters remaining in queue');
                }
            }

            addPulseAnimation(mesh) {
                console.log('üí´ Adding pulse animation to mesh');
                const originalScale = mesh.scale.clone();
                const pulse = () => {
                    const scale = 1 + Math.sin(Date.now() * 0.01) * 0.05;
                    mesh.scale.set(scale, scale, scale);
                    requestAnimationFrame(pulse);
                };
                pulse();
            }

            // Enhanced victory effects for 3D mode
            createVictoryEffect3D(word, positions) {
                positions.forEach((pos, index) => {
                    const cell = this.grid[pos.row][pos.col];
                    if (cell.letter) {
                        // Create explosion effect
                        const explosionGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                        const explosionMaterial = new THREE.MeshBasicMaterial({
                            color: 0xffd700,
                            transparent: true,
                            opacity: 0.8
                        });
                        const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                        explosion.position.copy(cell.letter.position);
                        explosion.position.z += 0.5;
                        
                        this.scene.add(explosion);
                        
                        // Animate explosion
                        const animateExplosion = () => {
                            explosion.scale.multiplyScalar(1.1);
                            explosion.material.opacity -= 0.02;
                            
                            if (explosion.material.opacity > 0) {
                                requestAnimationFrame(animateExplosion);
                            } else {
                                this.scene.remove(explosion);
                            }
                        };
                        animateExplosion();
                        
                        // Pulse the letter
                        this.addPulseAnimation(cell.letter);
                    }
                });
            }

            createGrid() {
                console.log('üèóÔ∏è createGrid() called - gridSize:', this.gridSize);
                
                const grid = document.getElementById('gameGrid');
                console.log('üì¶ Grid container found:', grid);
                
                if (!grid) {
                    console.error('‚ùå gameGrid element not found!');
                    return;
                }
                
                grid.innerHTML = '';
                
                // Remove existing grid classes
                grid.classList.remove('grid-8x8', 'grid-10x10', 'grid-12x12');
                
                // Add the correct grid class based on size
                if (this.gridSize === 8) {
                    grid.classList.add('grid-8x8');
                    console.log('üìê Added grid-8x8 class');
                } else if (this.gridSize === 10) {
                    grid.classList.add('grid-10x10');
                    console.log('üìê Added grid-10x10 class');
                } else if (this.gridSize === 12) {
                    grid.classList.add('grid-12x12');
                    console.log('üìê Added grid-12x12 class');
                }

                for (let i = 0; i < this.gridSize * this.gridSize; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.textContent = '';
                    cell.onclick = () => this.placeLetter(cell);
                    grid.appendChild(cell);
                }
                
                console.log('‚úÖ 2D grid created with', this.gridSize * this.gridSize, 'cells');
            }

            updateLetterQueue() {
                console.log('üîÑ updateLetterQueue() called - letters:', this.letters);
                
                const queue = document.getElementById('letterQueue');
                console.log('üì¶ Letter queue container found:', queue);
                
                if (!queue) {
                    console.error('‚ùå letterQueue element not found!');
                    return;
                }
                
                queue.innerHTML = '';
                
                this.letters.slice(0, 5).forEach((letter, index) => {
                    const letterDiv = document.createElement('div');
                    letterDiv.className = 'queue-letter';
                    letterDiv.textContent = letter;
                    queue.appendChild(letterDiv);
                    console.log('üìù Added letter to queue:', letter, 'at position:', index);
                });
                
                console.log('‚úÖ Letter queue updated');
            }

            placeLetter(cell) {
                console.log('üéØ placeLetter() called - cell:', cell, 'cell text:', cell.textContent);
                
                if (!cell.textContent && this.letters.length > 0) {
                    const letter = this.letters.shift();
                    cell.textContent = letter;
                    cell.classList.add('filled');
                    
                    console.log('üìù Placed letter:', letter, 'in 2D grid');
                    
                    this.score += 10;
                    console.log('üìä Score updated:', this.score);
                    
                    this.updateDisplay();
                    this.updateLetterQueue();
                    this.checkWordCompletion();
                    
                    if (typeof Utils !== 'undefined') {
                        console.log('‚ú® Creating particle effects for 2D');
                        Utils.createParticleEffect(
                            cell.offsetLeft + cell.offsetWidth / 2,
                            cell.offsetTop + cell.offsetHeight / 2,
                            5,
                            '#4ecdc4'
                        );
                        Utils.playSound('place', 600, 0.1);
                    } else {
                        console.warn('‚ö†Ô∏è Utils not available for 2D particle effects');
                    }
                } else {
                    console.log('‚ùå Cannot place letter - cell filled or no letters remaining');
                }
            }

            checkWordCompletion() {
                console.log('üîç checkWordCompletion() called - mode:', this.mode);
                
                if (this.mode === '3d') {
                    console.log('üéÆ Checking 3D word completion');
                    this.checkWordCompletion3D();
                } else {
                    console.log('üì± Checking 2D word completion');
                    this.checkWordCompletion2D();
                }
            }

            checkWordCompletion2D() {
                console.log('üì± checkWordCompletion2D() called');
                
                const directions = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1],           [0, 1],
                    [1, -1],  [1, 0],  [1, 1]
                ];

                const cells = document.querySelectorAll('.grid-cell');
                console.log('üì¶ Found', cells.length, 'grid cells');
                
                const grid = [];
                
                // Convert cells to 2D grid
                for (let row = 0; row < this.gridSize; row++) {
                    grid[row] = [];
                    for (let col = 0; col < this.gridSize; col++) {
                        const index = row * this.gridSize + col;
                        if (cells[index]) {
                            grid[row][col] = cells[index].textContent || '';
                        } else {
                            grid[row][col] = '';
                        }
                    }
                }
                
                console.log('üìê 2D grid created:', grid);

                // Check for words in all directions
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (grid[row][col]) {
                            for (let [dx, dy] of directions) {
                                const word = this.checkWordInDirection(grid, col, row, dx, dy);
                                if (word && this.targetWords.includes(word) && !this.completedWords.includes(word)) {
                                    console.log('üèÜ Word completed in 2D:', word);
                                    this.completeWord(word);
                                }
                            }
                        }
                    }
                }
            }

            checkWordCompletion3D() {
                console.log('üéÆ checkWordCompletion3D() called');
                
                const directions = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1],           [0, 1],
                    [1, -1],  [1, 0],  [1, 1]
                ];

                // Create grid from 3D grid data
                const grid = [];
                for (let row = 0; row < this.gridSize; row++) {
                    grid[row] = [];
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.grid[row] && this.grid[row][col] && this.grid[row][col].letter) {
                            // Extract letter from 3D mesh (simplified)
                            grid[row][col] = this.getLetterFrom3DMesh(this.grid[row][col].letter) || '';
                        } else {
                            grid[row][col] = '';
                        }
                    }
                }
                
                console.log('üìê 3D grid created:', grid);

                // Check for words in all directions
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (grid[row][col]) {
                            for (let [dx, dy] of directions) {
                                const word = this.checkWordInDirection(grid, col, row, dx, dy);
                                if (word && this.targetWords.includes(word) && !this.completedWords.includes(word)) {
                                    console.log('üèÜ Word completed in 3D:', word);
                                    this.completeWord(word);
                                }
                            }
                        }
                    }
                }
            }

            getLetterFrom3DMesh(mesh) {
                console.log('üîç getLetterFrom3DMesh() called for mesh:', mesh);
                // For now, return a placeholder letter
                // In a real implementation, you'd extract the letter from the mesh texture
                return 'A'; // Placeholder
            }

            checkWordInDirection(grid, startCol, startRow, dx, dy) {
                console.log('üîç checkWordInDirection() called - startCol:', startCol, 'startRow:', startRow, 'dx:', dx, 'dy:', dy);
                
                let word = '';
                let col = startCol;
                let row = startRow;
                
                while (col >= 0 && col < this.gridSize && row >= 0 && row < this.gridSize) {
                    const letter = grid[row][col];
                    if (letter) {
                        word += letter;
                    } else {
                        break;
                    }
                    col += dx;
                    row += dy;
                }
                
                console.log('üìù Word found in direction:', word);
                return word;
            }

            completeWord(word) {
                console.log('üèÜ completeWord() called - word:', word);
                
                this.completedWords.push(word);
                this.wordsFound++;
                this.score += word.length * 10;
                
                console.log('üìä Word completion stats - wordsFound:', this.wordsFound, 'score:', this.score);
                
                // Add word to completed list
                const wordList = document.getElementById('wordsFound');
                if (wordList) {
                    const wordItem = document.createElement('li');
                    wordItem.textContent = word;
                    wordItem.classList.add('completed');
                    wordList.appendChild(wordItem);
                    console.log('üìù Added word to completed list:', word);
                }
                
                this.updateDisplay();
                
                // Victory effects
                if (typeof Utils !== 'undefined') {
                    console.log('‚ú® Creating victory effects');
                    Utils.createVictorySparkles();
                    Utils.playSound('complete', 1000, 0.3);
                }
                
                console.log('‚úÖ Word completed successfully');
            }

            levelUp() {
                this.level++;
                
                if (typeof Utils !== 'undefined') {
                    Utils.showModal(
                        'Niveau ' + this.level + ' !',
                        'F√©licitations ! Vous avez atteint le niveau ' + this.level + '.',
                        [{ text: 'Continuer', action: () => this.updateDisplay() }]
                    );
                }
                
                this.updateDisplay();
            }

            selectMode(mode) {
                console.log('üéÆ selectMode() called - mode:', mode);
                
                // Update active button
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.mode === mode) {
                        btn.classList.add('active');
                        console.log('‚úÖ Activated mode button:', btn.textContent);
                    }
                });
                
                this.mode = mode;
                console.log('üéÆ Mode changed to:', this.mode);
                
                // Reinitialize game with new mode
                this.resetGame();
                this.init();
                
                console.log('‚úÖ Mode selection completed');
            }

            selectGrid(size) {
                console.log('üìê selectGrid() called - size:', size);
                
                // Update active button
                document.querySelectorAll('.grid-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (parseInt(btn.dataset.size) === size) {
                        btn.classList.add('active');
                        console.log('‚úÖ Activated grid button:', btn.textContent);
                    }
                });
                
                this.gridSize = size;
                console.log('üìê Grid size changed to:', this.gridSize);
                
                // Reinitialize game with new grid size
                this.resetGame();
                this.init();
                
                console.log('‚úÖ Grid selection completed');
            }

            startGame() {
                console.log('‚ñ∂Ô∏è startGame() called');
                
                if (!this.gameRunning) {
                    this.gameRunning = true;
                    this.startTime = Date.now();
                    console.log('‚è∞ Game started at:', this.startTime);
                    
                    // Update button text
                    const startButton = document.getElementById('startBtn');
                    if (startButton) {
                        startButton.innerHTML = '<i class="fas fa-pause"></i> Pause';
                        startButton.onclick = () => this.pauseGame();
                    }
                    
                    console.log('‚úÖ Game started successfully');
                } else {
                    console.log('‚ö†Ô∏è Game already running');
                }
            }

            pauseGame() {
                console.log('‚è∏Ô∏è pauseGame() called');
                
                if (this.gameRunning) {
                    this.gameRunning = false;
                    console.log('‚è∞ Game paused');
                    
                    // Update button text
                    const pauseButton = document.getElementById('pauseBtn');
                    if (pauseButton) {
                        pauseButton.innerHTML = '<i class="fas fa-play"></i> D√©marrer';
                        pauseButton.onclick = () => this.startGame();
                    }
                    
                    console.log('‚úÖ Game paused successfully');
                } else {
                    console.log('‚ö†Ô∏è Game not running');
                }
            }

            resetGame() {
                console.log('üîÑ resetGame() called');
                
                this.gameRunning = false;
                this.paused = false;
                this.score = 0;
                this.level = 1;
                this.wordsFound = 0;
                this.startTime = null;
                this.letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
                this.completedWords = [];
                
                console.log('üîÑ Game state reset');
                
                // Clear grid
                if (this.mode === '3d') {
                    console.log('üéÆ Clearing 3D grid');
                    this.grid.forEach(row => {
                        row.forEach(cell => {
                            if (cell.letter) {
                                this.scene.remove(cell.letter);
                                cell.letter = null;
                            }
                            if (cell.glow) {
                                this.scene.remove(cell.glow);
                                cell.glow = null;
                            }
                            cell.filled = false;
                            cell.mesh.material.color.setHex(0x2a2a3e);
                            cell.mesh.material.opacity = 0.8;
                        });
                    });
                } else {
                    console.log('üì± Clearing 2D grid');
                    const cells = document.querySelectorAll('.grid-cell');
                    cells.forEach(cell => {
                        cell.textContent = '';
                        cell.classList.remove('filled');
                    });
                }
                
                this.updateDisplay();
                this.updateLetterQueue();
                
                // Reset button text
                const startButton = document.getElementById('startBtn');
                if (startButton) {
                    startButton.innerHTML = '<i class="fas fa-play"></i> D√©marrer';
                    startButton.onclick = () => this.startGame();
                }
                
                console.log('‚úÖ Game reset successfully');
            }

            updateGame() {
                // Update game logic here
                const currentTime = Date.now();
                if (this.startTime) {
                    const elapsed = Math.floor((currentTime - this.startTime) / 1000);
                    document.getElementById('timeValue').textContent = 
                        `${Math.floor(elapsed / 60)}:${(elapsed % 60).toString().padStart(2, '0')}`;
                }
            }

            updateDisplay() {
                console.log('üìä updateDisplay() called - score:', this.score, 'level:', this.level);
                
                const scoreElement = document.getElementById('scoreValue');
                const levelElement = document.getElementById('levelValue');
                const timeElement = document.getElementById('timeValue');
                const wordsElement = document.getElementById('wordsValue');
                
                console.log('üì¶ Display elements found:', {
                    score: scoreElement,
                    level: levelElement,
                    time: timeElement,
                    words: wordsElement
                });
                
                if (scoreElement) scoreElement.textContent = this.score;
                if (levelElement) levelElement.textContent = this.level;
                
                // Update time if game is running
                if (this.gameRunning && this.startTime) {
                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    if (timeElement) timeElement.textContent = `${Math.floor(elapsed / 60)}:${(elapsed % 60).toString().padStart(2, '0')}`;
                }
                
                if (wordsElement) wordsElement.textContent = this.wordsFound;
                
                console.log('‚úÖ Display updated');
            }

            updateWordList() {
                const wordList = document.querySelectorAll('.word-list li');
                wordList.forEach((item, index) => {
                    const word = this.targetWords[index];
                    if (this.completedWords.includes(word)) {
                        item.classList.add('completed');
                    } else {
                        item.classList.remove('completed');
                    }
                });
            }

            setupEventListeners() {
                console.log('üéØ setupEventListeners() called');
                
                // Game control buttons
                const startBtn = document.getElementById('startBtn');
                const pauseBtn = document.getElementById('pauseBtn');
                const resetBtn = document.getElementById('resetBtn');
                
                console.log('üéÆ Control buttons found:', {
                    start: startBtn,
                    pause: pauseBtn,
                    reset: resetBtn
                });
                
                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        console.log('üñ±Ô∏è Start button clicked');
                        this.startGame();
                    });
                }
                
                if (pauseBtn) {
                    pauseBtn.addEventListener('click', () => {
                        console.log('üñ±Ô∏è Pause button clicked');
                        this.pauseGame();
                    });
                }
                
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        console.log('üñ±Ô∏è Reset button clicked');
                        this.resetGame();
                    });
                }
                
                // Mode selection
                const modeButtons = document.querySelectorAll('.mode-btn');
                console.log('üéÆ Mode buttons found:', modeButtons.length);
                
                modeButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        console.log('üñ±Ô∏è Mode button clicked:', btn.textContent);
                        this.selectMode(btn.dataset.mode);
                    });
                });
                
                // Grid size selection
                const gridButtons = document.querySelectorAll('.grid-btn');
                console.log('üìê Grid buttons found:', gridButtons.length);
                
                gridButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        console.log('üñ±Ô∏è Grid button clicked:', btn.textContent);
                        this.selectGrid(parseInt(btn.dataset.size));
                    });
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (event) => {
                    console.log('‚å®Ô∏è Key pressed:', event.key);
                    
                    switch(event.key) {
                        case ' ':
                            console.log('‚è∏Ô∏è Space key - toggling pause');
                            event.preventDefault();
                            if (this.gameRunning) {
                                this.pauseGame();
                            } else {
                                this.startGame();
                            }
                            break;
                        case 'r':
                        case 'R':
                            console.log('üîÑ R key - resetting game');
                            event.preventDefault();
                            this.resetGame();
                            break;
                        case 's':
                        case 'S':
                            console.log('‚ñ∂Ô∏è S key - starting game');
                            event.preventDefault();
                            this.startGame();
                            break;
                    }
                });
                
                console.log('‚úÖ Event listeners setup completed');
            }
        }

        // Global game instance
        let game3D;

        // Global functions for button controls
        function selectMode(mode) {
            if (game3D) game3D.selectMode(mode);
        }

        function selectGrid(size) {
            if (game3D) game3D.selectGrid(size);
        }

        function startGame() {
            if (game3D) game3D.startGame();
        }

        function resetGame() {
            if (game3D) game3D.resetGame();
        }

        function pauseGame() {
            if (game3D) game3D.pauseGame();
        }

        function clearGrid() {
            if (game3D) game3D.clearGrid();
        }

        // Initialize 3D game when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ DOM Content Loaded - Initializing 3D game...');
            
            // Check if Three.js is available
            if (typeof THREE === 'undefined') {
                console.error('‚ùå THREE.js not loaded!');
                return;
            }
            
            console.log('‚úÖ THREE.js available, creating Game3D instance...');
            game3D = new Game3D();
            console.log('üéÆ 3D Game initialized successfully');
            
            // Check if Utils is available
            if (typeof Utils !== 'undefined') {
                console.log('‚úÖ Utils available for sound and particle effects');
            } else {
                console.warn('‚ö†Ô∏è Utils not available - sound and particle effects disabled');
            }
        });

        // Fullscreen function
        function toggleFullScreen() {
            console.log('üñ•Ô∏è toggleFullScreen() called');
            
            const gameContainer = document.querySelector('.game-container');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            
            console.log('üì¶ Game container found:', gameContainer);
            console.log('üîò Fullscreen button found:', fullscreenBtn);
            
            if (gameContainer.classList.contains('fullscreen')) {
                console.log('üì§ Exiting fullscreen mode');
                exitFullScreen();
            } else {
                console.log('üì• Entering fullscreen mode');
                enterFullScreen();
            }
        }

        function enterFullScreen() {
            console.log('üì• enterFullScreen() called');
            
            const gameContainer = document.querySelector('.game-container');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            
            gameContainer.classList.add('fullscreen');
            fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i> Sortir';
            
            // Add exit button
            const exitBtn = document.createElement('div');
            exitBtn.className = 'fullscreen-exit';
            exitBtn.innerHTML = '<i class="fas fa-times"></i>';
            exitBtn.onclick = exitFullScreen;
            gameContainer.appendChild(exitBtn);
            
            // Resize 3D canvas for full screen
            const canvas = document.getElementById('threejsCanvas');
            console.log('üé® Canvas found for fullscreen:', canvas);
            
            if (canvas && game3D && game3D.renderer) {
                const container = gameContainer.querySelector('.game-grid-container');
                const containerRect = container.getBoundingClientRect();
                const maxSize = Math.min(containerRect.width, containerRect.height) * 0.9;
                
                console.log('üìê Fullscreen dimensions:', {
                    containerWidth: containerRect.width,
                    containerHeight: containerRect.height,
                    maxSize: maxSize
                });
                
                canvas.width = maxSize;
                canvas.height = maxSize;
                game3D.renderer.setSize(maxSize, maxSize);
                
                // Update camera aspect ratio
                if (game3D.camera) {
                    game3D.camera.aspect = maxSize / maxSize;
                    game3D.camera.updateProjectionMatrix();
                    console.log('üì∑ Camera aspect ratio updated for fullscreen');
                }
            } else {
                console.warn('‚ö†Ô∏è Canvas or renderer not available for fullscreen resize');
            }
            
            console.log('‚úÖ Entered full screen mode');
        }

        function exitFullScreen() {
            console.log('üì§ exitFullScreen() called');
            
            const gameContainer = document.querySelector('.game-container');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            
            gameContainer.classList.remove('fullscreen');
            fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> Plein √âcran';
            
            // Remove exit button
            const exitBtn = gameContainer.querySelector('.fullscreen-exit');
            if (exitBtn) {
                exitBtn.remove();
                console.log('‚ùå Exit button removed');
            }
            
            // Reset 3D canvas size
            const canvas = document.getElementById('threejsCanvas');
            console.log('üé® Canvas found for exit fullscreen:', canvas);
            
            if (canvas && game3D && game3D.renderer) {
                canvas.width = 500;
                canvas.height = 500;
                game3D.renderer.setSize(500, 500);
                
                // Update camera aspect ratio
                if (game3D.camera) {
                    game3D.camera.aspect = 1;
                    game3D.camera.updateProjectionMatrix();
                    console.log('üì∑ Camera aspect ratio reset');
                }
            } else {
                console.warn('‚ö†Ô∏è Canvas or renderer not available for fullscreen exit resize');
            }
            
            console.log('‚úÖ Exited full screen mode');
        }

        // Keyboard shortcut for full screen (F11)
        document.addEventListener('keydown', function(event) {
            if (event.key === 'F11') {
                console.log('‚å®Ô∏è F11 key pressed - toggling fullscreen');
                event.preventDefault();
                toggleFullScreen();
            }
        });
    </script>
</body>
</html>