<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/base-theme.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Letters Cascade Challenge - Three.js 3D Version</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎨</text></svg>">
    <!-- FontAwesome CDN with fallback -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/shared.css">
    <link rel="stylesheet" href="css/unified-colors.css">
    <link rel="stylesheet" href="css/theme-dark.css">
    <link rel="stylesheet" href="css/unified-layout.css">
    <!-- Add SEO meta tags and analytics script -->
    <meta name="description" content="Version 3D du jeu Letters Cascade Challenge, optimisée pour une expérience immersive en français." />
    <meta name="keywords" content="jeu 3D, lettres, cascade, Babylon.js, performance" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXX-X"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-XXXXX-X');
    </script>
    <style>
        /* Using unified color system from unified-colors.css */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--spacing-lg);
        }

        /* Page Layout */
        .page-layout {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: var(--spacing-lg);
            max-width: 1600px;
            margin: 0 auto;
            padding: var(--spacing-lg);
        }

        /* Game-specific styles */
        .game-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(25px);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            box-shadow: var(--shadow-xl);
            border: 1px solid rgba(255, 255, 255, 0.3);
            margin-bottom: var(--spacing-xl);
            position: relative;
            overflow: hidden;
        }

        .game-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at top left, rgba(102, 126, 234, 0.05) 0%, transparent 60%);
            pointer-events: none;
        }

        /* Navigation Sidebar */
        .nav-sidebar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(25px);
            border-radius: var(--radius-xl);
            padding: var(--spacing-lg);
            box-shadow: var(--shadow-xl);
            border: 1px solid rgba(255, 255, 255, 0.3);
            height: fit-content;
            position: sticky;
            top: var(--spacing-lg);
        }

        .nav-links {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .nav-links a {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm) var(--spacing-md);
            color: var(--gray-700);
            text-decoration: none;
            border-radius: var(--radius-md);
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .nav-links a:hover,
        .nav-links a.active {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            transform: translateX(5px);
        }

        .nav-links a i {
            width: 20px;
            text-align: center;
        }

        /* Main Content */
        .main-content {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-lg);
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: var(--spacing-lg);
            background: rgba(255, 255, 255, 0.95);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .header h1 {
            color: var(--primary-color);
            font-size: 2.5rem;
            font-weight: 900;
            margin-bottom: var(--spacing-md);
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color), var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: var(--gray-600);
            font-size: 1.1rem;
            max-width: 600px;
            margin: 0 auto;
        }

        /* Canvas Container */
        .canvas-container {
            position: relative;
            display: inline-block;
            margin: var(--spacing-lg) 0;
            border-radius: var(--radius-lg);
            overflow: hidden;
            box-shadow: var(--shadow-lg);
            background: #000;
        }

        #threeCanvas {
            display: block;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-lg);
            background: var(--gradient-bg-primary);
        }

        /* Game Controls */
        .game-controls {
            margin-top: var(--spacing-lg);
            display: flex;
            justify-content: center;
            gap: var(--spacing-md);
            flex-wrap: wrap;
        }

        .control-btn {
            padding: var(--spacing-sm) var(--spacing-lg);
            font-size: 1rem;
            font-weight: 600;
            border-radius: var(--radius-md);
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            color: var(--gray-700);
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .control-btn.primary {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-color: var(--primary-color);
        }

        .control-btn.primary:hover {
            background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        /* Game Info */
        .game-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-md);
            margin-top: var(--spacing-lg);
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.9);
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
            box-shadow: var(--shadow-md);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .info-panel h3 {
            color: var(--primary-color);
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
        }

        .info-panel p {
            color: var(--gray-600);
            font-size: 0.9rem;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: var(--spacing-md);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
        }

        .loading-progress {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: var(--spacing-md);
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .game-controls {
                flex-direction: column;
                align-items: center;
            }
            
            .game-info {
                grid-template-columns: 1fr;
            }
        }

        /* Game Status Indicator */
        .game-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm) var(--spacing-md);
            box-shadow: var(--shadow-md);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            font-weight: 600;
            font-size: 0.9rem;
        }

        .game-status.playing {
            color: var(--success-color);
        }

        .game-status.paused {
            color: var(--warning-color);
        }

        .game-status.game-over {
            color: var(--danger-color);
        }
    </style>
</head>
<body data-theme="dark">
    
    
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Chargement du jeu Three.js 3D...</div>
        <div class="loading-progress">
            <div class="loading-progress-bar" id="loadingProgressBar"></div>
        </div>
    </div>

    <!-- Game Status Indicator -->
    <div id="gameStatus" class="game-status" style="display: none;">
        <i class="fas fa-circle"></i>
        <span id="gameStatusText">Prêt</span>
    </div>

    <!-- Unified Navigation Header -->
    <header class="unified-nav-header">
        <nav class="unified-nav-container">
            <a href="index.html" class="unified-nav-logo">
                <i class="fas fa-gamepad"></i>
                <span>LCC</span>
            </a>
            
            <button role="button" />
                <span></span>
                <span></span>
                <span></span>
            </button>

            <ul class="unified-nav-menu" id="nav-menu" role="menubar">
                <li class="unified-nav-item" role="none">
                    <a href="index.html" class="unified-nav-link" role="menuitem">
                        <i class="fas fa-home"></i>
                        <span>Accueil</span>
                    </a>
                </li>
                <li class="unified-nav-item" role="none">
                    <a href="unified-3d-game.html" class="unified-nav-link" role="menuitem">
                        <i class="fas fa-cube"></i>
                        <span>3D Babylon.js</span>
                    </a>
                </li>
                <li class="unified-nav-item" role="none">
                    <a href="threejs-3d-game.html" class="unified-nav-link" role="menuitem" aria-current="page">
                        <i class="fas fa-cube"></i>
                        <span>3D Three.js</span>
                    </a>
                </li>
                <li class="unified-nav-item" role="none">
                    <a href="classic-2d-game.html" class="unified-nav-link" role="menuitem">
                        <i class="fas fa-square"></i>
                        <span>2D Classique</span>
                    </a>
                </li>
                <li class="unified-nav-item" role="none">
                    <a href="rules.html" class="unified-nav-link" role="menuitem">
                        <i class="fas fa-book"></i>
                        <span>Règles</span>
                    </a>
                </li>
                <li class="unified-nav-item" role="none">
                    <a href="docs/index.html" class="unified-nav-link" role="menuitem">
                        <i class="fas fa-file-alt"></i>
                        <span>Documentation</span>
                    </a>
                </li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main class="unified-page-layout">
        <!-- Header -->
        <div class="unified-glass-panel">
            <h1 class="unified-hero-title title-gradient-test">🌊 Letters Cascade Challenge - Three.js 3D</h1>
            <p class="unified-hero-subtitle">Version 3D avec Three.js, environnement naturel avec arbres, rochers, cascade et rivière pour une expérience immersive.</p>
        </div>

        <!-- Game Container -->
        <div class="unified-game-container" id="game-section">
            <h2 class="unified-text-center">🌲 Jeu Three.js 3D - Environnement Naturel</h2>
            
            <!-- Canvas Container -->
            <div class="canvas-container">
                <canvas id="threeCanvas" width="800" height="600"></canvas>
            </div>

            <!-- Game Controls -->
            <div class="unified-text-center unified-mt-lg">
                <button role="button" /><i class="fas fa-play"></i> Démarrer</button>
                <button role="button" /><i class="fas fa-pause"></i> Pause</button>
                <button role="button" /><i class="fas fa-redo"></i> Recommencer</button>
                <button role="button" /><i class="fas fa-expand"></i> Plein Écran</button>
                <button role="button" /><i class="fas fa-tree"></i> Environnement</button>
                <button role="button" /><i class="fas fa-water"></i> Cascade</button>
            </div>

            <!-- Game Info -->
            <div class="unified-grid unified-grid-3 unified-mt-lg">
                <div class="unified-card">
                    <h3 class="game-version-title">🎯 Contrôles 3D</h3>
                    <p class="game-version-description">Souris: Rotation | Molette: Zoom | Clic: Interaction | R: Réinitialiser caméra | P: Pause</p>
                </div>
                <div class="unified-card">
                    <h3 class="game-version-title">🌲 Environnement Naturel</h3>
                    <p class="game-version-description">Arbres, rochers, cascade et grande rivière pour une expérience immersive</p>
                </div>
                <div class="unified-card">
                    <h3 class="game-version-title">📊 Système de Score 3D</h3>
                    <p class="game-version-description">3 lettres: 125 pts | 4 lettres: 312 pts | 5 lettres: 625 pts | 6+ lettres: 1250 pts + bonus</p>
                </div>
                <div class="unified-card">
                    <h3 class="game-version-title">🔥 Combo 3D</h3>
                    <p class="game-version-description">+75% par mot enchaîné (bonus 3D)</p>
                </div>
                <div class="unified-card">
                    <h3 class="game-version-title">📈 Progression 3D</h3>
                    <p class="game-version-description">Niveau 1: 1250 pts | Niveau 2: 3125 pts | Niveau 3: 6250 pts</p>
                </div>
            </div>
        </div>

        <!-- Controls Section -->
        <div class="unified-glass-panel unified-mb-xl">
            <h2 class="unified-text-center"><i class="fas fa-cog"></i> Contrôles</h2>
            <p class="unified-text-center unified-mb-lg">Utilisez votre souris et votre clavier pour contrôler le jeu:</p>
            <div class="unified-grid unified-grid-2">
                <div class="unified-card">
                    <h3 class="game-version-title">Souris</h3>
                    <ul class="game-version-features">
                        <li>Rotation de la caméra</li>
                        <li>Molette: Zoom</li>
                        <li>Clic gauche: Interagir avec les lettres</li>
                        <li>Clic droit: Déplacer la caméra</li>
                    </ul>
                </div>
                <div class="unified-card">
                    <h3 class="game-version-title">Clavier</h3>
                    <ul class="game-version-features">
                        <li>P: Pause/Reprise du jeu</li>
                        <li>R: Recommencer le niveau</li>
                        <li>F: Plein écran</li>
                        <li>E: Basculer l'environnement</li>
                        <li>W: Basculer la cascade</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Info Section -->
        <div class="unified-glass-panel unified-mb-xl">
            <h2 class="unified-text-center"><i class="fas fa-info-circle"></i> À Propos</h2>
            <p class="unified-text-center unified-mb-lg">Ce jeu est une version 3D de l'édition "Lettres Cascade Challenge" avec un environnement naturel immersif. Votre objectif est de former des mots en plaçant les lettres tombantes sur une grille, entouré d'arbres, de rochers, d'une cascade et d'une grande rivière.</p>
            <p class="unified-text-center">Le jeu est conçu pour être relaxant et amusant, avec des effets visuels immersifs et une interface intuitive dans un environnement naturel.</p>
        </div>

        <!-- Stats Section -->
        <div class="unified-glass-panel unified-mb-xl">
            <h2 class="unified-text-center"><i class="fas fa-chart-bar"></i> Statistiques</h2>
            <div class="unified-grid unified-grid-4">
                <div class="unified-card">
                    <span class="stat-label">Score</span>
                    <span class="stat-value" id="gameScore">0</span>
                </div>
                <div class="unified-card">
                    <span class="stat-label">Niveau</span>
                    <span class="stat-value" id="gameLevel">1</span>
                </div>
                <div class="unified-card">
                    <span class="stat-label">Combo</span>
                    <span class="stat-value" id="gameCombo">1</span>
                </div>
                <div class="unified-card">
                    <span class="stat-label">Mots</span>
                    <span class="stat-value" id="gameWords">0</span>
                </div>
            </div>
        </div>

        <!-- Letter Queue Section -->
        <div class="unified-glass-panel unified-mb-xl">
            <h2 class="unified-text-center"><i class="fas fa-list"></i> File d'attente</h2>
            <div class="unified-text-center" id="letterQueue">
                <div class="letter-item" data-letter="A">
                    <span class="letter-text">A</span>
                </div>
                <div class="letter-item" data-letter="B">
                    <span class="letter-text">B</span>
                </div>
                <div class="letter-item" data-letter="C">
                    <span class="letter-text">C</span>
                </div>
                <div class="letter-item" data-letter="D">
                    <span class="letter-text">D</span>
                </div>
                <div class="letter-item" data-letter="E">
                    <span class="letter-text">E</span>
                </div>
            </div>
        </div>
    </main>

    <!-- Enhanced Three.js CDN with multiple fallbacks -->
    <script>
        // Enhanced Three.js loader with multiple CDN fallbacks
        function loadThreeJS() {
            const cdnUrls = [
                'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
                'https://unpkg.com/three@0.128.0/build/three.min.js',
                'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js',
                'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.128.0/three.min.js'
            ];
            
            function tryLoadThree(index = 0) {
                if (index >= cdnUrls.length) {
                    console.error('❌ All Three.js CDN sources failed');
                    return;
                }
                
                const script = document.createElement('script');
                script.src = cdnUrls[index];
                script.type = 'text/javascript';
                script.crossOrigin = 'anonymous';
                
                const timeout = setTimeout(() => {
                    console.warn('⏰ Timeout loading Three.js from:', cdnUrls[index]);
                    script.onerror();
                }, 5000);
                
                script.onload = () => {
                    clearTimeout(timeout);
                    console.log('✅ Three.js loaded from:', cdnUrls[index]);
                    setTimeout(() => {
                        if (typeof THREE !== 'undefined' && THREE.Scene && THREE.PerspectiveCamera && THREE.WebGLRenderer) {
                            console.log('✅ Three.js classes verified');
                        } else {
                            console.warn('⚠️ Three.js loaded but classes not available, trying next CDN');
                            tryLoadThree(index + 1);
                        }
                    }, 100);
                };
                
                script.onerror = () => {
                    clearTimeout(timeout);
                    console.warn('❌ Failed to load Three.js from:', cdnUrls[index]);
                    tryLoadThree(index + 1);
                };
                
                document.head.appendChild(script);
            }
            
            tryLoadThree();
        }
        
        // Load Three.js immediately
        loadThreeJS();
    </script>
    <script src="js/navigation.js"></script>
    <script type="module" src="js/bridge/GameLogicBridge.js"></script>
    
    <script>
        // Global variables for Three.js game
        let scene, camera, renderer, controls;
        let gameRunning = false;
        let environmentActive = true;
        let waterfallActive = true;
        
        // Environmental elements
        let trees = [];
        let rocks = [];
        let waterfall = null;
        let river = null;
        let ground = null;
        
        // Game state variables
        let gameScore = 0;
        let gameLevel = 1;
        let gameCombo = 0;
        let gameWords = 0;
        let letterQueue = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
        let targetWords = ['CHAT', 'MAIN', 'PIED', 'TETE', 'BRAS'];
        let placedLetters = [];
        let currentFallingLetter = null;
        
        // Initialize Three.js game
        async function initializeThreeJSGame() {
            console.log('🌲 Initializing Three.js game with natural environment...');
            
            try {
                // Simulate loading progress
                let progress = 0;
                const progressBar = document.getElementById('loadingProgressBar');
                const loadingInterval = setInterval(() => {
                    progress += Math.random() * 15;
                    if (progress > 100) progress = 100;
                    progressBar.style.width = progress + '%';
                    
                    if (progress >= 100) {
                        clearInterval(loadingInterval);
                        setTimeout(() => {
                            document.getElementById('loadingScreen').style.display = 'none';
                            console.log('✅ Loading screen hidden');
                        }, 500);
                    }
                }, 100);

                // Wait for DOM to be fully loaded
                if (document.readyState !== 'complete') {
                    await new Promise(resolve => {
                        document.addEventListener('DOMContentLoaded', resolve);
                    });
                }

                // Check if Three.js is available with retry mechanism
                let threeJSLoaded = false;
                let retryCount = 0;
                const maxRetries = 10;
                
                while (!threeJSLoaded && retryCount < maxRetries) {
                    if (typeof THREE !== 'undefined') {
                        threeJSLoaded = true;
                        console.log('✅ Three.js library found');
                    } else {
                        console.log(`🔄 Waiting for Three.js to load... (${retryCount + 1}/${maxRetries})`);
                        await new Promise(resolve => setTimeout(resolve, 500));
                        retryCount++;
                    }
                }
                
                if (!threeJSLoaded) {
                    throw new Error('Three.js library not loaded after multiple retries. Check CDN connection.');
                }

                // Check if canvas element exists
                const canvas = document.getElementById('threeCanvas');
                if (!canvas) {
                    throw new Error('Three.js canvas element #threeCanvas not found');
                }

                console.log('✅ Canvas element found');

                // Initialize Three.js scene with environment
                initializeThreeJS();
                
                console.log('✅ Three.js game with environment initialized');
            } catch (error) {
                console.error('❌ Error in initializeThreeJSGame:', error);
                const loadingText = document.querySelector('.loading-text');
                if (loadingText) {
                    loadingText.textContent = 'Erreur de chargement: ' + error.message;
                    loadingText.style.color = 'var(--error-500)';
                }
            }
        }

        // Initialize Three.js scene with natural environment
        function initializeThreeJS() {
            try {
                const canvas = document.getElementById('threeCanvas');
                
                // Ensure canvas has proper dimensions
                if (!canvas.width || !canvas.height) {
                    canvas.width = 800;
                    canvas.height = 600;
                    console.log('✅ Canvas dimensions set to 800x600');
                }
                
                // Create scene
                scene = new THREE.Scene();
                console.log('✅ Scene created');
                
                // Create camera with proper aspect ratio
                const aspectRatio = canvas.width / canvas.height;
                camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
                camera.position.set(0, 10, 15);
                console.log('✅ Camera created with aspect ratio:', aspectRatio);
                
                // Create renderer with proper settings
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    antialias: true,
                    alpha: true,
                    preserveDrawingBuffer: true
                });
                renderer.setSize(canvas.width, canvas.height);
                renderer.setClearColor(0x87CEEB, 0.8); // Sky blue
                renderer.setPixelRatio(window.devicePixelRatio);
                console.log('✅ Renderer created with size:', canvas.width, 'x', canvas.height);
                
                // Create natural environment
                createNaturalEnvironment();
                
                // Create game elements
                createGameElements();
                
                // Add lights
                addLights();
                
                // Start render loop
                animate();
                
                console.log('✅ Three.js scene with environment initialized successfully');
                
            } catch (error) {
                console.error('❌ Error initializing Three.js scene:', error);
                throw error;
            }
        }

        // Create natural environment (trees, rocks, waterfall, river)
        function createNaturalEnvironment() {
            try {
                // Create ground
                createGround();
                
                // Create trees
                createTrees();
                
                // Create rocks
                createRocks();
                
                // Create waterfall
                createWaterfall();
                
                // Create river
                createRiver();
                
                console.log('✅ Natural environment created');
            } catch (error) {
                console.error('❌ Error creating natural environment:', error);
            }
        }

        // Create ground
        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x228B22, // Forest green
                transparent: true,
                opacity: 0.9
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            scene.add(ground);
            
            // Add grass texture
            const grassGeometry = new THREE.PlaneGeometry(50, 50);
            const grassMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x32CD32, // Lime green
                transparent: true,
                opacity: 0.3
            });
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.rotation.x = -Math.PI / 2;
            grass.position.y = -1.99;
            scene.add(grass);
        }

        // Create trees
        function createTrees() {
            const treePositions = [
                { x: -15, z: -15 },
                { x: 15, z: -15 },
                { x: -15, z: 15 },
                { x: 15, z: 15 },
                { x: -10, z: -20 },
                { x: 10, z: -20 },
                { x: -20, z: -10 },
                { x: 20, z: -10 },
                { x: -20, z: 10 },
                { x: 20, z: 10 },
                { x: -10, z: 20 },
                { x: 10, z: 20 }
            ];
            
            treePositions.forEach((pos, index) => {
                const tree = createTree();
                tree.position.set(pos.x, 0, pos.z);
                scene.add(tree);
                trees.push(tree);
            });
        }

        // Create individual tree
        function createTree() {
            const treeGroup = new THREE.Group();
            
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 4, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Saddle brown
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2;
            treeGroup.add(trunk);
            
            // Tree foliage (multiple layers)
            const foliageColors = [0x228B22, 0x32CD32, 0x90EE90]; // Forest green, lime green, light green
            for (let i = 0; i < 3; i++) {
                const foliageGeometry = new THREE.SphereGeometry(2 + i * 0.5, 8, 6);
                const foliageMaterial = new THREE.MeshLambertMaterial({ 
                    color: foliageColors[i],
                    transparent: true,
                    opacity: 0.8
                });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = 4 + i * 1.5;
                treeGroup.add(foliage);
            }
            
            return treeGroup;
        }

        // Create rocks
        function createRocks() {
            const rockPositions = [
                { x: -8, z: -8, scale: 1.5 },
                { x: 8, z: -8, scale: 1.2 },
                { x: -8, z: 8, scale: 1.8 },
                { x: 8, z: 8, scale: 1.3 },
                { x: -5, z: -12, scale: 1.0 },
                { x: 5, z: -12, scale: 1.4 },
                { x: -12, z: -5, scale: 1.1 },
                { x: 12, z: -5, scale: 1.6 }
            ];
            
            rockPositions.forEach((pos, index) => {
                const rock = createRock();
                rock.position.set(pos.x, -1, pos.z);
                rock.scale.set(pos.scale, pos.scale, pos.scale);
                scene.add(rock);
                rocks.push(rock);
            });
        }

        // Create individual rock
        function createRock() {
            const rockGeometry = new THREE.DodecahedronGeometry(1, 0);
            const rockMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x696969, // Dim gray
                transparent: true,
                opacity: 0.9
            });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            
            // Random rotation for variety
            rock.rotation.x = Math.random() * Math.PI;
            rock.rotation.y = Math.random() * Math.PI;
            rock.rotation.z = Math.random() * Math.PI;
            
            return rock;
        }

        // Create waterfall
        function createWaterfall() {
            waterfall = new THREE.Group();
            
            // Waterfall base (cliff)
            const cliffGeometry = new THREE.BoxGeometry(3, 8, 2);
            const cliffMaterial = new THREE.MeshLambertMaterial({ color: 0x708090 }); // Slate gray
            const cliff = new THREE.Mesh(cliffGeometry, cliffMaterial);
            cliff.position.set(-12, 2, 0);
            waterfall.add(cliff);
            
            // Waterfall stream
            const waterGeometry = new THREE.BoxGeometry(0.5, 8, 0.3);
            const waterMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x00BFFF, // Deep sky blue
                transparent: true,
                opacity: 0.7
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.position.set(-12, 2, 0);
            waterfall.add(water);
            
            // Water particles (simplified)
            for (let i = 0; i < 20; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                const particleMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x00BFFF,
                    transparent: true,
                    opacity: 0.6
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(
                    -12 + (Math.random() - 0.5) * 0.5,
                    6 - Math.random() * 8,
                    (Math.random() - 0.5) * 0.3
                );
                waterfall.add(particle);
            }
            
            scene.add(waterfall);
        }

        // Create river
        function createRiver() {
            river = new THREE.Group();
            
            // River bed
            const riverGeometry = new THREE.BoxGeometry(20, 0.5, 3);
            const riverMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x000080, // Navy blue
                transparent: true,
                opacity: 0.8
            });
            const riverBed = new THREE.Mesh(riverGeometry, riverMaterial);
            riverBed.position.set(0, -1.75, -15);
            river.add(riverBed);
            
            // River water surface
            const waterSurfaceGeometry = new THREE.PlaneGeometry(20, 3);
            const waterSurfaceMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x1E90FF, // Dodger blue
                transparent: true,
                opacity: 0.6
            });
            const waterSurface = new THREE.Mesh(waterSurfaceGeometry, waterSurfaceMaterial);
            waterSurface.rotation.x = -Math.PI / 2;
            waterSurface.position.set(0, -1.5, -15);
            river.add(waterSurface);
            
            // River banks
            const bankGeometry = new THREE.BoxGeometry(20, 0.5, 1);
            const bankMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Saddle brown
            
            const leftBank = new THREE.Mesh(bankGeometry, bankMaterial);
            leftBank.position.set(0, -1.75, -16.5);
            river.add(leftBank);
            
            const rightBank = new THREE.Mesh(bankGeometry, bankMaterial);
            rightBank.position.set(0, -1.75, -13.5);
            river.add(rightBank);
            
            scene.add(river);
        }

        // Create game elements
        function createGameElements() {
            try {
                // Create game grid
                createGameGrid();
                
                // Create initial letters
                createInitialLetters();
                
                console.log('✅ Game elements created');
            } catch (error) {
                console.error('❌ Error creating game elements:', error);
            }
        }

        // Create game grid
        function createGameGrid() {
            const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
            gridHelper.position.y = -1.99;
            scene.add(gridHelper);
        }

        // Create initial letters
        function createInitialLetters() {
            const letters = ['A', 'B', 'C'];
            letters.forEach((letter, index) => {
                const letterMesh = createLetterMesh(letter);
                if (letterMesh) {
                    letterMesh.position.set(index * 2 - 2, 0, 0);
                    scene.add(letterMesh);
                }
            });
        }

        // Create letter mesh as an approximate geometric glyph
        function createLetterMesh(letter) {
            const group = new THREE.Group();
            const color = getLetterColor(letter);
            const material = new THREE.MeshLambertMaterial({ color, transparent: true, opacity: 0.95 });
            const depth = 0.2;

            function makeBar(w, h, x, y, rotZ = 0) {
                const geom = new THREE.BoxGeometry(w, h, depth);
                const bar = new THREE.Mesh(geom, material);
                bar.position.set(x, y, 0);
                bar.rotation.z = rotZ;
                bar.castShadow = true;
                bar.receiveShadow = true;
                group.add(bar);
                return bar;
            }

            const L = (letter || 'A').toUpperCase();
            const t = 0.18; // thickness

            switch (L) {
                case 'I':
                    makeBar(t, 0.9, 0, 0);
                    break;
                case 'L':
                    makeBar(t, 0.9, -0.25, 0);
                    makeBar(0.7, t, 0.1, -0.45);
                    break;
                case 'T':
                    makeBar(0.9, t, 0, 0.45);
                    makeBar(t, 0.9, 0, 0);
                    break;
                case 'H':
                    makeBar(t, 0.9, -0.25, 0);
                    makeBar(t, 0.9, 0.25, 0);
                    makeBar(0.6, t, 0, 0);
                    break;
                case 'E':
                    makeBar(t, 0.9, -0.25, 0);
                    makeBar(0.6, t, 0.05, 0.45);
                    makeBar(0.6, t, 0.05, 0);
                    makeBar(0.6, t, 0.05, -0.45);
                    break;
                case 'F':
                    makeBar(t, 0.9, -0.25, 0);
                    makeBar(0.6, t, 0.05, 0.45);
                    makeBar(0.5, t, 0.0, 0);
                    break;
                case 'A':
                    makeBar(t, 1.0, -0.22, 0, Math.PI / 12);
                    makeBar(t, 1.0, 0.22, 0, -Math.PI / 12);
                    makeBar(0.45, t, 0, 0.05);
                    break;
                case 'M':
                    makeBar(t, 0.9, -0.35, 0);
                    makeBar(t, 0.9, 0.35, 0);
                    makeBar(t, 0.9, 0, 0, Math.PI / 6);
                    makeBar(t, 0.9, 0, 0, -Math.PI / 6);
                    break;
                case 'N':
                    makeBar(t, 0.9, -0.3, 0);
                    makeBar(t, 0.9, 0.3, 0);
                    makeBar(t, 0.95, 0, 0, -Math.atan2(0.9, 0.6));
                    break;
                case 'V':
                    makeBar(t, 1.0, -0.18, -0.05, Math.PI / 8);
                    makeBar(t, 1.0, 0.18, -0.05, -Math.PI / 8);
                    break;
                case 'W':
                    makeBar(t, 1.0, -0.35, -0.05, Math.PI / 8);
                    makeBar(t, 1.0, -0.1, -0.05, -Math.PI / 8);
                    makeBar(t, 1.0, 0.1, -0.05, Math.PI / 8);
                    makeBar(t, 1.0, 0.35, -0.05, -Math.PI / 8);
                    break;
                case 'Y':
                    makeBar(t, 0.5, 0, -0.2);
                    makeBar(t, 0.6, -0.18, 0.25, Math.PI / 6);
                    makeBar(t, 0.6, 0.18, 0.25, -Math.PI / 6);
                    break;
                case 'Z':
                    makeBar(0.9, t, 0, 0.45);
                    makeBar(0.9, t, 0, -0.45);
                    makeBar(t, 0.95, 0, 0, -Math.atan2(0.9, 0.9));
                    break;
                case 'O': {
                    const torus = new THREE.TorusGeometry(0.4, 0.09, 12, 24);
                    const ring = new THREE.Mesh(torus, material);
                    ring.rotation.x = Math.PI / 2;
                    group.add(ring);
                    break;
                }
                case 'U': {
                    makeBar(t, 0.7, -0.28, -0.1);
                    makeBar(t, 0.7, 0.28, -0.1);
                    const torus = new THREE.TorusGeometry(0.28, t / 1.6, 12, 24, Math.PI);
                    const arc = new THREE.Mesh(torus, material);
                    arc.rotation.x = Math.PI / 2;
                    arc.position.set(0, -0.45, 0);
                    group.add(arc);
                    break;
                }
                default: {
                    // Fallback: rounded box
                    const geom = new THREE.BoxGeometry(0.8, 0.8, depth);
                    const box = new THREE.Mesh(geom, material);
                    group.add(box);
                }
            }

            // Add front letter marker for readability
            createLetterText(group, letter);
            group.userData = { letter };
            return group;
        }

        // Get letter color
        function getLetterColor(letter) {
            const colorMap = {
                'A': 0xff6384, 'B': 0x6366f1, 'C': 0x22c55e, 'D': 0xf59e0b,
                'E': 0xef4444, 'F': 0xa855f7, 'G': 0x06b6d4, 'H': 0xfb923c,
                'I': 0xec4899, 'J': 0x3b82f6, 'K': 0x10b981, 'L': 0xf56565,
                'M': 0x8b5cf6, 'N': 0x0ea5e9, 'O': 0x22c55e, 'P': 0xfb923c,
                'Q': 0xa855f7, 'R': 0xef4444, 'S': 0x06b6d4, 'T': 0x6366f1,
                'U': 0x10b981, 'V': 0xf59e0b, 'W': 0xec4899, 'X': 0x3b82f6,
                'Y': 0x8b5cf6, 'Z': 0x0ea5e9
            };
            return colorMap[letter.toUpperCase()] || 0x9ca3af;
        }

        // Create letter text
        function createLetterText(mesh, letter) {
            try {
                const textGeometry = new THREE.PlaneGeometry(0.6, 0.8);
                const textMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.9
                });
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.z = 0.11;
                mesh.add(textMesh);
                
                mesh.userData.letter = letter;
            } catch (error) {
                console.error('❌ Error creating letter text:', error);
            }
        }

        // Add lights
        function addLights() {
            try {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                // Directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                scene.add(directionalLight);
                
                // Point light for atmosphere
                const pointLight = new THREE.PointLight(0x667eea, 1, 100);
                pointLight.position.set(0, 5, 0);
                scene.add(pointLight);
                
                console.log('✅ Lights added');
            } catch (error) {
                console.error('❌ Error adding lights:', error);
            }
        }

        // Animation loop
        function animate() {
            try {
                requestAnimationFrame(animate);
                
                // Animate environment elements
                animateEnvironment();
                
                // Animate game elements if running
                if (gameRunning) {
                    animateGameElements();
                }
                
                // Render scene
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
                if (window.GameBridge) {
                    // crude FPS estimate using fixed 60fps assumption for now; optional
                    window.GameBridge.updateFPS(60);
                }
            } catch (error) {
                console.error('❌ Error in animation loop:', error);
            }
        }

        // Animate environment elements
        function animateEnvironment() {
            // Animate trees (gentle swaying)
            trees.forEach((tree, index) => {
                tree.rotation.y += 0.001 * Math.sin(Date.now() * 0.001 + index);
            });
            
            // Animate waterfall particles
            if (waterfall && waterfallActive) {
                waterfall.children.forEach((child, index) => {
                    if (child.geometry.type === 'SphereGeometry') {
                        child.position.y -= 0.05;
                        if (child.position.y < -2) {
                            child.position.y = 6;
                        }
                    }
                });
            }
            
            // Animate river water
            if (river) {
                river.children.forEach((child, index) => {
                    if (child.material && child.material.opacity) {
                        child.material.opacity = 0.6 + Math.sin(Date.now() * 0.002 + index) * 0.1;
                    }
                });
            }
        }

        // Animate game elements
        function animateGameElements() {
            // Animate falling letters
            scene.children.forEach(child => {
                if (child.userData && child.userData.type === 'falling' && child.userData.falling) {
                    child.position.y -= 0.05;
                    child.rotation.y += 0.02;
                    
                    if (child.position.y <= -1) {
                        placeLetterOnGrid(child);
                    }
                }
            });
        }

        // Toggle environment visibility
        function toggleEnvironment() {
            environmentActive = !environmentActive;
            
            // Toggle trees
            trees.forEach(tree => {
                tree.visible = environmentActive;
            });
            
            // Toggle rocks
            rocks.forEach(rock => {
                rock.visible = environmentActive;
            });
            
            // Toggle waterfall
            if (waterfall) {
                waterfall.visible = environmentActive;
            }
            
            // Toggle river
            if (river) {
                river.visible = environmentActive;
            }
            
            console.log('🌲 Environment toggled:', environmentActive ? 'ON' : 'OFF');
        }

        // Toggle waterfall
        function toggleWaterfall() {
            waterfallActive = !waterfallActive;
            console.log('🌊 Waterfall toggled:', waterfallActive ? 'ON' : 'OFF');
        }

        // Start Three.js game
        function startThreeJSGame() {
            if (!gameRunning) {
                console.log('🚀 Starting Three.js game with environment...');
                gameRunning = true;
                updateGameStatus('playing', 'En jeu');
                
                // Start game loop
                startGameLoop();
                
                // Generate first falling letter
                generateFallingLetter();
            }
        }

        // Game loop
        function startGameLoop() {
            const gameLoop = () => {
                if (gameRunning) {
                    updateGame();
                    requestAnimationFrame(gameLoop);
                }
            };
            gameLoop();
        }

        // Update game state
        function updateGame() {
            // Update falling letter
            updateFallingLetter();
            
            // Check for word completion
            checkWordCompletion();
            
            // Check level progression
            checkLevelProgression();
            
            // Update UI
            updateGameUI();
        }

        // Generate falling letter
        function generateFallingLetter() {
            if (letterQueue.length > 0) {
                currentFallingLetter = letterQueue.shift();
                console.log(`🎯 Generated falling letter: ${currentFallingLetter}`);
                
                // Create 3D falling letter
                createFallingLetter3D(currentFallingLetter);
                
                // Update letter queue display
                updateLetterQueueDisplay();
            }
        }

        // Create 3D falling letter
        function createFallingLetter3D(letter) {
            try {
                if (!scene) {
                    console.error('❌ Scene is not initialized. Reinitializing Three.js...');
                    initializeThreeJS();
                    return;
                }
                
                const letterMesh = createLetterMesh(letter);
                letterMesh.position.set(0, 8, 0);
                letterMesh.userData = { 
                    letter: letter,
                    type: 'falling',
                    falling: true
                };
                
                scene.add(letterMesh);
                console.log(`✅ Created 3D falling letter: ${letter}`);
                if (window.GameBridge) window.GameBridge.placeLetter(letter);
            } catch (error) {
                console.error(`❌ Error creating falling letter ${letter}:`, error);
            }
        }

        // Update falling letter position
        function updateFallingLetter() {
            if (!currentFallingLetter) return;
            
            if (!scene) {
                console.error('❌ Scene is not initialized in updateFallingLetter');
                return;
            }
            
            scene.children.forEach(child => {
                if (child.userData && child.userData.type === 'falling' && child.userData.falling) {
                    child.position.y -= 0.05;
                    
                    if (child.position.y <= -1) {
                        placeLetterOnGrid(child);
                    }
                }
            });
        }

        // Place letter on grid
        function placeLetterOnGrid(letterMesh) {
            try {
                const letter = letterMesh.userData.letter;
                
                const gridX = Math.floor(letterMesh.position.x / 2) * 2;
                const gridZ = Math.floor(letterMesh.position.z / 2) * 2;
                
                letterMesh.position.set(gridX, 0, gridZ);
                letterMesh.userData.falling = false;
                letterMesh.userData.type = 'placed';
                
                placedLetters.push({
                    letter: letter,
                    x: gridX,
                    z: gridZ,
                    mesh: letterMesh
                });
                
                console.log(`📍 Placed letter ${letter} at (${gridX}, ${gridZ})`);
                
                setTimeout(() => {
                    generateFallingLetter();
                }, 1000);
                
            } catch (error) {
                console.error('❌ Error placing letter on grid:', error);
            }
        }

        // Check word completion
        function checkWordCompletion() {
            targetWords.forEach(word => {
                if (isWordCompleted(word)) {
                    completeWord(word);
                }
            });
        }

        // Check if word is completed
        function isWordCompleted(word) {
            const wordLetters = word.split('');
            const placedLetterValues = placedLetters.map(pl => pl.letter);
            
            return wordLetters.every(letter => placedLetterValues.includes(letter));
        }

        // Complete word
        function completeWord(word) {
            console.log(`🎉 Word completed: ${word}`);
            
            let baseScore = 0;
            switch(word.length) {
                case 3: baseScore = 125; break;
                case 4: baseScore = 312; break;
                case 5: baseScore = 625; break;
                default: baseScore = 1250 + (word.length - 6) * 125; break;
            }
            
            const comboMultiplier = 1 + (gameCombo - 1) * 0.75;
            const totalScore = Math.floor(baseScore * comboMultiplier);
            
            gameScore += totalScore;
            gameWords += 1;
            gameCombo += 1;
            
            targetWords = targetWords.filter(w => w !== word);
            updateGameUI();
            
            console.log('📊 3D Word completion stats:', {
                word: word,
                wordLength: word.length,
                baseScore: baseScore,
                comboMultiplier: comboMultiplier,
                totalScore: totalScore,
                combo: gameCombo,
                wordsFound: gameWords
            });
        }

        // Check level progression
        function checkLevelProgression() {
            const levelRequirements = {
                1: 1250, 2: 3125, 3: 6250, 4: 12500, 5: 18750,
                6: 25000, 7: 31250, 8: 37500, 9: 43750, 10: 50000
            };
            
            const currentRequirement = levelRequirements[gameLevel];
            
            if (gameScore >= currentRequirement) {
                const previousLevel = gameLevel;
                gameLevel++;
                console.log(`🎉 Level up! Level ${previousLevel} → Level ${gameLevel}`);
                showLevelUpEffect();
            }
        }

        // Show level up effect
        function showLevelUpEffect() {
            const levelUpNotification = document.createElement('div');
            levelUpNotification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--gradient-accent);
                color: white;
                padding: 20px 40px;
                border-radius: 15px;
                font-size: 1.5rem;
                font-weight: bold;
                z-index: 10000;
                animation: levelUpAppear 1s ease-out;
            `;
            levelUpNotification.innerHTML = `🎉 Niveau ${gameLevel} !`;
            
            document.body.appendChild(levelUpNotification);
            
            setTimeout(() => {
                document.body.removeChild(levelUpNotification);
            }, 2000);
        }

        // Update game UI
        function updateGameUI() {
            document.getElementById('gameScore').textContent = gameScore;
            document.getElementById('gameLevel').textContent = gameLevel;
            document.getElementById('gameCombo').textContent = gameCombo;
            document.getElementById('gameWords').textContent = gameWords;
        }

        // Update letter queue display
        function updateLetterQueueDisplay() {
            const queueContainer = document.getElementById('letterQueue');
            if (queueContainer) {
                queueContainer.innerHTML = letterQueue.slice(0, 5).map(letter => `
                    <div class="letter-item" data-letter="${letter}">
                        <span class="letter-text">${letter}</span>
                    </div>
                `).join('');
            }
        }

        // Pause Three.js game
        function pauseThreeJSGame() {
            if (gameRunning) {
                console.log('⏸️ Pausing Three.js game...');
                gameRunning = false;
                updateGameStatus('paused', 'En pause');
            }
        }

        // Reset Three.js game
        function resetThreeJSGame() {
            console.log('🔄 Resetting Three.js game...');
            gameRunning = false;
            updateGameStatus('playing', 'Prêt');
            placedLetters = [];
            gameScore = 0;
            gameLevel = 1;
            gameCombo = 0;
            gameWords = 0;
            updateGameUI();
            letterQueue = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
            updateLetterQueueDisplay();
        }

        // Toggle fullscreen for Three.js game
        function toggleFullScreenThreeJS() {
            const canvas = document.getElementById('threeCanvas');
            if (canvas && canvas.requestFullscreen) {
                canvas.requestFullscreen();
            } else if (canvas && canvas.webkitRequestFullscreen) {
                canvas.webkitRequestFullscreen();
            } else if (canvas && canvas.msRequestFullscreen) {
                canvas.msRequestFullscreen();
            }
        }

        // Update game status indicator
        function updateGameStatus(status, text) {
            const statusElement = document.getElementById('gameStatus');
            const textElement = document.getElementById('gameStatusText');
            
            if (statusElement && textElement) {
                statusElement.className = `game-status ${status}`;
                textElement.textContent = text;
                statusElement.style.display = 'flex';
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🌲 Three.js Game with Environment Page loaded');
            initializeThreeJSGame();
            // Signal that the game is initialized for E2E tests
            window.gameInitialized = true;
            
            // Mobile Navigation Toggle
            const navToggle = document.querySelector('.unified-nav-toggle');
            const navMenu = document.querySelector('.unified-nav-menu');
            const navLinks = document.querySelectorAll('.unified-nav-link');

            navToggle.addEventListener('click', function() {
                const isExpanded = navToggle.getAttribute('aria-expanded') === 'true';
                navToggle.setAttribute('aria-expanded', !isExpanded);
                navToggle.classList.toggle('active');
                navMenu.classList.toggle('active');
            });

            navLinks.forEach(link => {
                link.addEventListener('click', function() {
                    navToggle.classList.remove('active');
                    navMenu.classList.remove('active');
                    navToggle.setAttribute('aria-expanded', 'false');
                });
            });

            document.addEventListener('click', function(event) {
                if (!navToggle.contains(event.target) && !navMenu.contains(event.target)) {
                    navToggle.classList.remove('active');
                    navMenu.classList.remove('active');
                    navToggle.setAttribute('aria-expanded', 'false');
                }
            });

            navToggle.addEventListener('keydown', function(event) {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    navToggle.click();
                }
            });

            const currentPage = window.location.pathname.split('/').pop() || 'index.html';
            navLinks.forEach(link => {
                const href = link.getAttribute('href');
                if (href === currentPage) {
                    link.setAttribute('aria-current', 'page');
                }
            });

            let lastScrollTop = 0;
            const navHeader = document.querySelector('.unified-nav-header');
            
            window.addEventListener('scroll', function() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                
                if (scrollTop > lastScrollTop && scrollTop > 100) {
                    navHeader.style.transform = 'translateY(-100%)';
                } else {
                    navHeader.style.transform = 'translateY(0)';
                }
                
                lastScrollTop = scrollTop;
            });
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            if (camera && renderer) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.width / canvas.height;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.width, canvas.height);
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', function(event) {
            switch(event.key.toLowerCase()) {
                case 'p':
                    if (gameRunning) {
                        pauseThreeJSGame();
                    } else {
                        startThreeJSGame();
                    }
                    break;
                case 'r':
                    resetThreeJSGame();
                    break;
                case 'f':
                    toggleFullScreenThreeJS();
                    break;
                case 'e':
                    toggleEnvironment();
                    break;
                case 'w':
                    toggleWaterfall();
                    break;
            }
        });
    </script>
    
    <!-- Three.js Library -->
    <script src="js/libs/three.min.js"></script>
    <script src="js/libs/tween.umd.js"></script>
    <script src="js/libs/FBXLoader.js"></script>
    
    <!-- Game Scripts -->
    <script src="js/shaders.js"></script>
    <script src="js/game3d.js"></script>

    <footer class="glass-panel" id="page-footer" style="margin: var(--spacing-xl,2rem) 0; text-align:center;"></footer>
  
    <script>(function(){try{var el=document.getElementById('page-footer');if(el){var d=new Date();el.textContent=d.toLocaleDateString('fr-FR',{year:'numeric',month:'long',day:'numeric'});}}catch(e){}})();</script>
  </body>
</html> 